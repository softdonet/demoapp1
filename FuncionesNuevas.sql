estado_comproba
fn_list_address

fspiuselect * from ALMACEN.FN_PRODUCTOS_ALMACEN(1,'a',1)

 select * from contabilidad.list__libromayor(3,1,4,0,12)

select * from ventas.list_importeventasdiariasMensual(2017,1)

select * from ALMACEN.ISP_DETELETEUNIDADINVENTARIO(1,'28',6,1,1,NULL,'0',NULL,NULL,'0')

select *from compras.list_importecomprasdiariasmensual(20fn_list_address
													   17,1);

select *from compras.list_importecomprasProductomensual(2017,1)
select *from compras.list_CantidadcomprasProductomensual(2017,1)
select *from compras.list_HistoricoPrecioscomprasProductomensual(2017,1)
select *from compras.fn_list_HistoricoPrecioscomprasProductomensual(2017,1)
select *from almacen.list_IngresoProductosTerminadosProduccion(2017,1) where mes=11 and id_producto='12'  
select *from almacen.fn_list_IngresoProductosTerminadosProduccion(2017,1) 

select date_part('month',fec_documento) as mes , dc.cantidad,dc.precio, c.* from compras.tbl_detcompra dc
inner join compras.tbl_compra c on c.id__compra=dc.id__compra  and c.id_sucursalcompra=dc.id_sucursalcompra 
 where date_part('year',fec_documento)=2017 and  id_producto='79' and dc.id_estado=1 and dc.id_sucursalcompra=1
order by date_part('month',fec_documento)

CAJA.SPI_MOVCAJAINGDIVERSOS
select *from seguridad.item where menu ilike '%Registro%compras%'

select *from common.tbl_sucursal


select *from creditos.v_letras_pendientes_x_cobrar

select *from Ventas.list_CantidadventasDiadriasProductos(1,2018,1);
select *from Ventas.fn_list_CantidadventasDiadriasProductos(1,2017,1);


select * from ALMACEN.FN_IMPORTAR_PRODUCTS('002117','NET VOLEY PROFESIONAL 10 X 100 COCOS CABLE ACERO VERTEGO 72','02','ARTICULO DEPORTIVO','0074','NET','482','VERTEGO',2,'NINGUNO',0,'NINGUNO',14,'UND *M',1,1,1,'0.00','65.0','92.0','0.0','0.0','0.0','0.0','120.0')

select distinct id_unidad,unidad from almacen.tbl_import_producto order by 2

delete from ventas.tbl_items
delete from almacen.tbl_unidad

select * from  almacen.tbl_import_producto where id_unidad=14

update almacen.tbl_import_producto set unidad='UND *M' where id_unidad=14


SELECT  ROW_NUMBER () OVER (ORDER BY SUM(DF.CANTIDAD) DESC), P.ID_PRODUCTO,P.DESCRIPCION_LARGA AS PRODUCTO, SUM(DF.CANTIDAD) AS CANTIDAD FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN ALMACEN.TBL_DETPRODUCTO UN ON UN.ID_UNIDADVENTA=DF.ID_UNIDADVENTA AND DF.ID_PRODUCTO=UN.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=UN.ID_PRODUCTO
WHERE F.ID_ESTADO=1 AND DF.ID_ESTADO=1
GROUP BY P.ID_PRODUCTO,P.DESCRIPCION_LARGA
ORDER BY 4 DESC

SELECT *FROM ALMACEN.TBL_DETPRODUCTO

select *from contabilidad.tbl_auxiliar
select *from contabilidad.tbl_subdiario


SELECT  ROW_NUMBER () OVER (ORDER BY SUM(DF.CANTIDAD) DESC), P.ID_PRODUCTO,P.DESCRIPCION_LARGA AS PRODUCTO, SUM(DF.CANTIDAD) AS CANTIDAD FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN ALMACEN.TBL_DETPRODUCTO UN ON UN.ID_UNIDADVENTA=DF.ID_UNIDADVENTA AND DF.ID_PRODUCTO=UN.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=UN.ID_PRODUCTO
WHERE F.ID_ESTADO=1 AND DF.ID_ESTADO=1
GROUP BY P.ID_PRODUCTO,P.DESCRIPCION_LARGA
ORDER BY 4 DESC



SELECT trim(COALESCE(CLI.NOMBRE_RAZON,CLI.APELL_MATERNO || ' ' || CLI.APELL_PATERNO  || ' ' ||CLI.NOMBRES)) AS CLIENTE,SUM(F.IMP_TOTAL) AS total FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=F.ID_CLIENTE
INNER JOIN ALMACEN.TBL_DETPRODUCTO UN ON UN.ID_UNIDADVENTA=DF.ID_UNIDADVENTA AND DF.ID_PRODUCTO=UN.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=UN.ID_PRODUCTO
WHERE F.ID_ESTADO=1 AND DF.ID_ESTADO=1
 group by COALESCE(CLI.NOMBRE_RAZON,CLI.APELL_MATERNO || ' ' || CLI.APELL_PATERNO  || ' ' ||CLI.NOMBRES)
 order by 2 desc

select *from seguridad.item where evento ilike '%frmUtilidaesporproducto%'
 

SELECT *FROM VENTAS.TBL_FACTURACION
SELECT *FROM PLANILLAS.TBL_PERSONA

select *from  common.tbl_concepto where descripcion_larga ilike '%ENVA%'

select * from contabilidad.isp_configuracioncuenta(1,0,63,52,'998',1,1,1,'','')

select * from contabilidad.tbl_configuracioncuenta 

select *from contabilidad.v_conceptos

select * from contabilidad.list_configuracioncuentas(2,1,13,'')

select *from contabilidad.tbl_configuracioncuenta ccta

select * from contabilidad.v_plancuenta  

select *from CONTABILIDAD.TBL_CONFIGIMPUESTO

select *from almacen.tbl_precio where costo>0

select 279.804545454545454544680000-198.80000000

select ((279.804545454545454544680000-198.80000000)*100)/279.804545454545454544680000

select *from VENTAS.fn_rentabilidad_x_producto(2,1,'01/01/2014','31/12/2018','1')

select *from almacen.tbl_familia
select *from VENTAS.fn_rentabilidad_x_cliente(1,1,'01/01/2018','31/12/2018');


select *from  PRODUCT_ATTRIBUTES

select * from almacen.fn_elminar_serie_producto(1)


select * from VENTAS.ISP_CONTACTO(1,NULL,'42607389','GUEVARA YLATOMA','JOSE','','-','','','','','','','','','','','','0.00','0.00',0,1,'','99999999','','','','','0.00','0.00','',NULL,1,1,1,'1',1,1)

select * from caja.spi_licadaCaja(1,1,1,8,'1','2018-06-13 18:07:48.002','13/06/2018','1')

select *from contabilidad.tbl_axuliardocumento

ALTER TABLE contabilidad.tbl_axuliardocumento
  ADD CONSTRAINT tbl_axuliardocumento_id_auxiliar_fkey FOREIGN KEY (subdiario_id)
      REFERENCES contabilidad.tbl_auxiliar (id) MATCH SIMPLE

select shard_1.id_generator();


select *from ventas.order_list(1);
select * from ventas.order_list(01) 
select *from common.tbl_comprobante



select * from ventas.ISP_SEGIMCOTIZACION(1,0,'2020-07-22 21:39:56.723','sss','ss','2020-07-22 21:39:56.723','s',1,'1',3420,1)

select * from ventas.V_CABCOTIZACION   where id_sucursal=1 and  documento || doc_persona || cliente ilike '%%'  



select *from ventas.tbl_cotizacionpreventa where fecha::date=now()::Date

select * from compras.fn_dscto_notacredito(32,1)

select  *from planillas.fn_asistencia('','');

select *from almacen.fn_get_existencias(0);

select *from seguridad.fn_user_get('1')

select * from common.tbl_estado

select  *from ventas.fn_order_getbydelivery('1','')

select *from ventas.fn_order_getbydelivery('','1');

select * from ventas.fn_order_getbydelivery('1', '1')

select  *from almacen.fn_getproducts_bysubsidiary('','','');


select *from caja.list_caja_saldos('30/04/2021','08/05/2021')



CREATE OR REPLACE FUNCTION almacen.tbl_datos_adicionales_producto_venta(
	_id integer ,
	_item integer,
	_key text,
	_value text,
	_id_producto varchar(30),
	_id_unidadventa integer,
	_id_facturacion integer,
	_id_sucursal integer,
	_id_estado integer
) RETURNS TEXT[] AS $$
DECLARE
	RES TEXT[];
BEGIN
	UPDATE almacen.tbl_datos_adicionales_producto_venta SET id_Estado=3 
	where id_producto=_id_producto  and item=_item and id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
	INSERT INTO almacen.tbl_datos_adicionales_producto_venta(
		item,
		key,
		value,
		id_producto,
		id_unidadventa,
		id_facturacion,
		id_sucursal,
		id_estado
	)values(
		_item,
		_key,
		_value,
		_id_producto,
		_id_unidadventa,
		_id_facturacion,
		_id_sucursal,
		_id_estado
	) ;
	RES:=ARRAY['0','Registrado correctamente'];
	IF NOT FOUND THEN
		RES:=ARRAY['501','Ocurrio un erro al registrar datos adicionales ..Intente nuevamente'];
	END IF;
	
return res;	
END;$$
LANGUAGE 'plpgsql';

create or replace function caja.list_caja_saldos(
	f1 text,
	f2 text
)
returns table(
	documento text,
	dia integer,
	mes integer,	
	cliente text,
	importe numeric(20,4)
) as $$
declare
begin
create temporary table temps(
	documento text,
	mes integer,
	dia integer,
	cliente text,
	importe numeric(20,6)
) on commit drop;
insert into temps
  select 
	'' AS Documento,
	0 as dia,
	0 as mes,
	'************ SALDO ANTERIOR *******************' as Mensaje,
	 sum(imp_movimiento*(COALESCE(signo,1)))  as Importe	 
	from caja.tbl_movcaja mov	
	where fecha_mov<f1::date;
	
	insert into temps
	select 
		serie || '-'|| numero as documento ,
			date_part('day',fecha_mov) as dia,
		date_part('month',fecha_mov) as mes,
		nomape_cliente as cliente,
		sum(imp_movimiento*(COALESCE(signo,1))) as importe
	from caja.tbl_movcaja mov	
	where fecha_mov>=f1::date
	group by serie,numero,nomape_cliente, fecha_mov 
	order by mov.fecha_mov asc;
	return query select *from temps ;
end;$$
language 'plpgsql';


select *from caja.list_caja_acumulada('01/05/2021','11/05/2021')

create or replace function caja.list_caja_acumulada(
	f1 text,
	f2 text
)
returns table(
	op integer,
	mensaje text,
	fecha date,
	dni text,
	colaborador text,
	apertura numeric(20,4),	
	deposito numeric(20,4),
	tarjeta numeric(20,4),
	efectivo numeric(20,4),
	egreso numeric(20,4),
	saldo numeric(20,4)
) as $$
declare
begin
create temporary table temps(
	op integer,
	mensaje text,
	fecha date,
	dni text,
	colaborador text,
	apertura numeric(20,4),	
	deposito numeric(20,4),
	tarjeta numeric(20,4),
	efectivo numeric(20,4),
	egreso numeric(20,4),
	saldo numeric(20,4)
) on commit drop;
insert into temps
select  1 as op,
		x .mensaje,
		x.fecha,
		x.dni,
		x.colaborador,
		sum(x.apertura) as apertura,
		sum(x.deposito) as deposito,
		sum(x.tarjeta) as tarjeta,
		sum(x.efectivo) as efectivo ,
		sum(x.egreso) as egreso 
	from (
  select 
	'*********SALDO ANTERIOR*********' as mensaje,	
	 f1::date as fecha,
	  vend.doc_persona as dni,
	  vend.nombre_razon as Colaborador,
	 0 AS apertura,
	 case when dmov.id_formapago='03' AND COALESCE(signo,1)=1 then imp_movimiento*(COALESCE(signo,1)) else 0 end as deposito,
	 case when dmov.id_formapago='02' AND COALESCE(signo,1)=1 then imp_movimiento*(COALESCE(signo,1)) else 0 end as tarjeta,
	 case when dmov.id_formapago='01' AND COALESCE(signo,1)=1 then imp_movimiento*(COALESCE(signo,1)) else 0 end as efectivo,
	 case when mov.signo=-1 then imp_movimiento else 0 end as egreso	   
	from caja.tbl_movcaja mov	
	inner join planillas.tbl_persona vend on vend.id_persona=mov.id_persona
	inner join caja.tbl_detmovpago dmov on mov.id_movimcaja=dmov.id_movimcaja  
	where fecha_mov::date<f1::date and mov.id_estado=1
	) x group by x.fecha,
	x.dni,x.colaborador,x .mensaje;
	 
	
	insert into temps
	select 
		2 as op,
		x.colaborador,
		x.fecha,
		x.dni,
		x.colaborador,
		sum(x.apertura) as apertura,
		sum(x.deposito) as deposito,
		sum(x.tarjeta) as tarjeta,
		sum(x.efectivo) as efectivo ,
		sum(x.egreso) as egreso 
	from (
select 
	 mov.fecha_mov::date as fecha,
	 vend.doc_persona as dni,
	 vend.nombre_razon as Colaborador,
	 0 AS apertura,
	 case when dmov.id_formapago='03' and COALESCE(signo,1)=1  then imp_movimiento else 0 end as deposito,
	 case when dmov.id_formapago='02' and COALESCE(signo,1)=1 then imp_movimiento else 0 end as tarjeta,
	 case when dmov.id_formapago='01' and COALESCE(signo,1)=1 then imp_movimiento else 0 end as efectivo,
	 case when COALESCE(signo,1)=-1 then imp_movimiento else 0 end as egreso	   
	from caja.tbl_movcaja mov	
	inner join caja.tbl_detmovpago dmov on mov.id_movimcaja=dmov.id_movimcaja
	inner join planillas.tbl_persona vend on vend.id_persona=mov.id_persona
	where mov.id_estado=1 and fecha_mov::date>=f1::date  and fecha_mov::date<=f2::date
) x 
group by x.fecha::date,x.dni,x.colaborador
order by x.fecha::Date asc;
	return query select t.*from temps t order by  t.dni,t.op,t.fecha asc;
end;$$
language 'plpgsql';


select * from planillas.tbl_persona
select * from caja.tbl_movcaja mov where signo is not null


SELECT  *FROM COMMON.TBL_FORMAPAGO

CREATE OR REPLACE FUNCTION creditos.getfunccalmora(
	_id_cuota integer)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
	data record;
	mora numeric ;--double precision ;
	saldo numeric(30,14) ;
	return_mora numeric;
begin
mora:=0.00;
select --generaIntereses(x.saldo,convertirTemToTead(2), CAST( now() AS DATE)-CAST(fec_vencimiento AS DATE)) 
case when (CAST( now() AS DATE)-(CAST(fec_vencimiento AS DATE))-8)>0 then
((x.saldo*0.1)/100)*(CAST( now() AS DATE)-(CAST(fec_vencimiento AS DATE))-8)
else 0 end
into mora from
(select 
cc.id_cuotas,
cc.nro_cuota,
CC.imp_cuota,
fec_vencimiento::date, 
trunc(CC.imp_cuota-COALESCE(imp_pago,0)- COALESCE(( SELECT sum(COALESCE(nc.imp_dscto, 0::numeric)) AS sum
           FROM creditos.tbl_cuota_notacredito nc
          WHERE cc.id_cuotas = nc.id_cuota AND cc.id_credito = nc.id_credito AND cc.id_sucursal_credito = nc.id_sucursal_cred AND nc.id_estado = 1), 0::numeric),2) as saldo
 from creditos.tbl_cuota cc
left join (
	select  ccc.id_cuotas,ccc.id_credito,ccc.id_sucursal_credito,sum(dpc.imp_pago) as imp_pago from creditos.tbl_cuota ccc 
	inner join creditos.tbl_detpagocuota dpc on ccc.id_cuotas=dpc.id_cuotas and ccc.id_credito=dpc.id_credito and  ccc.id_sucursal_credito=dpc.id_sucursal_credito
	inner join caja.tbl_movcaja mov on  (mov.id_movimcaja=dpc.id_movimcaja and  mov.id_sucursal=dpc.id_sucursal)
	where mov.id_estado=1 and dpc.id_estado=1
	group by ccc.id_credito,ccc.id_sucursal_credito,ccc.id_cuotas
) pagc on pagc.id_credito=cc.id_credito and  pagc.id_sucursal_credito=cc.id_sucursal_credito and pagc.id_cuotas=cc.id_cuotas
) x
where trunc(x.saldo,2)>0 and x.fec_vencimiento<now() and-- x.nro_cuota<>0 and 
x.ID_CUOTAs=_id_cuota;


	if mora is not Null then
		return_mora:= MORA;
		/*select   (CC.total_cuota+CC.importe_mora-COALESCE((SELECT sum(M.monto_total) FROM OPERACIONES.MOVIMIENTO M 
		WHERE CC.IDCUOTA=M.IDCUOTA  and (m.anulado='0' or m.anulado='N') ) ,0)) into saldo  from creditos.cuota cc WHERE CC.IDCUOTA=_id_cuota;
		if trunc(saldo,2)>0 then
			--update creditos.cuota set importe_mora=mora where  IDCUOTA=_ID_CUOTA;
			return_mora:= MORA;
		ELSE
			return_mora:=0;	
		end if;*/
		
	else
		return 0;
	end if;
return return_mora;	
end;
$BODY$;

CREATE OR REPLACE FUNCTION almacen.fn_update_stock(
	_product_id character varying,
	_unit_id integer,
	_stock numeric(20,4),
	_reserva numeric(20,4)
	)
    RETURNS TABLE(statuscode integer, statusmessage text)     
AS $$
DECLARE 
 res text;	
BEGIN
	 update almacen.tbl_existencia set stock_fisico=_stock,stock_reserva=_reserva where id_producto=_product_id and id_unidadventa=_unit_id;
	 return query select 1 as statuscode,'Stock Actualizado' as statusmessage;

END;$$
LANGUAGE 'plpgsql';
  
select *from almacen.fn_update_stock('',1,0,0);
select  *from almacen.fn_get_stock_mobil(5);
select * from almacen.fn_get_stock_mobil(331,2)

select * from almacen.fn_get_stock_mobil(2,333)

select *from planillas.fn_list_customers(99,'',0);

select  *from ventas.tbl_facturacion where numdoc_Facturacion::integer=26867 and id_comprobante=2


update  ventas.tbl_facturacion set serie_facturacion='B001',id_comprobante=2 where numdoc_Facturacion::integer=26867 and id_comprobante=3






create or replace   function planillas.fn_list_customers(
	op integer,
	_customerId text,
	_addresId bigint
)returns table(
	customerId varchar(15),
	estadoCivilId integer,
	doc_persona varchar(12),
	nombre_razon varchar(500),
	razon_comercial varchar(200),
	sexo char(1),
	email varchar(100),
	paguinaweb text,
	fecha_nac timestamp,
	tipo_persona boolean,
	cliente_proveedor boolean,
	deuda_confidencial boolean,
	no_apto_credito boolean,
	concientizado boolean,
	copropietario boolean,
	observaciones text,
	estadoId integer,
	vendtitularId char(15),
	venSuplenteId char(15),
	colaboradorId char(15),
	imp_minimoventa numeric(20,4),
	percep_cliente boolean,
	agente_perceptor boolean,
	coopropietarioId integer,
	tipDocIdentidadId integer,
	porcent_percepcion numeric(20,4),
	persona_refId varchar(15),
	direccion_refId  bigint,
	facturar_a_clienteref boolean,
	gestiona_lineacredito boolean,
	address json
) as $$
declare
begin
return query select 
	p.id_persona as customerId,
	p.id_estadocivil as estadocivilId,
	p.doc_persona,
	p.nombre_razon,
	p.razon_comercial,
	p.sexo,
	p.email,
	p.paginaweb,
	p.fecha_nac,
	p.tipo_persona,
	p.cliente_proveedor,
	p.deuda_confidencial,
	p.no_apto_credito,
	p.concientizado,
	p.copropietario,
	p.observaciones,
	p.id_estado as estadoId,
	p.id_vendtitular  as  vendtitularId,
	p.id_vendsuplente as vendsuplenteId,
	p.id_cobrador cobradorId,
	p.imp_minimoventa,
	p.percep_cliente,
	p.agente_perceptor,
	0 as coopropietarioId,
	p.id_tipdocidentidad as  tipdocidentidadId,
	p.porcent_percepcion,
	p.id_persona_ref as persona_refId,
	p.id_direccion_ref as direccion_refId,
	p.facturar_a_clienteref,
	p.gestiona_lineacredito	,
	(
	 select array_to_json(array_agg(row_to_json(d)))
      from (        
       select 
			dir.id_persona,
			dir.id_direccion,
			dir.direccion,
			dir.referencia,
			dir.id_sector,
			dir.id_estado,
			dir.id_direccion,
			dir.id_tipvivienda
		from ventas.tbl_direccion dir
		where dir.id_persona=p.id_persona             
      ) d
    ) as Address
	 from planillas.tbl_persona p	
	 where p.id_persona=_customerId ;--and dir.id_direccion=_addresId;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION planillas.fn_list_address(
	op integer,
	_customerId text
)
returns table(
	customerId varchar(15),
	direccionId bigint,
	direccion text,
	referencia text,
	id_sector integer,
	id_estado integer,
	id_direccion bigint,
	id_tipvivienda integer
) as $$
declare
begin
return query select 
	dir.id_persona,
	dir.id_direccion,
	dir.direccion,
	dir.referencia,
	dir.id_sector,
	dir.id_estado,
	dir.id_direccion,
	dir.id_tipvivienda
from ventas.tbl_direccion dir
where dir.id_persona=_customerId;
end;$$
language 'plpgsql';

select  *from ventas.tbl_direccion
select *from  planillas.tbl_persona


select  *from seguridad.tbl_usuario
create or replace function almacen.fn_get_stock_mobil(
	op integer,
	order_id bigint
)
returns table (
	producto_id varchar(30),
	unit_id integer,
	stock numeric(20,6),
	reserva numeric(20,2),
	preventa_id bigint
) as $$
declare 
begin
	if op=1 then
		return query select e.id_producto,e.id_unidadventa,stock_fisico,stock_reserva,id_cotizapreventa from almacen.tbl_existencia e
		inner join ventas.tbl_detpreventacotiza dc on e.id_producto=dc.id_producto 
		where dc.id_cotizapreventa=order_id;
	end if;
	if op=2 then
		return query select e.id_producto,e.id_unidadventa,stock_fisico,stock_reserva,id_facturacion::bigint as id_facturacion from almacen.tbl_existencia e
		inner join ventas.tbl_detfacturacion dc on e.id_producto=dc.id_producto 
		where dc.id_facturacion=order_id;
	end if;
end;$$
language 'plpgsql';

select *from almacen.fn_get_stock_mobil(5);

select *from almacen.tbl_existencia

CREATE OR REPLACE FUNCTION ventas.fn_rentabilidad_x_producto(
	op integer,
	_id_empresa integer,
	_f_desde character varying,
	_f_hasta character varying,
	_id_familia character varying)
    RETURNS TABLE(
	id_producto text, 
	producto text, 
	familia text, 
	marca text, 
	unidad text, 
	valor numeric, 
	cantidad numeric, 
	precio numeric, 
	total_venta numeric, 
	precio_compra numeric, 
	total_compra numeric, 
	codigo text, 
	cod_barra text
) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
declare
  begin
  if op=1 then
	return query select 
x.id_producto::text,
x.producto::text,
x.familia:: text as familia,
x.marca::text,
x.unidad::text,
x.valor,
x.cantidad,
x.importe/x.cantidad as precio,
x.total_venta,
x.costo/x.val_unidad as precio_compra,
(x.costo/x.val_unidad )*x.cantidad as total_compra,
x.codigo::text,
x.codigo_barra::text

 from (sELECT 
		P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		M.DESCRIPCION_LARGA AS MARCA,
		U.DESC_LARGA AS UNIDAD,
		DP.VAL_UNIDAD AS VALOR,
		SUM(x.cantidad) as cantidad,
		sum(df.importe) as importe,
		SUM(DF.importe) AS TOTAL_VENTA,
		sum(df.costo) as costo,
		sum(df.val_unimedventa) as val_unidad,
		p.codigo::text as codigo,
		DDP.codigo_barra::text as codigo_barra
		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
		INNER JOIN ALMACEN.TBL_DETPRODUCTO DDP ON(DDP.ID_PRODUCTO=DF.ID_PRODUCTO and ddp.unidad_inventario=true)
		JOIN LATERAL almacen.fn_stock(df.id_producto, df.id_unidadventa, df.id_almacen, df.cantidad) x(product_id, unit_id, val_unit, stock, cantidad) ON (((x.product_id)::text = (ddp.id_producto)::text))
		inner join ALMACEN.TBL_PRECIO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=X.UNIT_ID
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
		INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
		INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
		JOIN almacen.tbl_unidad u ON ((u.id_unidadventa = x.unit_id))
		INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL
		LEFT JOIN (SELECT 
				FF.ID_FACTURACIONREF AS ID_FACTURACION,
				FF.ID_SUCURSALREF AS ID_SUCURSAL,
				DFF.ID_PRODUCTO,DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO AS _ID_PRODUCTO ,
				SUM(DFF.CANTIDAD) AS CANTIDAD,
				SUM(DFF.importe)  AS IMPORTE				
			FROM VENTAS.TBL_FACTURACION FF 
			INNER JOIN VENTAS.TBL_DETFACTURACION DFF ON FF.ID_FACTURACION =DFF.ID_FACTURACION AND FF.ID_SUCURSAL=DFF.ID_SUCURSAL
			WHERE FF.NOTA_CREDITO=TRUE
			GROUP BY 
			        FF.ID_FACTURACIONREF,
				FF.ID_SUCURSALREF,
				DFF.ID_PRODUCTO,
				DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO 
			) Z ON Z.ID_FACTURACION=F.ID_FACTURACION AND Z.ID_SUCURSAL=F.ID_SUCURSAL AND DF.ID_PRODUCTO=Z._ID_PRODUCTO AND Z.ID_UNIDADVENTA=DF.ID_UNIDADVENTA	 
		where f.id_estado=1 and df.id_estado=1 
		AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE>=_f_desde::DATE AND F.FECHA_VENTA::DATE<=_f_hasta::DATE AND F.NOTA_CREDITO=FALSE
		--AND F.ID_FACTURACION::TEXT || F.ID_SUCURSAL::TEXT NOT IN (SELECT FF.ID_FACTURACIONREF::TEXT || FF.ID_SUCURSALREF::TEXT FROM VENTAS.TBL_FACTURACION FF WHERE FF.NOTA_CREDITO=TRUE and ff.id_estado=1 )
		GROUP BY P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA ,
		Fa.DESCRIPCION_LARGA ,
		M.DESCRIPCION_LARGA ,
		U.DESC_LARGA ,
		DP.VAL_UNIDAD,
		dp.id_producto,
		dp.id_unidadventa,		
		z.cantidad,z.importe,DDP.codigo_barra
		ORDER BY Fa.DESCRIPCION_LARGA
		) as x;
end if;
if op=2 then
	return query SELECT 
		P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		M.DESCRIPCION_LARGA AS MARCA,
		U.DESC_LARGA AS UNIDAD,
		DP.VAL_UNIDAD AS VALOR,
		SUM(DF.CANTIDAD) AS CANTIDAD,
		AVG(DF.PRECIO) AS PRECIO,
		AVG(DF.PRECIO)*SUM(DF.CANTIDAD) AS TOTAL_VENTA,
		dp.coste AS precio_compra,
		dp.coste*SUM(DF.CANTIDAD) as total_compra,
		p.codigo::text as codigo,
		DDP.codigo_barra::text as codigo_barra
		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
		INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
		INNER JOIN ALMACEN.TBL_DETPRODUCTO DDP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DDP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
		INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
		INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
		INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)  
		INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL
		where f.id_estado=1 and df.id_estado=1 and fa.id_familia=_id_familia AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE BETWEEN _f_desde::DATE AND _f_hasta::DATE
		GROUP BY P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA ,
		Fa.DESCRIPCION_LARGA ,
		M.DESCRIPCION_LARGA ,
		U.DESC_LARGA ,
		DP.VAL_UNIDAD,
		dp.id_producto,
		dp.id_unidadventa,
		dp.coste,DDP.codigo_barra
		ORDER BY Fa.DESCRIPCION_LARGA;
end if;
  end;
$BODY$;
select * from ventas.fn_rentabilidad_x_producto(1,1,'01/03/2021','27/03/2021','1    ')

create or replace function almacen.update_costo()
returns text as  $$
declare
  det record;
  dat record;
begin
 CREATE TEMPORARY TABLE temp_data(
	id_producto text,
	id_unidad integer,
	val_unidad numeric(20,4),
	costo numeric(20,6),
	fecha TIMESTAMP
 )
 ON COMMIT DROP;

  CREATE  TABLE temp_data_costos(
	id_producto text,
	id_unidad integer,
	val_unidad numeric(20,4),
	costo numeric(20,6),
	fecha TIMESTAMP
 );
for det in select * from almacen.list_kardex_batch('01/11/2017','27/11/2021',1,1) loop
	INSERT INTO temp_data(id_producto,id_unidad,val_unidad,costo,fecha)VALUES(DET.codarti,det.idunimed,0,det.c_unid3,det.fecha);
	/*update almacen.tbl_detfacturacion set costo=det.c_unid3 from ventas.facturacion fac
	where fac.id_facturacion=tbl_detfacturacion.id_facturacion 
	and fac.id_sucursal=tbl_detfacturacion.id_facturacion 
	and det.codarti=tbl_detfacturacion.id_producto and */
end loop;

for dat in select * from temp_data loop
	insert into temp_data_costos
	select  id_producto,id_unidadventa,val_unidad,dat.costo*val_unidad,dat.fecha from almacen.tbl_precio where id_producto=dat.id_producto;
end loop;


update ventas.tbl_detfacturacion set costo=pre.costo,val_unimedventa=pre.val_unidad 
from temp_data_costos pre 
where tbl_detfacturacion.id_producto=pre.id_producto and 
tbl_detfacturacion.id_unidadventa=pre.id_unidad and tbl_detfacturacion.fecha::date=pre.fecha::date;-- and tbl_detfacturacion.id_producto not in ('603','92')



return '';
end;$$
language 'plpgsql';

select almacen.update_costo();

CREATE OR REPLACE FUNCTION almacen.fn_getproducts_bysubsidiary(
	_enterpriseid character varying,
	_categoryid character varying,
	_subsidiaryid character varying)
    RETURNS TABLE(
	resourceid varchar(20), 
	productname varchar(200), 
	description text, 
	logo text, 
	price numeric(20,6), 
	stock text, 
	ispromotion boolean,
	statusId integer,
	code char(30),
	family varchar(100),
	unit text
) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE _categoria integer;
BEGIN
/*
	select a.id into _categoria
	from delivery.category a
	where a.uuid = _categoryid;*/
--select  *from almacen.v_productosalmacen
--select *from almacen.tbl_producto
	RETURN QUERY
		SELECT 	
			a.id_producto as productoid, 
			a.producto as productname, 
			p.caracteristicas as descripcion,
			null as logo, 
			a.precio1 as price, 
			coalesce(a.disponible ,'0') as stock, 
			false as promotion,
			p.id_estado,
			p.codigo,
			a.famila,
			coalesce(a.unidad::text,'-') as unidad
		FROM almacen.v_productosalmacen a 
		inner join almacen.tbl_producto p on p.id_producto=a.id_producto
		--inner join delivery.subsidiary s on a.subsidiary_id = s.id
		where a.id_estado=1 and p.descripcion_larga ilike '%' || _categoryid || '%'  ;
				/*and s.status
				and a.category_id=_categoria 
				and s.enterprise_id = _enterpriseid
				and s.uuid = _subsidiaryid;*/
END;
$BODY$;

CREATE OR REPLACE FUNCTION ventas.fn_order_getbydelivery(
	_enterprise_id character varying,
	_delivery_id character varying)
    RETURNS TABLE(
	resourceid bigint, 
	document_type varchar(30), 
	payment_method varchar(20), 
	order_satus_id integer, 
	order_satus varchar(20), 
	order_number text, 
	full_name varchar(500), 
	resource_user varchar(15), 
	phone_number text, 
	order_date character varying, 
	ubigeo_destination varchar(8), 
	address_destination text, 
	reference_destination text, 
	x numeric(20,12), 
	y numeric(20,12), 
	amount numeric(20,6), 
	tax numeric(20,6), 
	discount numeric(20,6), 
	total_amount numeric(20,6), 
	document_number varchar(12), 
	business_name varchar(500), 
	address text, 
	document_ref text, 
	delivery_amount numeric
) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
---select  *from common.tbl_tipoventa
    return query 
        select  a.id_cotizapreventa as resourceid,
                c.descripcion_larga as document_type,
                d.descripcion_larga as payment_method,
                s.id_estado order_satus_id,
                s.des_estado as order_satus,
                a.serie || '-' ||numero as order_number,
                b.nombre_razon as full_name,
		b.id_persona as resource_user,
		COALESCE(b.phone_number,'') as phone_number,
                cast(CASE WHEN a.fecha IS NULL THEN '' ELSE to_char(a.fecha, 'DD/MM/YYYY') END as character varying) as order_date,
                dis.id_distrito  as ubigeo_destination,
                dir.direccion as address_destination,
                dir.referencia as reference_destination,
                a.x_destination as x,
                a.y_destination as y,
                a.imp_bruto as amount,
                a.imp_igv as tax,
                a.imp_dscto as discount,
                a.imp_total as total_amount,
                b.doc_persona as document_number,
                b.nombre_razon as business_name,
                dir.direccion as address,
                '' as document_ref,
		coalesce(a.delivery_amount, 0)
        from ventas.tbl_cotizacionpreventa a 
        inner join planillas.tbl_persona b on a.id_cliente = b.id_persona
        inner join ventas.tbl_direccion dir on dir.id_direccion=a.id_direccion and dir.id_persona=a.id_cliente
        inner join ventas.tbl_sector sec on sec.id_sector=dir.id_sector
        inner join ventas.tbl_zona z on z.id_zona=sec.id_zona
        inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
        inner join common.tbl_provincia prov on prov.id_provincia=dis.id_provincia
        inner join common.tbl_dpto dpto on dpto.id_dpto=prov.id_dpto
        inner join planillas.tbl_persona delivery on a.id_vendedor = delivery.id_persona
        inner join common.tbl_comprobante c on a.id_comprobante = c.id_comprobante 
        inner join common.tbl_tipoventa d on a.id_tipoventa = d.id_tipoventa 
        inner join common.tbl_estado s on a.id_estado= s.id_estado
        where delivery.id_persona= _delivery_id --and  a.enterprise_id = _enterprise_id
              --and delivery.order_status in(1,2,3)
        order by a.id_cotizapreventa desc;
        --limit 20;
        

END;
$BODY$;
 

CREATE OR REPLACE FUNCTION ventas.fn_order_change_status(
	_enterprise_id character varying,
	_order_id character varying,
	_status_id character varying)
    RETURNS TABLE(statuscode integer, statusmessage text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	new_status_name character varying;
	order_status integer;
	status_name character varying;
	uniqueid bigint;
BEGIN
	--select  *from common.tbl_estado
	select a.id_estado, a.des_estado into order_status, new_status_name
	from common.tbl_estado a
	where a.id_estado = _status_id::integer;
	
	order_status := COALESCE(order_status,0);
	
	if(order_status = 0 ) then
		return query 
			select 0 as statuscode,
					'Estado a cambiar de la orden es inválido' as statusmessage;
					
	else
		select b.des_estado, a.id_cotizapreventa into status_name, uniqueid
		from ventas.tbl_cotizacionpreventa a inner join common.tbl_estado b
		on a.id_estado = b.id_estado
		where a.id_cotizapreventa = _order_id::bigint;-- and a.enterprise_id = _enterprise_id;
	
		if(status_name = 'ACTIVO' and new_status_name='ANULADO')then
			update ventas.tbl_cotizacionpreventa
				set id_estado = order_status
			where id_cotizapreventa = uniqueid::bigint;-- uuid = _order_id and enterprise_id = _enterprise_id;

			return query 
				select 1 as statuscode,
						'Estado de Orden cambiado' as statusmessage;
		else 
            if(status_name <> 'registrado' and new_status_name = '')then
               
                return query 
                    select 0 as statuscode,
                            'Solo se pueden cancelar las ordenes que esten con estado registrado.' as statusmessage;

			else 
                update ventas.tbl_cotizacionpreventa
                    set id_estado = order_status
                where id_cotizapreventa = uniqueid::bigint;-- uuid = _order_id and enterprise_id = _enterprise_id;

				if(new_status_name = 'editar') then
					update ventas.tbl_detpreventacotiza
						set status = false
					where id_cotizapreventa = uniqueid::bigint;
				end if;

                return query 
                    select 1 as statuscode,
                            'Estado de Orden cambiado -' || order_status::TEXT as statusmessage;
		    end if;	
		end if;	
	end if;

END;
$BODY$;

"ANULADO"
 select * from ventas.fn_order_detail('', '3467');
select  *from common.tbl_estado
select id_estado as resourceid, des_estado as status, des_estado as label from common.tbl_estado where est_estado

CREATE OR REPLACE FUNCTION ventas.fn_order_detail(
	_enterprise_id character varying,
	_order_id character varying)
    RETURNS TABLE(
	product_id varchar(20), 
	product_name varchar(200), 
	product_desc varchar(200), 
	quantity numeric(20,4), 
	price numeric(20,4), 
	tax numeric(20,4), 
	discount numeric(20,4), 
	total_amount numeric(20,4)
	) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN

	return query 
		select 
			c.id_producto uuid, 
			c.descripcion_larga  as name, 
			c.descripcion_larga as descripcion, 
			a.cantidad as quantity, 
			a.precio as price, 
			(a.imp_total-a.imp_igv)::numeric(20,4) as tax, 
			a.imp_dscto as discount, 
			a.imp_total as total_amount
		from ventas.tbl_detpreventacotiza a 
		inner join ventas.tbl_cotizacionpreventa b on a.id_cotizapreventa = b.id_cotizapreventa
		inner join almacen.tbl_precio pre on pre.id_producto=a.id_producto and pre.id_unidadventa=a.id_unidadventa 
		inner join almacen.tbl_producto c on pre.id_producto = c.id_producto
		where b.id_estado=1 and b.id_cotizapreventa = _order_id::bigint ;--and c.id_empresa = _enterprise_id::ineteger;
		

END;
$BODY$;

 

CREATE OR REPLACE FUNCTION seguridad.fn_user_get(
	_uuid character varying)
    RETURNS TABLE(
	resourceid char(5), 
	documenttypeid integer, 
	documenttype character varying, 
	document_number character varying, 
	name varchar(50), 
	last_name text, 
	full_name varchar(500), 
	sex integer, 
	bird_date character varying, 
	phone_number text, 
	mobile_number text, 
	email varchar(100), 
	ubigeo varchar(8), 
	des_ubigeo varchar(30), 
	address text, 
	reference text, 
	date_insert character varying, 
	date_update character varying, 
	login_type text
) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	SET TIMEZONE = 'America/Lima';
	
	return query 
		select	a.id_usuario as resourceid, 
			b.id_tipdocidentidad as documenttypeid, 
			b.descripcion_larga as documenttype, 
			p.doc_persona as document_number, 
			p.nombres as name, 
			p.apell_paterno || ' ' || p.apell_materno as last_name, 
			p.nombre_razon as full_name, 
			CASE WHEN p.sexo='M' THEN 1 ELSE 2 END as sex, 
			cast(case when p.fecha_nac is null then '' else to_char(p.fecha_nac,'dd/MM/yyyy') end as character varying) as bird_date, 
			'' as phone_number, 
			'' as mobile_number, 
			p.email, 
			dis.id_distrito as ubigeo, 
			dis.distrito as des_ubigeo, 
			dir.direccion as  address, 
			dir.referencia as reference, 
			cast(to_char(p.fecha_reg,'dd/MM/yyyy hh:mm:ss') as character varying) as date_insert, 
			cast(case when now() is null then '' else to_char(now(),'dd/MM/yyyy hh:mm:ss') end as character varying) as date_update, 
			'Login' as login_type
			FROM seguridad.tbl_usuario a
			inner join Planillas.tbl_persona p on p.id_persona=a.id_persona
			inner join ventas.tbl_direccion dir on dir.id_persona=p.id_persona
			inner join ventas.tbl_sector s on s.id_sector=dir.id_sector
			inner join ventas.tbl_zona z on z.id_zona=s.id_zona
			inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
			inner join planillas.tbl_tipdocidentidad b on p.id_tipdocidentidad = b.id_tipdocidentidad
			where a.id_usuario = _uuid;
	
END;
$BODY$;

select *from planillas.tbl_persona
select *from seguridad.tbl_usuario a
select *from seguridad.fn_login_user('1','admin','admin',1)

CREATE OR REPLACE FUNCTION seguridad.fn_login_user(
	_enterprise_id character varying,
	_login_user character varying,
	_login_pwd character varying,
	_user_type integer)
    RETURNS TABLE(statuscode integer, statusmessage text, resourceid text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
--	_enterprise_uuid character varying;
	_resource_id character varying;
	_enterpriseid integer;
	_user_type_id integer;
BEGIN
--SELECT a.uuid into _enterprise_uuid
--	FROM db_coma.configuration.enterprise a
--	where a.uuid = _enterprise_id;
--select  *from seguridad.tbl_usuario
SELECT a.id_usuario as uuid, a.id_empresa as enterprise_id, 2 as user_type_id into _resource_id, _enterpriseid, _user_type_id
	FROM seguridad.tbl_usuario a
	where a.camp2 = _login_user and a.camp1 = _login_pwd;

	IF(exists(
			SELECT 1
			FROM seguridad.tbl_usuario a 
			where a.camp2 = _login_user
			and a.camp1 = _login_pwd
			and a.id_empresa::text = _enterprise_id
		)
	  )
	  then
		if(_enterpriseid::text = _enterprise_id::text and _user_type_id = _user_type)then
			return 
				query 
					select 1 as statuscode,
							'Acceso exitoso.' as statusmessage, cast(_resource_id as text) as resourceid;
			else
			return 
				query 
					select 0 as statuscode,
							'Usuario/Contraseña incorrecto.'  as statusmessage, '' as resourceid;
		end if;
	else
		return 
			query 
				select 0 as StatusCode,
					'Su cuenta no existe.' as StatusMessage, '' as resourceid;
	end if;
END;
$BODY$;


select * from common.fn_enterprise_getbyid('1');

CREATE OR REPLACE FUNCTION common.fn_enterprise_getbyid(
	_resourceid character varying)
    RETURNS TABLE(
	resourceid integer, 
	identification_type_id integer, 
	identification_type text, 
	document_number char(12), 
	district_id character varying, 
	district text, 
	company_name character varying, 
	trade_name text, 
	address character varying, 
	web text, 
	logo text, 
	phone text, 
	email text, 
	date_create character varying, 
	date_update character varying
) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		SELECT 
		a.id_empresa as uuid, 
		1 as identification_type_id, 
		'RUC' AS name, 
		a.ruc as document_number, 
		dis.id_distrito as district_id, 
		trim(dis.distrito) || ' - ' || trim(prov.provincia) || ' - ' || trim(dep.departamento) as district,
		a.nombre as company_name,  
		'' as trade_name, 
		a.direccion as  address, 
		'' as web, 
		encode(null, 'base64') as logo, 
		'' as phone, 
		'' as email,
		cast(to_char(now(),'dd/MM/yyyy hh:mm:ss') as character varying) as date_create, 
		cast(case when a.date_update is null then '' else to_char(now(),'dd/MM/yyyy hh:mm:ss') end as character varying) as date_update
		FROM common.tbl_empresa A 
			inner join ventas.tbl_sector s on s.id_sector=a.id_sector
			inner join ventas.tbl_zona z on z.id_zona=s.id_zona 
			inner join common.tbl_distrito dis on dis.id_distrito = z.id_distrito
			inner join common.tbl_provincia prov on dis.id_provincia= prov.id_provincia 
			inner join common.tbl_dpto dep on prov.id_dpto = dep.id_dpto
		where a.id_empresa = _resourceid::integer;
END;
$BODY$;

select *from common.tbl_provincia
select *from  ventas.tbl_zona
select  *from common.tbl_empresa

select  *from common.fn_autocomplete_district('','');
CREATE OR REPLACE FUNCTION common.fn_autocomplete_district(
	_enterprise_uuid character varying,
	_district character varying)
    RETURNS TABLE(resourceid character varying, district character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		select 	c.id_distrito as resourceid, 
				cast(trim(c.distrito) || ' - ' || trim(b.provincia) || ' - ' || trim(a.departamento) as character varying) as distrito
		from   common.tbl_dpto a 
		inner join common.tbl_provincia b on a.id_dpto = b.id_dpto 
		inner join common.tbl_distrito c on b.id_provincia = c.id_provincia
		where c.distrito ilike'%'|| _district ||'%'
		order by c.distrito
		limit 10;
END;
$BODY$;

CREATE OR REPLACE FUNCTION almacen.fn_get_existencias(
	_id_empresa integer
)
returns table(
	statuscode integer, 
	statusmessage text,
	data text
) as  $$
declare
begin
 return query select 1 as statuscode, 'Productos Recuperados' statusmessage ,row_to_json(t)::text as data
from (
  select  
    (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        
       select *
       from almacen.tbl_existencia dir -- select  *from ventas.v_direccion
       
       --where dir.id_persona=p.id_persona
      
       
      ) d
    ) as exsistencias
   
		 
) t;
end;$$
language 'plpgsql';

select  *from planillas.tbl_coordinatehistory

select id_producto, *from almacen.tbl_existencia

CREATE OR REPLACE FUNCTION planillas.fn_coordinate_history_add(
	_enterprise_id integer,
	_order_id bigint ,
	_user_id bigint,
	_date timestamp without time zone,
	_x numeric,
	_y numeric)
    RETURNS TABLE(statuscode integer, statusmessage text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	uniqueid integer;
	delivery_id integer;
BEGIN
		 
		insert into planillas.tbl_coordinatehistory (user_id, order_id, date_insert, coddia, x, y)
		values(_user_id::text, _order_id, _date, cast( to_char(_date,'yyyymmdd') as int) , _x, _y);
		
		return query 
				select 1 as statuscode,
						'Coordenada Registrada' as statusmessage;
						
END;
$BODY$;

select *from planillas.tbl_coordinatehistory

CREATE OR REPLACE FUNCTION compras.isp_ordencompra(
	op integer,
	_id_cotizaorden bigint,
	_fecha_registro text,
	_fecha_entrega text,
	_serie character,
	_numero character,
	_id_tipoventa integer,
	_id_responsablecompra character varying,
	_id_solicitoordencompra character varying,
	_lugar_entrega text,
	_id_comprobante integer,
	_id_moneda integer,
	_id_tipocambio integer,
	_id_operacion integer,
	_id_dirproveedor bigint,
	_id_proveedor character varying,
	_id_direccionfactura bigint,
	_id_clientefactura character varying,
	_imp_bruto numeric,
	_imp_dscto numeric,
	_valor_venta numeric,
	_imp_persepcion numeric,
	_imp_igv numeric,
	_imp_total numeric,
	_id_igv integer,
	_observaciones text,
	_id_estado integer,
	_id_usuario character,
	_id_sucursal integer,
	_tipo_cambio numeric,
	_total_dolares numeric)
    RETURNS text[]
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
	correl integer;
	res text[];
	
BEGIN
if op=1 then
	if exists(select *from  ventas.tbl_direccion where id_persona=_id_proveedor and id_direccion=_id_dirproveedor)then
		if exists(select *from planillas.tbl_persona where id_persona=_id_responsablecompra)then
			select max(id_cotizaorden) into correl from compras.tbl_ordencotizacompra;
			if correl is null then
				correl:=1;
			else
				correl:=correl+1;
			end if;
			_id_cotizaorden:=correl;
			INSERT INTO compras.tbl_ordencotizacompra(
				id_cotizaorden, 
				fecha_registro, 
				fecha_entrega, 
				serie, 
				numero, 
				id_tipoventa, 
				id_responsablecompra, 
				id_solicitoordencompra, 
				lugar_entrega, 
				id_comprobante, 
				id_moneda, 
				id_tipocambio, 
				id_operacion, 
				id_dirproveedor, 
				id_proveedor, 
				id_direccionfactura, 
				id_clientefactura, 
				imp_bruto, 
				imp_dscto, 
				valor_venta, 
				imp_persepcion, 
				imp_igv, 
				imp_total, 
				id_igv, 
				observaciones, 
				id_estado, 
				id_usuario, 
				fec_actualiza, 
				id_usuarioactualiza, 
				id_sucursal,
				tipo_cambio,
				total_dolares
			)
			VALUES (
				_id_cotizaorden, 
				to_timestamp(_fecha_registro,'YYYY-MM-DD HH24:MI:SS.MS'), 
				to_timestamp(_fecha_entrega,'YYYY-MM-DD HH24:MI:SS.MS'), 
				_serie, 
				_numero, 
				_id_tipoventa, 
				_id_responsablecompra, 
				_id_solicitoordencompra, 
				_lugar_entrega, 
				_id_comprobante, 
				_id_moneda, 
				_id_tipocambio, 
				_id_operacion, 
				_id_dirproveedor, 
				_id_proveedor, 
				_id_direccionfactura, 
				_id_clientefactura, 
				_imp_bruto, 
				_imp_dscto, 
				_valor_venta, 
				_imp_persepcion, 
				_imp_igv, 
				_imp_total, 
				_id_igv, 
				_observaciones, 
				_id_estado, 
				_id_usuario, 
				now(), 
				_id_usuario, 
				_id_sucursal,
				_tipo_cambio,
				_total_dolares
			)returning array['0',id_cotizaorden::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar al cabecera de la orden de compra '];
			end if;
		else
			res:=array['503','Seleccione el responsable para realizar esta operación'];
		end if;
	else
		res:=array['503','Seleccione el proveedor que sera dirigida la orden de compra'];
	end if;
end if;
if op=2 then
	if exists(select *from compras.tbl_ordencotizacompra where id_cotizaorden=_id_cotizaorden)then
		if exists(select *from  ventas.tbl_direccion where id_persona=_id_proveedor and id_direccion=_id_dirproveedor)then
			if exists(select *from planillas.tbl_persona where id_persona=_id_responsablecompra)then
				UPDATE compras.tbl_ordencotizacompra
				   SET 					
					fecha_entrega=to_timestamp(_fecha_entrega,'YYYY-MM-DD HH24:MI:SS.MS'), 
					serie=_serie, 
					numero=_numero, 
					id_tipoventa=_id_tipoventa, 
					id_responsablecompra=_id_responsablecompra, 
					id_solicitoordencompra=_id_solicitoordencompra, 
					lugar_entrega=_lugar_entrega, 
					id_comprobante=_id_comprobante, 
					id_moneda=_id_moneda, 
					id_tipocambio=_id_tipocambio, 
					id_operacion=_id_operacion, 
					id_dirproveedor=_id_dirproveedor, 
					id_proveedor=_id_proveedor, 
					id_direccionfactura=_id_direccionfactura, 
					id_clientefactura=_id_clientefactura, 
					imp_bruto=_imp_bruto, 
					imp_dscto=_imp_dscto, 
					valor_venta=_valor_venta, 
					imp_persepcion=_imp_persepcion, 
					imp_igv=_imp_igv, 
					imp_total=_imp_total, 
					id_igv=_id_igv, 
					observaciones=_observaciones, 
					id_estado=_id_estado, 
					fec_actualiza=now(), 
					id_usuarioactualiza=_id_usuario, 
					id_sucursal=_id_sucursal,
					tipo_cambio=_tipo_cambio,
					total_dolares=_total_dolares
				 WHERE id_cotizaorden=_id_cotizaorden returning array['0',id_cotizaorden::text] into res;
				 
			else
				res:=array['503','Seleccione el responsable para realizar esta operación'];
			end if;
		else
			res:=array['503','Seleccione el proveedor que sera dirigida la orden de compra'];
		end if;
	else
		res:=array['503','Seleccione correctamente al momento de editar la orden de compra'];
	end if;
end if;
return res;
END;
$BODY$;



create or replace function planillas.fn_asistencia(f1 text,f2 text)
returns table(
	codigo text, 
	documento text,
	colaborador text,
	cantidad integer,
	precio numeric(20,2),
	imp_total numeric(20,2)
) as $$
begin
 return query SELECT 
    p.cod_barras::text as codigo,
    p.doc_persona::text doc_persona,
    p.nombre_razon::text AS colaborador,
    count(1)::integer as cantidad,
    (2.66)::numeric(20,2)  as precio,
    (2.66*count(1))::numeric(20,2) as Importe 
   FROM (planillas.tbl_asistencia d
     JOIN planillas.tbl_persona p ON (((p.id_persona)::text = (d.id_persona)::text)))
     where d.fecha::date>=f1::date and d.fecha::Date<=f2::date
group by p.doc_persona,p.cod_barras,
    p.nombre_razon;

 end;$$
 language 'plpgsql';

select *from  planillas.tbl_persona where doc_persona='42607389'

CREATE OR REPLACE FUNCTION common.fn_autocomplete_district(
	_district character varying)
    RETURNS TABLE(resourceid varchar(8), district character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		select 	v.id_ubigeo as resourceid, cast( trim(v.distrito) || '-' || trim(provincia) || '-' || trim(departamento) as character varying) as distrito
		from common.v_ubigeo v
		where   v.distrito ilike'%'|| _district ||'%'
		order by v.distrito
		limit 10;
END;
$BODY$;


select *from common.v_ubigeo 
select *from common.v_ubigeo
select  *from almacen.tbl_producto

select *from almacen.fn_list_products(1,'34')

CREATE OR REPLACE FUNCTION almacen.fn_list_products(
	op integer,
	_id_producto varchar(30)
)
returns table(data json)
as $$
declare
begin
return query select row_to_json(t) as data
from (
  select  p.*,		             
	(
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        
       select 
		  	fm.* 
		 from almacen.tbl_familiamarca fm        
       where fm.id_familia=p.id_familia and  fm.id_marca=p.id_marca        
      ) d
    ) as familia_marca,    
	(
	 select array_to_json(array_agg(row_to_json(d)))
	  from (
	   select 
			f.* 
		 from almacen.tbl_familia f        
	   where f.id_familia=p.id_familia             
	  ) d
	) as familia,
	(
	 select array_to_json(array_agg(row_to_json(d)))
	  from (

	   select 
			m.* 
		 from almacen.tbl_marca m        
	   where p.id_marca=m.id_marca      
	  ) d
	) as marca,
	(
	select array_to_json(array_agg(row_to_json(d)))
	  from (
	   select 
			dp.* 
		 from almacen.tbl_detproducto dp        
	   where dp.id_producto=p.id_producto      
	  ) d
	) as detproducto,
	(
	 select array_to_json(array_agg(row_to_json(d)))
	  from (

	   select 
			pre.* 
		 from almacen.tbl_precio pre        
	   where pre.id_producto=p.id_producto  
	  ) d
	) as precios,
	(
	 select array_to_json(array_agg(row_to_json(d)))
	  from (

	   select 
			ex.* 
		 from almacen.tbl_existencia ex        
	   where ex.id_producto=p.id_producto  
	  ) d
	) as existencias
  from almacen.tbl_producto p 
	where  p.id_producto=_id_producto
		 
) t;
end;$$
language 'plpgsql';

select  *from almacen.tbl_producto

CREATE OR REPLACE FUNCTION planillas.fn_list_customers(
	_filtro text)
    RETURNS TABLE(dat text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
declare
	cad text;
begin
	return query select row_to_json(t)::text as data
from (
  select  --select *from planillas.tbl_persona
	p.id_persona as customer_id,
	p.id_tipdocidentidad as identification_type_id,
        p.doc_persona as Document,
        
        COALESCE(p.dni,'') as dni,
        p.nombre_razon as customer_name,
        p.razon_comercial as short_name,
        p.id_estadocivil as civil_status_id,
        p.sexo as sex,
        p.email as Mail,
        p.paginaweb as page,
        '' as phone,
        p.observaciones as Observation,
        false as Employee,
        p.tipo_persona as person_type,
        p.cliente_proveedor as Customer,
        p.deuda_confidencial as confidential_debt,
        p.no_apto_credito as no_credit,
        p.id_vendtitular as owner_seller_id,
        p.id_vendsuplente as substitute_seller_id,
        p.id_cobrador as debt_collector_Id,
        
         (
	select to_json(t) from (select  '01' as codcat, 'Cliente tienda' as nomcat) t
    ) as categoria,
    (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        
       select dir.id_direccion Id ,
       dir.direccion as Address,
       dir.referencia as Reference,
       dir.sector,
       dir.departamento as Department,
       dir.provincia as Province,
       dir.distrito as District,
       dir.id_sector as sector_id,
       dir.id_distrito as district_id,
       dir.id_provincia as province_id,
       dir.id_departamento as department_id,
       1 as status_id,
       trim(COALESCE(dir.direccion,'')) || ' - ' || COALESCE(trim(dir.distrito),'') || ' - ' || COALESCE(trim(dir.provincia),'') || ' - ' || COALESCE(trim(dir.departamento),'')as direccion 
       from ventas.v_direccion dir -- select  *from ventas.v_direccion
       
       where dir.id_persona=p.id_persona
      
       
      ) d
    ) as Address
  from planillas.v_persona p 
	where  trim(p.doc_persona)||trim(p.nombre_razon)  ilike '%'|| _filtro ||'%'
		 
) t;
end;
$BODY$;

select *from planillas.v_persona

select  *from ventas.add_address(1, 'JR. LIBERTAD S/N - ZARAGOZA', 1829, '83', '', 1, 255, 1) 

CREATE OR REPLACE FUNCTION ventas.add_address(
    op integer,
    _direccion text,
    _id_sector integer,
    _id_persona text,
    _referencia text,
    _id_estado integer,
    _id_direccion bigint,
    _id_tipvivienda INTEGER
    )
  RETURNS TABLE(statuscode integer, statusmessage text) AS
$BODY$
DECLARE
	res text[];
	correl bigint;
BEGIN
if not exists(select * from ventas.tbl_direccion where id_persona = _id_persona and id_direccion = _id_direccion) then		 
		insert into ventas.tbl_direccion(
			  id_direccion,
			  direccion,
			  id_sector,
			  id_persona,
			  referencia,
			  id_estado,
			  id_tipvivienda
		)values(
			  _id_direccion,
			  _direccion,
			  _id_sector,
			  _id_persona,
			  _referencia,
			  _id_estado,
			  _id_tipvivienda
		)returning array['0',tbl_direccion.id_direccion::text] into res;
		
		if not found then
			return query  select  0 as statuscode, 'Inconsistencia inespera al momento de registar la dirección del cliente' as statusmessage;
		end if;
		 return query  select  1 as statuscode, 'Dirección registrada' as statusmessage;
 else
	 	update ventas.tbl_direccion set 
			  direccion = _direccion,
			  id_sector = _id_sector,
			  referencia = _referencia,
			  id_estado = _id_estado,
			  id_tipvivienda=_id_tipvivienda
		  where id_persona = _id_persona and id_direccion = _id_direccion;
		--  res:=array['0',_id_direccion::text, _id_persona];
		  return query  select  1 as statuscode, 'Dirección actualizado' as statusmessage;	 
end if;
	
END;$BODY$
  LANGUAGE plpgsql ;
 


CREATE OR REPLACE FUNCTION planillas.add_customer(
	op integer,
	_id_persona character varying,
	_id_estadocivil integer,
	_doc_persona character varying,
	_nombre_razon character varying,
	_razon_comercial character varying,
	_sexo character,
	_email character varying,
	_paginaweb text,
	_fecha_nac text,
	_tipo_persona boolean,
	_cliente_proveedor boolean,
	_deuda_confidencial boolean,
	_no_apto_credito boolean,
	_concientizado boolean,
	_copropietario boolean,
	_observaciones text,
	_id_estado integer,
	_id_vendtitular character,
	_id_vendsuplente character,
	_id_cobrador character,
	_imp_minimoventa numeric,
	_percep_cliente boolean,
	_agente_perceptor boolean,
	_id_coopropietario character varying,
	_id_tipdocidentidad integer,
	_porcent_percepcion numeric,
	_id_persona_ref varchar(15),
	_id_direccion_ref bigint,
	_facturar_a_clienteref boolean ,
	_gestiona_lineacredito boolean
)
    RETURNS TABLE(statuscode integer, statusmessage text,customerId text) 
AS $$

DECLARE 
	RES TEXT[];
	correl integer;
	customerId text;
BEGIN
	IF OP=1 THEN
		if not exists(select * from PLANILLAS.TBL_PERSONA where trim(doc_persona) = trim(_doc_persona)) then			 		 				 
				if ((_id_tipdocidentidad NOT IN(2,7) )and (length(_doc_persona)=8 ) ) then					 
					return query 
						select  0 as statuscode, 
						'Verifique la identificacion del cliente para el tipo DNI' as statusmessage, 
						'0' as custumer_id;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					return query 
						select  0 as statuscode, 
						'Verifique la identificacion del cliente para el tipo RUC' as statusmessage, 
						'0' as custumer_id;					
				end if;
				--select  *from planillas.tbl_tipdocidentidad
				insert into PLANILLAS.TBL_PERSONA(
				  id_persona ,
				  id_estadocivil ,
				  doc_persona ,
				  nombre_razon,
				  razon_comercial ,
				  sexo ,
				  email,
				  paginaweb ,
				  fecha_nac ,
				  tipo_persona ,
				  cliente_proveedor ,
				  deuda_confidencial,
				  no_apto_credito ,
				  concientizado ,
				  copropietario ,
				  observaciones ,
				  id_estado,
				  ID_VENDTITULAR,
				  ID_VENDSUPLENTE,
				  ID_COBRADOR,
				  IMP_MINIMOVENTA,
				  PERCEP_CLIENTE,
				  AGENTE_PERCEPTOR ,
				  id_tipdocidentidad,
				  PORCENT_PERCEPCION,
				  id_persona_ref,
				  id_direccion_ref ,
				  facturar_a_clienteref,				 
				  gestiona_lineacredito
				)
				values(
				  _id_persona ,
				  _id_estadocivil ,
				  _doc_persona ,
				  _nombre_razon,
				  _razon_comercial ,
				  _sexo ,
				  _email,
				  _paginaweb ,
				  _fecha_nac::date ,
				  _tipo_persona ,
				  _cliente_proveedor ,
				  _deuda_confidencial,
				  _no_apto_credito ,
				  _concientizado ,
				  _copropietario ,
				  _observaciones ,
				  _id_estado,
				  _ID_VENDTITULAR,
				  _ID_VENDSUPLENTE,
				  _ID_COBRADOR,
				  _IMP_MINIMOVENTA,
				  _PERCEP_CLIENTE,
				  _AGENTE_PERCEPTOR,
				  _id_tipdocidentidad,
				  _porcent_percepcion,
				  _id_persona_ref,
				  _id_direccion_ref ,
				  _facturar_a_clienteref,				 
				  _gestiona_lineacredito
				)returning TBL_PERSONA.id_persona into customerId;
				 
				--res:=array['504','Inconsistencia inesperada al registrar el detalle de la cotizacion'];
				return query 
				    select  1 as statuscode, 
					    'Cliente registrado' as statusmessage, 
					    cast(customerId as text) as resourceid;
				IF NOT FOUND THEN
					return query 
						select  0 as statuscode, 
						'Los datos enviados son inválidos' as statusmessage, 
						'0' as custumer_id;
				end if;
		else
			if _cliente_proveedor=true then
				return query 
						select  0 as statuscode, 
						'El Cliente con Documento de Identidad <<*** ' || _doc_persona || ' >> ya esta registrado ..!! ' as statusmessage, 
						'0' as custumer_id;
				 
			else
				return query 
						select  0 as statuscode, 
						'El Proveedor con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! ' as statusmessage, 
						'0' as custumer_id;				 
			end if;
			
		end if;
		
	END IF;
	IF OP=2 THEN
		if exists(select * from PLANILLAS.TBL_PERSONA where id_persona=_id_persona) then
				if ((_id_tipdocidentidad NOT IN(2,7) )and (length(_doc_persona)=8 ) ) then					 
					return query 
						select  0 as statuscode, 
						'Verifique la identificacion del cliente para el tipo DNI' as statusmessage, 
						'0' as custumer_id;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					return query 
						select  0 as statuscode, 
						'Verifique la identificacion del cliente para el tipo RUC' as statusmessage, 
						'0' as custumer_id;					
				end if;
					update PLANILLAS.TBL_PERSONA set 
						  id_estadocivil =_id_estadocivil ,
						  doc_persona = _doc_persona ,
						  nombre_razon= _nombre_razon,
						  razon_comercial = _razon_comercial,
						  sexo = _sexo,
						  email = _email,
						  paginaweb = _paginaweb,
						  fecha_nac = _fecha_nac::Date,
						  tipo_persona = _tipo_persona,
						  deuda_confidencial = _deuda_confidencial,
						  no_apto_credito = _no_apto_credito,
						  concientizado = _concientizado,
						  copropietario = _copropietario,
						  observaciones = _observaciones,
						  id_estado = _id_estado,
						  ID_VENDTITULAR=_ID_VENDTITULAR,
						  ID_VENDSUPLENTE=_ID_VENDSUPLENTE,
						  ID_COBRADOR=_ID_COBRADOR,
						  IMP_MINIMOVENTA=_IMP_MINIMOVENTA,
						  PERCEP_CLIENTE=_PERCEP_CLIENTE,
						  AGENTE_PERCEPTOR=_AGENTE_PERCEPTOR,
						  id_tipdocidentidad=_id_tipdocidentidad,
						  PORCENT_PERCEPCION=_PORCENT_PERCEPCION,
						  id_persona_ref=_id_persona_ref,
						  id_direccion_ref=_id_direccion_ref ,
						  facturar_a_clienteref =_facturar_a_clienteref ,
						  cliente_proveedor=true,
						  gestiona_lineacredito=_gestiona_lineacredito
					where id_persona=_id_persona;
			return query 
				    select  1 as statuscode, 
					    'Cliente registrado' as statusmessage, 
					    cast(_id_persona as text) as resourceid;
		else
			return query 
				    select  0 as statuscode, 
					    'Seleccione correctamente el cliente' as statusmessage, 
					    cast(_id_persona as text) as resourceid;
		end if;
	end if;
END;$$
language 'plpgsql';




CREATE OR REPLACE FUNCTION ventas.fn_order_delete(
	_sucursal_id integer,
	_enterprise_id character varying,
	_order_id bigint)
    RETURNS TABLE(statuscode integer, statusmessage text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	id_subsidiary INTEGER;
	id_order INTEGER;
BEGIN
	
	SELECT a.id into id_subsidiary
	FROM delivery.subsidiary a
	WHERE uuid = _subsidiary_id and enterprise_id = _enterprise_id and status;
	
	id_subsidiary := COALESCE(id_subsidiary,0);
	
	select a.id into id_order
	from delivery.order a
	where enterprise_id = _enterprise_id and status and subsidiary_id=id_subsidiary and uuid = _order_id;
	
	id_order := COALESCE(id_order,0);
		
	if(id_subsidiary = 0 or id_order = 0) then 
		return query 
				select 	0 as statuscode, 
						'Los datos enviados son inválidos' as statusmessage;
	else
		delete from delivery.order_detail_component a 
			using delivery.order_detail b
		where a.order_detail_id = b.id 
			and b.order_id = id_order;

		delete from delivery.order_detail a 
			using delivery.order b
		where a.order_id = b.id 
			and b.id = id_order;

		delete from delivery.order
		where id = id_order;

		return query 
					select 	1 as statuscode, 
							'Orden Registrada' as statusmessage;
	end if;
	
END;
$BODY$;


CREATE OR REPLACE FUNCTION ventas.fn_order_detail_add(
	op integer,
	_id_cotizapreventa bigint,
	_id_sucursal integer,
	_cantidad numeric,
	_precio numeric,
	_imp_dscto numeric,
	_imp_igv numeric,
	_imp_total numeric,
	_descripcion_linea text,
	_id_estado integer,
	_id_producto character varying,
	_id_unidadventa integer,
	_id_listaprecio integer,
	_lp integer,
	_item integer,
	_tipo character,
	_modotexto boolean,
	_observaciones text,
	_id_almacen integer,
	_id_unimedventa integer,
	_imp_percepcion numeric,
	_porcent_percepcion numeric,
	_precio_sinpercepcion numeric)
    RETURNS TABLE(statuscode integer, statusmessage text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
	res text[];
	_correl_item integer;
	_cantidad_old numeric(20,4);
BEGIN
if op=1 then
	if exists(select *from  ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
		if exists(select *from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			select max(item) into _correl_item from ventas.tbl_detpreventacotiza where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal;
			if _correl_item is null then
				_correl_item=1;
			else
				_correl_item:=_correl_item+1;
			end if;
			INSERT INTO ventas.tbl_detpreventacotiza(
				id_cotizapreventa, 
				id_sucursal, 
				cantidad, 
				precio, 
				imp_dscto, 
				imp_igv, 
				imp_total, 
				descripcion_linea, 
				id_estado, 
				id_producto, 
				id_unidadventa, 
				id_listaprecio, 
				lp, 
				item, 
				tipo, 
				modotexto, 
				observaciones,
				id_almacen,
				id_unimedventa,
				imp_percepcion,
				porcent_percepcion,
				precio_sinpercepcion
			)
			VALUES (
				_id_cotizapreventa, 
				_id_sucursal, 
				_cantidad, 
				_precio, 
				_imp_dscto, 
				_imp_igv, 
				_imp_total, 
				_descripcion_linea, 
				_id_estado, 
				_id_producto, 
				_id_unidadventa, 
				_id_listaprecio, 
				_lp, 
				_correl_item, 
				_tipo, 
				_modotexto, 
				_observaciones,
				case when _id_almacen=0 then 1 else _id_almacen end,
				_id_unimedventa,
				_imp_percepcion,
				_porcent_percepcion,
				_precio_sinpercepcion
			) returning array['0',id_cotizapreventa::text, id_sucursal::text] into res;
			
			if not found then
				--res:=array['504','Inconsistencia inesperada al registrar el detalle de la cotizacion'];
				return query 
				select 	0 as statuscode, 
						'Inconsistencia inesperada al registrar el detalle de la orden' as statusmessage;
			end if;
			return query 
					select 	1 as statuscode, 
							'Detalle de Orden Registrada' as statusmessage;
		else
			--res:=array['503','Verefique que este seleccionado correctamente el producto : idprdod'|| _id_producto || '  _id_unidadventa :' || _id_unidadventa ];
			return query 
				select 	0 as statuscode, 
						'Verefique que este seleccionado correctamente el producto : '|| _id_producto as statusmessage;
		end if;
	else
		--res:=array['504','Ingrese correctamente los datos de la cabecera de la cotizacion'];
		return query 
				select 	0 as statuscode, 
						'Ingrese correctamente los datos de la cabecera de la cotizacion' as statusmessage;
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_detpreventacotiza 
		where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio and item=_item) then
			select  cantidad into _cantidad_old from ventas.tbl_detpreventacotiza  where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		UPDATE ventas.tbl_detpreventacotiza
		   SET  cantidad=_cantidad, 
			precio=_precio, 
			imp_dscto=_imp_dscto, 
		        imp_igv=_imp_igv, 
		        imp_total=_imp_total, 
		        descripcion_linea=_descripcion_linea, 
		        id_estado=_id_estado, 
		        lp=_lp,
		        tipo=_tipo, 
		        modotexto=_modotexto, 
		        observaciones=_observaciones,
		        id_almacen=_id_almacen,
		        id_unimedventa=_id_unimedventa,
		        imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			precio_sinpercepcion=_precio_sinpercepcion,
			cantidad_old=_cantidad_old,
			printed=case when _cantidad-COALESCE(_cantidad_old,0)=0 then true else false end
		 WHERE id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		--res:=array['0','Proceso efectuado con exito'];
		return query 
					select 	1 as statuscode, 
							'Detalle de Orden Registrada' as statusmessage;
		
	else
		--res:=array['504','Verefique que exista el producto :' || _descripcion_linea::text];
		return query 
				select 	0 as statuscode, 
						'Verefique que exista el producto :' || _descripcion_linea::text as statusmessage;
	end if;
end if;
--return res;
END;
$BODY$;


CREATE OR REPLACE FUNCTION ventas.fn_order_add(
	op integer,
	_id_sucursal integer,
	_id_cotizapreventa bigint,
	_id_cotizacion bigint,
	_id_sucursalcotizacion integer,
	_serie character,
	_numero character,
	_id_comprobante integer,
	_fecha text,
	_valido_hasta text,
	_imp_bruto numeric,
	_imp_dscto numeric,
	_valor_venta numeric,
	_imp_igv numeric,
	_imp_total numeric,
	_cotizacion boolean,
	_preventa boolean,
	_id_estado integer,
	_id_direccion bigint,
	_id_cliente character varying,
	_id_usuario character,
	_id_tipoventa integer,
	_glosa text,
	_id_igv integer,
	_id_tipocambio integer,
	_id_moneda integer,
	_redondeo numeric,
	_id_tranzaccion character,
	_id_operacion integer,
	_id_vendedor character varying,
	_observaciones text,
	_dni_cliente character,
	_nomape_cliente text,
	_direccion_cliente text,
	_tipdocumento text,
	_bloquear_encaja boolean,
	_imp_percepcion numeric,
	_imp_neto numeric,
	_telefono character varying,
	_id_mesa integer)
    RETURNS TABLE(statuscode integer, statusmessage text, orderid text,sucursalid text, order_number text,amount numeric(20,2)) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
	res text;
	correl integer;
	--serie char(4);
	--_numero varchar(7);
	correlativo integer;
	cad text[];
	__ID BIGINT;
	_User_id varchar(5);
	orderId bigint;
	sucursalid integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		--select *from common.v_configseries
		--select *from seguridad.tbl_usuariodocumento
		select ud.serie into _serie from seguridad.tbl_usuario us
		inner join seguridad.tbl_usuariodocumento ud on us.id_usuario=ud.id_usuario
		where ud.id_sucursal=_id_sucursal and us.id_persona=_ID_VENDEDOR and ud.id_comprobante=_id_comprobante and ud.predeterminado=true and ud.id_estado=1;

		--select us.id_usuario into _User_id from seguridad.tbl_usuario us where  us.id_persona=_ID_VENDEDOR ;

		select numero into correlativo from common.V_CONFIGSERIES  where id_tranzaccion='20' and id_comprobante ='16' and serie=_serie and id_estado =1 and id_empresa=1  and id_sucursal=1;
		if correlativo is null then
			correlativo:=1;
		else
			correlativo=correlativo+1;
		end if;
		
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    lpad(correlativo::text,7,'0'), 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono
			    			    
		) RETURNING id_cotizapreventa,id_sucursal INTO orderId,sucursalid;

		cad:=(select * from restaurant.usp_comandamesa(
		    op ,
		    0,
		    orderId ,
		    _id_mesa ,
		    now()::text,
		    true,
		    1,
		    _ID_VENDEDOR
		 ));

		--res:=to_json(message('success','Commanda registrado->' || _ID_VENDEDOR,__ID::TEXT,''))::text;  
		--res:=(select to_json(t) from(select 'success' as status,'Pedido generado' as message,_serie || '-' || lpad(correlativo::text,7,'0') as number,__ID::text as code,'' as sql,_imp_total::text as amount ) t);
		 return query 
                    select  1 as statuscode, 
                            'Orden Registrada' as statusmessage, 
                            cast(orderId as text) as resourceid, 
			    cast(sucursalid as text) as sucursalid,
                            cast((_serie || '-' || lpad(correlativo::text,7,'0')) as text) as order_number,
			    _IMP_NETO::numeric(20,2) as amount;
		IF NOT FOUND THEN
			return query 
				select  0 as statuscode, 
				'Los datos enviados son inválidos' as statusmessage, 
				'' as resourceid,'' sucursalid, 
				'' as order_number,
				'0.00'::numeric(20,2) as amount;
			--RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		--RES:=to_json(message('error','Seleccione un cliente para realizar este proceso','503',''))::text;  
		--RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
		return query 
				select  0 as statuscode, 
				'Seleccione el cliente correctamente' as statusmessage, 
				'' as resourceid,'' sucursalid, 
				'' as order_number,
				'0.00'::numeric(20,2) as amount;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    --serie=_serie, 
				    --numero=_numero, 
				   -- id_comprobante=_id_comprobante, 				     
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    --valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				--RES:=to_json(message('success','Registro actualizado',_id_cotizapreventa::text,''))::text;  
				--res:=(select to_json(t) from(select 'success' as status,'Pedido generado' as message,_serie || '-' || lpad(_numero::text,7,'0') as number,_id_cotizapreventa::text as code,'' as sql,_imp_total::text as amount ) t);
				--res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
				return query 
				    select  1 as statuscode, 
					    'Orden Registrada' as statusmessage, 
					    cast(_id_cotizapreventa as text) as resourceid, 
					    cast(_id_sucursal as text) as sucursalid,
					    cast((_serie || '-' || lpad(_numero::text,7,'0')) as text) as order_number,
					    _IMP_NETO::numeric(20,2) as amount;
	ELSE
		--RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
		--RES:=to_json(message('error','Verifique que el registro este seleccionado correctamente el registro ','504',''))::text;  
		return query 
				select  0 as statuscode, 
				'Verifique que el registro este seleccionado correctamente el registro' as statusmessage, 
				'' as resourceid,
				'' sucursalid, 
				'' as order_number,
				'0.00'::numeric(20,2) as amount;
	END IF;
END IF;
END;
$BODY$;




CREATE OR REPLACE FUNCTION compras.rpt_comprasporproveedor(
    refcursor,
    fec_desde text,
    fec_hasta text,
    _id_cliente text,
    op integer,
    text)
  RETURNS refcursor AS
$BODY$
declare
	cad text;
begin
if op=1 then -- todas las ventas todos los clientes
	cad:='select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,''"'','''')) as proveedor, 
	    sum(tbl_compra.imp_venta) as valor_venta,
	    sum(tbl_compra.imp_igv) as imp_igv,
	    sum(tbl_compra.imp_total) as imp_total
	   from  compras.tbl_compra
	   JOIN common.tbl_comprobante ON tbl_compra.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_compra.id_dirproveedor= tbl_direccion.id_direccion  AND tbl_compra.id_proveedor= tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_compra.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_compra.id_sucursalcompra) where tbl_compra.id_estado=1
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon 
	  ORDER BY trim(REPLACE(tbl_persona.nombre_razon,''"'','''')) asc';
	
	 open $1 for execute cad;
end if;
if op=2 then -- todas las ventas por cliente
	 open $1 for select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	    sum(tbl_compra.imp_venta) as valor_venta,
	    sum(tbl_compra.imp_igv) as imp_igv,
	    sum(tbl_compra.imp_total) as imp_total
	   from  compras.tbl_compra
	   JOIN common.tbl_comprobante ON tbl_compra.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_compra.id_dirproveedor= tbl_direccion.id_direccion  AND tbl_compra.id_proveedor= tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_compra.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_compra.id_sucursalcompra)
	   where tbl_compra.id_proveedor=_id_cliente and   tbl_compra.id_estado=1
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	  ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;

if op=3 then -- todos los clientes y las ventas entre vechas
	 open $1 for select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	    sum(tbl_compra.imp_venta) as valor_venta,
	    sum(tbl_compra.imp_igv) as imp_igv,
	    sum(tbl_compra.imp_total) as imp_total
	   from  compras.tbl_compra
	   JOIN common.tbl_comprobante ON tbl_compra.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_compra.id_dirproveedor= tbl_direccion.id_direccion  AND tbl_compra.id_proveedor= tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_compra.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_compra.id_sucursalcompra)
	  where tbl_compra.fec_documento>=cast(fec_desde as date) and tbl_compra.fec_documento<=cast(fec_hasta as date) and   tbl_compra.id_estado=1
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	  ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;

if op=4 then -- ventas entre fechas y por cliente
	 open $1 for select 
	    tbl_persona.doc_persona,
	   trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,    
	    sum(tbl_compra.imp_venta) as valor_venta,
	    sum(tbl_compra.imp_igv) as imp_igv,
	    sum(tbl_compra.imp_total) as imp_total
	   from  compras.tbl_compra
	   JOIN common.tbl_comprobante ON tbl_compra.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_compra.id_dirproveedor = tbl_direccion.id_direccion  AND tbl_compra.id_proveedor= tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_compra.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_compra.id_sucursalcompra)
	   where tbl_compra.id_proveedor=_id_cliente and  
	   tbl_compra.fec_documento>=cast(fec_desde as date) and tbl_compra.fec_documento<=cast(fec_hasta as date) and   tbl_compra.id_estado=1
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	  ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;
--
if op=5 then -- todo los clienes de forma detallada que no incluyenn los productos
	open $1 for select *from compras.v_listar_cabecera_compras order by proveedor;
end if;

if op=6 then -- por  cliene de forma detallada que no incluyenn los productos
	open $1 for select *from compras.v_listar_cabecera_compras 
	where  id_proveedor=_id_cliente order by proveedor;
end if;


if op=7 then -- todos los clientes entre fechas 
	open $1 for select *from compras.v_listar_cabecera_compras 
	where  fec_documento>=cast(fec_desde as date) and fec_documento<=cast(fec_hasta as date)
	order by proveedor;
end if;

if op=8 then -- por cliente clientes entre fechas 
	open $1 for select *from compras.v_listar_cabecera_compras 
	where  id_proveedor=_id_cliente and fec_documento>=cast(fec_desde as date) and fec_documento<=cast(fec_hasta as date)
	order by proveedor;
end if;
--

if op=9 then --todas las  ventas, todas los clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie || '-'||f.nro_doc_compra) as documento,
	f.fec_documento,	
	f.id_proveedor,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	f.imp_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.imp_total as total_det,
	UND.DESC_CORTA AS unidad
	from  compras.tbl_compra f
	INNER JOIN compras.tbl_detcompra DF ON (f.id_compra=df.id_compra and f.id_sucursalcompra=df.id_sucursalcompra and f.id_mes=df.id_mes and f.anio=df.anio)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DP.ID_UNIDADVENTA --SELECT  *FROM ALMACEN.TBL_UNIDAD
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_dirproveedor = tbl_direccion.id_direccion  AND f.id_proveedor = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona 
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursalcompra) where  f.id_estado=1
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;

end if;

if op=10 then --todas las  ventas, por  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie || '-'||f.nro_doc_compra) as documento,
	f.fec_documento,	
	f.id_proveedor,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	f.imp_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.imp_total as total_det
	from  compras.tbl_compra f
	INNER JOIN compras.tbl_detcompra DF ON (f.id_compra=df.id_compra and f.id_sucursalcompra=df.id_sucursalcompra and f.id_mes=df.id_mes and f.anio=df.anio)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_dirproveedor = tbl_direccion.id_direccion  AND f.id_proveedor = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona 
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursalcompra) 
	where f.id_proveedor=_id_cliente and f.id_estado=1
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;

end if;


if op=11 then --ventas por fecha , todos  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie || '-'||f.nro_doc_compra) as documento,
	f.fec_documento,	
	f.id_proveedor,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	f.imp_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.imp_total as total_det,
	UND.DESC_CORTA AS unidad
	from  compras.tbl_compra f
	INNER JOIN compras.tbl_detcompra DF ON (f.id_compra=df.id_compra and f.id_sucursalcompra=df.id_sucursalcompra and f.id_mes=df.id_mes and f.anio=df.anio)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DP.ID_UNIDADVENTA --SELECT  *FROM ALMACEN.TBL_UNIDAD
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_dirproveedor = tbl_direccion.id_direccion  AND f.id_proveedor = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona 
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursalcompra)  

	where  f.fec_documento>=cast(fec_desde as date) and f.fec_documento<=cast(fec_hasta as date) and f.id_estado=1 and df.id_estado=1
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;


if op=12 then --ventas por fecha , por  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie || '-'||f.nro_doc_compra) as documento,
	f.fec_documento,	
	f.id_proveedor,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as proveedor,  
	f.imp_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.imp_total as total_det
	from  compras.tbl_compra f
	INNER JOIN compras.tbl_detcompra DF ON (f.id_compra=df.id_compra and f.id_sucursalcompra=df.id_sucursalcompra and f.id_mes=df.id_mes and f.anio=df.anio)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_dirproveedor = tbl_direccion.id_direccion  AND f.id_proveedor = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.rid_persona= tbl_direccion.id_persona 
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursalcompra)  
	where  f.id_proveedor=_id_cliente and f.fec_documento>=cast(fec_desde as date) and f.fec_documento<=cast(fec_hasta as date) and f.id_estado=1
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;

return $1;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


create or replace function planillas.spi_asistencia(
	_id bigint ,
	_codigo_barra varchar(30),
	_id_sucursal integer
)
returns text[] as $$
declare
	_id_persona varchar(30);
	_asistencia_id bigint;
	res text[];
begin
if exists(select * from planillas.tbl_persona where cod_barras=_codigo_barra) then
	select id_persona into _id_persona from planillas.tbl_persona where cod_barras=_codigo_barra;
	insert into planillas.tbl_asistencia(id_persona,id_sucursal)VALUES(_id_persona,_id_sucursal) RETURNING tbl_asistencia.id INTO _asistencia_id;
	res=array['0','Asistencia generada',_asistencia_id::text];
else
	res=array['520','Codigo no existe',_asistencia_id::text];
end if;
return res;
end;$$
language 'plpgsql';





CREATE OR REPLACE FUNCTION compras.fn_dscto_notacredito(
	_id__compra bigint,
	_id_sucursal integer)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
	dat record;
	imp_notacredito numeric(20,6);
	cantidad_compras numeric(20,6);
	__id__compra bigint ;
	__id_sucursal integer;
begin
 

	 SELECT sum(dc.imp_incluido) into imp_notacredito
	   FROM compras.tbl_compra cp
	     JOIN compras.tbl_detcompra dc ON cp.id__compra = dc.id__compra AND cp.id_sucursalcompra = dc.id_sucursalcompra
	  WHERE cp.nota_credito = true AND cp.id__compra__ref=_id__compra and cp.id__sucursal__ref=_id_sucursal and 
	  cp.id_estado=1 and dc.id_estado=1 and (cp.id_motivonotacredito = ANY (ARRAY['04'::bpchar, '05'::bpchar, '09'::bpchar]));
	
	RAISE NOTICE 'imp_notacredito is %', imp_notacredito;

	SELECT sum(x1.cantidad)  into cantidad_compras
	   FROM compras.tbl_detcompra dc
	   JOIN compras.tbl_compra cc ON cc.id__compra= dc.id__compra AND cc.id_sucursalcompra = dc.id_sucursalcompra
	   JOIN LATERAL almacen.fn_stock(dc.id_producto, dc.id_unidadventa, dc.id_almacen, dc.cantidad) x1(product_id, unit_id, val_unit, stock, cantidad) ON x1.product_id::text = dc.id_producto::text
	WHERE dc.imp_incluido > 0::numeric AND dc.id_estado = 1 and cc.id_estado=1 and  cc.id__compra=_id__compra and cc.id_sucursalcompra=_id_sucursal
	  --GROUP BY cc.id__compra, cc.id_sucursalcompra,dc.id_producto,x1.unit_id
	;
	if cantidad_compras>0 then
		return  COALESCE(imp_notacredito,0)/COALESCE(cantidad_compras,0);
	else
		return 0.0000;
	end if;
end;
$BODY$;

select  *from compras.fn_dscto_notacredito(1218,1);


select  d.item,d.id_producto,producto,desc_unidad,cantidad,dp.val_unidad from compras.v_detcompras d
inner join almacen.tbl_detproducto dp on dp.id_producto=d.id_producto and dp.id_unidadventa=d.id_unidadventa   where ID__COMPRA = 32 and id_sucursalcompra = 1 order by item

CREATE OR REPLACE FUNCTION ventas.cur_cantidad_productos_semanales(
    refcursor,
    op integer,
    mes integer,
    _id_empresa integer,
    vend text,
    text)
  RETURNS refcursor AS
$BODY$
begin
if op=1 then
 open $1 for  select vendedor,
		COALESCE(uno,0) as uno,
		COALESCE(dos,0) as dos,
		COALESCE(tres,0) as tres,
		COALESCE(cuatro,0) as cuatro,
		COALESCE(cinco,0) as cinco,
		COALESCE(seis,0) as seis,
		COALESCE(ciete,0) as ciete,
		COALESCE(ocho,0) as ocho,
		COALESCE(nueve,0) as nueve,
		COALESCE(diez,0) as diez,
		COALESCE(once,0) as once,
		COALESCE(doce,0) as doce,
		COALESCE(trece,0) as trece,
		COALESCE(catorce,0) as catorce,
		COALESCE(quince,0) qunce ,
		   COALESCE(dieciseis ,0) dieciseis,
		   COALESCE(diecisiete ,0) diecisiete,
		   COALESCE(dieciocho,0) dieciocho,
		   COALESCE(diecinueve,0) diecinueve,
		   COALESCE(veinte,0) veinte,
		   COALESCE(ventiuno,0) ventiuno,
		   COALESCE(ventidos,0) ventidos,
		   COALESCE(ventitres,0) ventitres,
		   COALESCE(venticuatro,0) venticuatro,
		   COALESCE(venticinco,0)venticinco,
		   COALESCE(ventiseis,0) ventiseis,
		   COALESCE(venticiete,0) venticiete,
		   COALESCE(ventiocho,0) ventiocho,
		   COALESCE(ventinueve,0) ventinueve,
		   COALESCE(trienta,0) trienta,
		   COALESCE(treintauno,0) treintauno,		   
		(COALESCE(uno,0)+
		COALESCE(dos,0)+ 
		COALESCE(tres,0)+
		COALESCE(cuatro,0)+
		COALESCE(cinco,0)+
		COALESCE(seis,0) +
		COALESCE(ciete,0)+
		COALESCE(ocho,0) +
		COALESCE(nueve,0) +
		COALESCE(diez,0) +
		COALESCE(once,0) +
		COALESCE(doce,0) +
		COALESCE(trece,0)+
		COALESCE(catorce,0)+
		COALESCE(quince,0)+
		   COALESCE(dieciseis ,0) +
		   COALESCE(diecisiete ,0) +
		   COALESCE(dieciocho,0) +
		   COALESCE(diecinueve,0) +
		   COALESCE(veinte,0) +
		   COALESCE(ventiuno,0)+
		   COALESCE(ventidos,0) +
		   COALESCE(ventitres,0) +
		   COALESCE(venticuatro,0)+
		   COALESCE(venticinco,0)+
		   COALESCE(ventiseis,0) +
		   COALESCE(venticiete,0) +
		   COALESCE(ventiocho,0) +
		   COALESCE(ventinueve,0) +
		   COALESCE(trienta,0) +
		   COALESCE(treintauno,0) ) as cantidad_ventas
	
	  from crosstab(
		  '(select pro.descripcion_larga as producto, date_part(''day'',fecha_venta), 
		sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0))
		  from ventas.tbl_facturacion f
		   inner join planillas.tbl_persona cli on (cli.id_persona=f.id_cliente)
		  inner join planillas.tbl_persona vend on (vend.id_persona=cli.id_vendtitular)		 
		  inner join ventas.tbl_detfacturacion df on(df.id_facturacion=f.id_facturacion and f.id_sucursal=df.id_sucursal)
		  inner join almacen.tbl_producto pro on (pro.id_producto=df.id_producto)
		  INNER JOIN COMMON.tbl_sucursal S ON (S.ID_SUCURSAL=F.ID_SUCURSAL)
		   where date_part(''month'',fecha_venta::date) = ''' || mes || '''  and S.ID_EMPRESA= ''' || _id_empresa || ''' and
		   date_part(''year'',fecha_venta::date)=date_part(''year'',now()::date) 
			and df.id_estado=1 and 
			f.id_estado=1 and pro.servicio=false AND F.nota_credito=false
			and and vend.id_persona='''||  vend || '''
		  group by pro.descripcion_larga, date_part(''day'',fecha_venta) order by 1) ',
		  'select m from generate_series(1,32) m') as (
		   vendedor text,
		   uno  NUMERIC(14,3), 
		   dos NUMERIC(14,3),
		   tres NUMERIC(14,3), 
		   cuatro NUMERIC(14,3), 
		   cinco NUMERIC(14,3), 
		   seis NUMERIC(14,3), 
		   ciete NUMERIC(14,3), 
		   ocho NUMERIC(14,3), 
		   nueve NUMERIC(14,3), 
		   diez NUMERIC(14,3), 
		   once NUMERIC(14,3), 
		   doce NUMERIC(14,3),
		   trece NUMERIC(14,3),
		   catorce NUMERIC(14,3),
		   quince  NUMERIC(14,3), 
		   dieciseis NUMERIC(14,3),
		   diecisiete NUMERIC(14,3), 
		   dieciocho NUMERIC(14,3), 
		   diecinueve NUMERIC(14,3), 
		   veinte NUMERIC(14,3), 
		   ventiuno NUMERIC(14,3), 
		   ventidos NUMERIC(14,3), 
		   ventitres NUMERIC(14,3), 
		   venticuatro NUMERIC(14,3), 
		   venticinco NUMERIC(14,3), 
		   ventiseis NUMERIC(14,3),
		   venticiete NUMERIC(14,3),
		   ventiocho NUMERIC(14,3),
		   ventinueve NUMERIC(14,3),
		   trienta NUMERIC(14,3),
		   treintauno NUMERIC(14,3),
		   total NUMERIC(14,3)
	  );/*
union
select p.personal,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
from personal.v_listar_personal_ventas as p
where p.idpersonal not in (select idpersonal from ventas.facturacion 
where date_part('month',fecha_emision::date) = date_part('month',now()::date) and 
date_part('year',fecha_emision::date)=date_part('year',now()::date) and anulado='N');*/

end if;
if op=2 then
	open $1 for  select vendedor,
		COALESCE(uno,0) as uno,
		COALESCE(dos,0) as dos,
		COALESCE(tres,0) as tres,
		COALESCE(cuatro,0) as cuatro,
		COALESCE(cinco,0) as cinco,
		COALESCE(seis,0) as seis,
		COALESCE(ciete,0) as ciete,
		COALESCE(ocho,0) as ocho,
		COALESCE(nueve,0) as nueve,
		COALESCE(diez,0) as diez,
		COALESCE(once,0) as once,
		COALESCE(doce,0) as doce,
		COALESCE(trece,0) as trece,
		COALESCE(catorce,0) as catorce,
		COALESCE(quince,0) qunce ,
		   COALESCE(dieciseis ,0) dieciseis,
		   COALESCE(diecisiete ,0) diecisiete,
		   COALESCE(dieciocho,0) dieciocho,
		   COALESCE(diecinueve,0) diecinueve,
		   COALESCE(veinte,0) veinte,
		   COALESCE(ventiuno,0) ventiuno,
		   COALESCE(ventidos,0) ventidos,
		   COALESCE(ventitres,0) ventitres,
		   COALESCE(venticuatro,0) venticuatro,
		   COALESCE(venticinco,0)venticinco,
		   COALESCE(ventiseis,0) ventiseis,
		   COALESCE(venticiete,0) venticiete,
		   COALESCE(ventiocho,0) ventiocho,
		   COALESCE(ventinueve,0) ventinueve,
		   COALESCE(trienta,0) trienta,
		   COALESCE(treintauno,0) treintauno,		   
		(COALESCE(uno,0)+
		COALESCE(dos,0)+ 
		COALESCE(tres,0)+
		COALESCE(cuatro,0)+
		COALESCE(cinco,0)+
		COALESCE(seis,0) +
		COALESCE(ciete,0)+
		COALESCE(ocho,0) +
		COALESCE(nueve,0) +
		COALESCE(diez,0) +
		COALESCE(once,0) +
		COALESCE(doce,0) +
		COALESCE(trece,0)+
		COALESCE(catorce,0)+
		COALESCE(quince,0)+
		   COALESCE(dieciseis ,0) +
		   COALESCE(diecisiete ,0) +
		   COALESCE(dieciocho,0) +
		   COALESCE(diecinueve,0) +
		   COALESCE(veinte,0) +
		   COALESCE(ventiuno,0)+
		   COALESCE(ventidos,0) +
		   COALESCE(ventitres,0) +
		   COALESCE(venticuatro,0)+
		   COALESCE(venticinco,0)+
		   COALESCE(ventiseis,0) +
		   COALESCE(venticiete,0) +
		   COALESCE(ventiocho,0) +
		   COALESCE(ventinueve,0) +
		   COALESCE(trienta,0) +
		   COALESCE(treintauno,0) ) as cantidad_ventas
	
	  from crosstab(
		  '(select pro.descripcion_larga as producto, date_part(''day'',fecha_venta), 
		  sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0))
		  from ventas.tbl_facturacion f
		   inner join planillas.tbl_persona cli on (cli.id_persona=f.id_cliente)
		  inner join planillas.tbl_persona vend on (vend.id_persona=cli.id_vendtitular)		 
		  inner join ventas.tbl_detfacturacion df on(df.id_facturacion=f.id_facturacion and f.id_sucursal=df.id_sucursal)
		  inner join almacen.tbl_producto pro on (pro.id_producto=df.id_producto)
		  INNER JOIN COMMON.tbl_sucursal S ON (S.ID_SUCURSAL=F.ID_SUCURSAL)
		   where date_part(''month'',fecha_venta::date) = ''' || mes || '''  and S.ID_EMPRESA= ''' || _id_empresa || ''' and f.nota_credito=false and
		   date_part(''year'',fecha_venta::date)=date_part(''year'',now()::date) and df.id_estado=1 and pro.servicio=false and f.id_estado=1 
		  group by pro.descripcion_larga, date_part(''day'',fecha_venta) order by 1) ',
		  'select m from generate_series(1,32) m') as (
		   vendedor text,
		   uno  NUMERIC(14,3), 
		   dos NUMERIC(14,3),
		   tres NUMERIC(14,3), 
		   cuatro NUMERIC(14,3), 
		   cinco NUMERIC(14,3), 
		   seis NUMERIC(14,3), 
		   ciete NUMERIC(14,3), 
		   ocho NUMERIC(14,3), 
		   nueve NUMERIC(14,3), 
		   diez NUMERIC(14,3), 
		   once NUMERIC(14,3), 
		   doce NUMERIC(14,3),
		   trece NUMERIC(14,3),
		   catorce NUMERIC(14,3),
		   quince  NUMERIC(14,3), 
		   dieciseis NUMERIC(14,3),
		   diecisiete NUMERIC(14,3), 
		   dieciocho NUMERIC(14,3), 
		   diecinueve NUMERIC(14,3), 
		   veinte NUMERIC(14,3), 
		   ventiuno NUMERIC(14,3), 
		   ventidos NUMERIC(14,3), 
		   ventitres NUMERIC(14,3), 
		   venticuatro NUMERIC(14,3), 
		   venticinco NUMERIC(14,3), 
		   ventiseis NUMERIC(14,3),
		   venticiete NUMERIC(14,3),
		   ventiocho NUMERIC(14,3),
		   ventinueve NUMERIC(14,3),
		   trienta NUMERIC(14,3),
		   treintauno NUMERIC(14,3),
		   total NUMERIC(14,3)
	  );
end if;
	return $1;
end ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION ventas.cur_cantidad_productos_diarias(
    refcursor,
    op integer,
    mes integer,
    _id_empresa integer,
    vend text,
    text)
  RETURNS refcursor AS
$BODY$
begin
if op=1 then
 open $1 for  select vendedor,
		COALESCE(uno,0) as uno,
		COALESCE(dos,0) as dos,
		COALESCE(tres,0) as tres,
		COALESCE(cuatro,0) as cuatro,
		COALESCE(cinco,0) as cinco,
		COALESCE(seis,0) as seis,
		COALESCE(ciete,0) as ciete,
		COALESCE(ocho,0) as ocho,
		COALESCE(nueve,0) as nueve,
		COALESCE(diez,0) as diez,
		COALESCE(once,0) as once,
		COALESCE(doce,0) as doce,
		COALESCE(trece,0) as trece,
		COALESCE(catorce,0) as catorce,
		COALESCE(quince,0) qunce ,
		   COALESCE(dieciseis ,0) dieciseis,
		   COALESCE(diecisiete ,0) diecisiete,
		   COALESCE(dieciocho,0) dieciocho,
		   COALESCE(diecinueve,0) diecinueve,
		   COALESCE(veinte,0) veinte,
		   COALESCE(ventiuno,0) ventiuno,
		   COALESCE(ventidos,0) ventidos,
		   COALESCE(ventitres,0) ventitres,
		   COALESCE(venticuatro,0) venticuatro,
		   COALESCE(venticinco,0)venticinco,
		   COALESCE(ventiseis,0) ventiseis,
		   COALESCE(venticiete,0) venticiete,
		   COALESCE(ventiocho,0) ventiocho,
		   COALESCE(ventinueve,0) ventinueve,
		   COALESCE(trienta,0) trienta,
		   COALESCE(treintauno,0) treintauno,		   
		(COALESCE(uno,0)+
		COALESCE(dos,0)+ 
		COALESCE(tres,0)+
		COALESCE(cuatro,0)+
		COALESCE(cinco,0)+
		COALESCE(seis,0) +
		COALESCE(ciete,0)+
		COALESCE(ocho,0) +
		COALESCE(nueve,0) +
		COALESCE(diez,0) +
		COALESCE(once,0) +
		COALESCE(doce,0) +
		COALESCE(trece,0)+
		COALESCE(catorce,0)+
		COALESCE(quince,0)+
		   COALESCE(dieciseis ,0) +
		   COALESCE(diecisiete ,0) +
		   COALESCE(dieciocho,0) +
		   COALESCE(diecinueve,0) +
		   COALESCE(veinte,0) +
		   COALESCE(ventiuno,0)+
		   COALESCE(ventidos,0) +
		   COALESCE(ventitres,0) +
		   COALESCE(venticuatro,0)+
		   COALESCE(venticinco,0)+
		   COALESCE(ventiseis,0) +
		   COALESCE(venticiete,0) +
		   COALESCE(ventiocho,0) +
		   COALESCE(ventinueve,0) +
		   COALESCE(trienta,0) +
		   COALESCE(treintauno,0) ) as cantidad_ventas
	
	  from crosstab(
		  '(select pro.descripcion_larga as producto, date_part(''day'',fecha_venta), 
		sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0))
		  from ventas.tbl_facturacion f
		   inner join planillas.tbl_persona cli on (cli.id_persona=f.id_cliente)
		  inner join planillas.tbl_persona vend on (vend.id_persona=cli.id_vendtitular)		 
		  inner join ventas.tbl_detfacturacion df on(df.id_facturacion=f.id_facturacion and f.id_sucursal=df.id_sucursal)
		  inner join almacen.tbl_producto pro on (pro.id_producto=df.id_producto)
		  INNER JOIN COMMON.tbl_sucursal S ON (S.ID_SUCURSAL=F.ID_SUCURSAL)
		   where date_part(''month'',fecha_venta::date) = ''' || mes || '''  and S.ID_EMPRESA= ''' || _id_empresa || ''' and
		   date_part(''year'',fecha_venta::date)=date_part(''year'',now()::date) 
			and df.id_estado=1 and 
			f.id_estado=1 and pro.servicio=false AND F.nota_credito=false
			and and vend.id_persona='''||  vend || '''
		  group by pro.descripcion_larga, date_part(''day'',fecha_venta) order by 1) ',
		  'select m from generate_series(1,32) m') as (
		   vendedor text,
		   uno  NUMERIC(14,3), 
		   dos NUMERIC(14,3),
		   tres NUMERIC(14,3), 
		   cuatro NUMERIC(14,3), 
		   cinco NUMERIC(14,3), 
		   seis NUMERIC(14,3), 
		   ciete NUMERIC(14,3), 
		   ocho NUMERIC(14,3), 
		   nueve NUMERIC(14,3), 
		   diez NUMERIC(14,3), 
		   once NUMERIC(14,3), 
		   doce NUMERIC(14,3),
		   trece NUMERIC(14,3),
		   catorce NUMERIC(14,3),
		   quince  NUMERIC(14,3), 
		   dieciseis NUMERIC(14,3),
		   diecisiete NUMERIC(14,3), 
		   dieciocho NUMERIC(14,3), 
		   diecinueve NUMERIC(14,3), 
		   veinte NUMERIC(14,3), 
		   ventiuno NUMERIC(14,3), 
		   ventidos NUMERIC(14,3), 
		   ventitres NUMERIC(14,3), 
		   venticuatro NUMERIC(14,3), 
		   venticinco NUMERIC(14,3), 
		   ventiseis NUMERIC(14,3),
		   venticiete NUMERIC(14,3),
		   ventiocho NUMERIC(14,3),
		   ventinueve NUMERIC(14,3),
		   trienta NUMERIC(14,3),
		   treintauno NUMERIC(14,3),
		   total NUMERIC(14,3)
	  );/*
union
select p.personal,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
from personal.v_listar_personal_ventas as p
where p.idpersonal not in (select idpersonal from ventas.facturacion 
where date_part('month',fecha_emision::date) = date_part('month',now()::date) and 
date_part('year',fecha_emision::date)=date_part('year',now()::date) and anulado='N');*/

end if;
if op=2 then
	open $1 for  select vendedor,
		COALESCE(uno,0) as uno,
		COALESCE(dos,0) as dos,
		COALESCE(tres,0) as tres,
		COALESCE(cuatro,0) as cuatro,
		COALESCE(cinco,0) as cinco,
		COALESCE(seis,0) as seis,
		COALESCE(ciete,0) as ciete,
		COALESCE(ocho,0) as ocho,
		COALESCE(nueve,0) as nueve,
		COALESCE(diez,0) as diez,
		COALESCE(once,0) as once,
		COALESCE(doce,0) as doce,
		COALESCE(trece,0) as trece,
		COALESCE(catorce,0) as catorce,
		COALESCE(quince,0) qunce ,
		   COALESCE(dieciseis ,0) dieciseis,
		   COALESCE(diecisiete ,0) diecisiete,
		   COALESCE(dieciocho,0) dieciocho,
		   COALESCE(diecinueve,0) diecinueve,
		   COALESCE(veinte,0) veinte,
		   COALESCE(ventiuno,0) ventiuno,
		   COALESCE(ventidos,0) ventidos,
		   COALESCE(ventitres,0) ventitres,
		   COALESCE(venticuatro,0) venticuatro,
		   COALESCE(venticinco,0)venticinco,
		   COALESCE(ventiseis,0) ventiseis,
		   COALESCE(venticiete,0) venticiete,
		   COALESCE(ventiocho,0) ventiocho,
		   COALESCE(ventinueve,0) ventinueve,
		   COALESCE(trienta,0) trienta,
		   COALESCE(treintauno,0) treintauno,		   
		(COALESCE(uno,0)+
		COALESCE(dos,0)+ 
		COALESCE(tres,0)+
		COALESCE(cuatro,0)+
		COALESCE(cinco,0)+
		COALESCE(seis,0) +
		COALESCE(ciete,0)+
		COALESCE(ocho,0) +
		COALESCE(nueve,0) +
		COALESCE(diez,0) +
		COALESCE(once,0) +
		COALESCE(doce,0) +
		COALESCE(trece,0)+
		COALESCE(catorce,0)+
		COALESCE(quince,0)+
		   COALESCE(dieciseis ,0) +
		   COALESCE(diecisiete ,0) +
		   COALESCE(dieciocho,0) +
		   COALESCE(diecinueve,0) +
		   COALESCE(veinte,0) +
		   COALESCE(ventiuno,0)+
		   COALESCE(ventidos,0) +
		   COALESCE(ventitres,0) +
		   COALESCE(venticuatro,0)+
		   COALESCE(venticinco,0)+
		   COALESCE(ventiseis,0) +
		   COALESCE(venticiete,0) +
		   COALESCE(ventiocho,0) +
		   COALESCE(ventinueve,0) +
		   COALESCE(trienta,0) +
		   COALESCE(treintauno,0) ) as cantidad_ventas
	
	  from crosstab(
		  '(select pro.descripcion_larga as producto, date_part(''day'',fecha_venta), 
		  sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0))
		  from ventas.tbl_facturacion f
		   inner join planillas.tbl_persona cli on (cli.id_persona=f.id_cliente)
		  inner join planillas.tbl_persona vend on (vend.id_persona=cli.id_vendtitular)		 
		  inner join ventas.tbl_detfacturacion df on(df.id_facturacion=f.id_facturacion and f.id_sucursal=df.id_sucursal)
		  inner join almacen.tbl_producto pro on (pro.id_producto=df.id_producto)
		  INNER JOIN COMMON.tbl_sucursal S ON (S.ID_SUCURSAL=F.ID_SUCURSAL)
		   where date_part(''month'',fecha_venta::date) = ''' || mes || '''  and S.ID_EMPRESA= ''' || _id_empresa || ''' and f.nota_credito=false and
		   date_part(''year'',fecha_venta::date)=date_part(''year'',now()::date) and df.id_estado=1 and pro.servicio=false and f.id_estado=1 
		  group by pro.descripcion_larga, date_part(''day'',fecha_venta) order by 1) ',
		  'select m from generate_series(1,32) m') as (
		   vendedor text,
		   uno  NUMERIC(14,3), 
		   dos NUMERIC(14,3),
		   tres NUMERIC(14,3), 
		   cuatro NUMERIC(14,3), 
		   cinco NUMERIC(14,3), 
		   seis NUMERIC(14,3), 
		   ciete NUMERIC(14,3), 
		   ocho NUMERIC(14,3), 
		   nueve NUMERIC(14,3), 
		   diez NUMERIC(14,3), 
		   once NUMERIC(14,3), 
		   doce NUMERIC(14,3),
		   trece NUMERIC(14,3),
		   catorce NUMERIC(14,3),
		   quince  NUMERIC(14,3), 
		   dieciseis NUMERIC(14,3),
		   diecisiete NUMERIC(14,3), 
		   dieciocho NUMERIC(14,3), 
		   diecinueve NUMERIC(14,3), 
		   veinte NUMERIC(14,3), 
		   ventiuno NUMERIC(14,3), 
		   ventidos NUMERIC(14,3), 
		   ventitres NUMERIC(14,3), 
		   venticuatro NUMERIC(14,3), 
		   venticinco NUMERIC(14,3), 
		   ventiseis NUMERIC(14,3),
		   venticiete NUMERIC(14,3),
		   ventiocho NUMERIC(14,3),
		   ventinueve NUMERIC(14,3),
		   trienta NUMERIC(14,3),
		   treintauno NUMERIC(14,3),
		   total NUMERIC(14,3)
	  );
end if;
	return $1;
end ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from COMPRAS.ISP_DETORDENCOTIZACOMPRA(1,1,1,'4419',35,35,1,'7 SEMILLAS INST. 265GR X 8 UND','1'::numeric,'6.2190'::numeric,'0.00'::numeric,'0.95'::numeric,'5.27'::numeric,'6.22'::numeric,'0.00'::numeric,'6.22'::numeric,'35'::numeric,1,'FALSE','1    ','2020-12-03 21:12:59.578','6.22'::numeric,'0.0000'::numeric)

CREATE OR REPLACE FUNCTION compras.isp_detordencotizacompra(
    op integer,
    _id_cotizaorden bigint,
    _item integer,
    _id_producto character varying,
    _id_unidad integer,
    _id_unidadpedido integer,
    _id_listaprecio integer,
    _descripcion_linea text,
    _cantidad numeric,
    _costo_unitario numeric,
    _porcent_dscto numeric,
    _imp_igv numeric,
    _valor_venta numeric,
    _total numeric,
    _imp_dscto numeric,
    _imp_bruto numeric,
    _porcent_igv numeric,
    _id_estado integer,
    _modo_texto boolean,
    _id_usuario character,
    _fecha text,
    _total_dolares numeric,
    _peso numeric(20,4)
)
  RETURNS text[] AS
$BODY$
DECLARE
	RES TEXT[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT *FROM COMPRAS.TBL_ORDENCOTIZACOMPRA WHERE id_cotizaorden=_id_cotizaorden)THEN
		IF EXISTS(SELECT *FROM ALMACEN.TBL_PRECIO WHERE id_producto=_id_producto AND id_unidadventa=_id_unidad and  id_listaprecio=_id_listaprecio) THEN
		INSERT INTO compras.tbl_detordencotizacomp(
			id_cotizaorden, 
			item, 
			id_producto, 
			id_unidad, 
			id_unidadpedido, 
			id_listaprecio, 
			descripcion_linea, 
			cantidad, 
			costo_unitario, 
			porcent_dscto, 
			imp_igv, 
			valor_venta, 
			total, 
			imp_dscto, 
			imp_bruto, 
			porcent_igv, 
			id_estado, 
			modo_texto, 
			id_usuario, 
			fecha, 
			fecha_actualiza,
			total_dolares,
			peso
			)
		VALUES (
			_id_cotizaorden, 
			_item, 
			_id_producto, 
			_id_unidad, 
			_id_unidadpedido, 
			_id_listaprecio, 
			_descripcion_linea, 
			_cantidad, 
			_costo_unitario, 
			_porcent_dscto, 
			_imp_igv, 
			_valor_venta, 
			_total, 
			_imp_dscto, 
			_imp_bruto, 
			_porcent_igv, 
			_id_estado, 
			_modo_texto, 
			_id_usuario, 
			to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			now(),
			_total_dolares,
			_peso
		) RETURNING ARRAY['0',id_cotizaorden::TEXT] into res;
			IF NOT FOUND THEN
				RES:=ARRAY['504','Verefique que los datos del detalle de orden de compra este ingresado correctamente'];
			END IF;
			
		ELSE
			RES:=ARRAY['504','Seleccione correctamente el producto con el codigo' || _id_producto];
		END IF;
	ELSE
		RES:=ARRAY['503','No existe la orden de compra'];
	END IF;

END if;
IF OP=2 THEN
	IF EXISTS(SELECT *FROM COMPRAS.TBL_ORDENCOTIZACOMPRA WHERE id_cotizaorden=_id_cotizaorden)THEN
		IF EXISTS(SELECT *FROM ALMACEN.TBL_PRECIO WHERE id_producto=_id_producto AND id_unidadventa=_id_unidad and  id_listaprecio=_id_listaprecio) THEN
			UPDATE compras.tbl_detordencotizacomp
			   SET 
				id_cotizaorden=_id_cotizaorden, 
				item=_item, 
				id_producto=_id_producto, 
				id_unidad=_id_unidad, 
				id_unidadpedido=_id_unidadpedido, 
				id_listaprecio=_id_listaprecio, 
				descripcion_linea=_descripcion_linea, 
				cantidad=_cantidad, 
				costo_unitario=_costo_unitario, 
				porcent_dscto=_porcent_dscto, 
				imp_igv=_imp_igv, 
				valor_venta=_valor_venta, 
				total=_total, 
				imp_dscto=_imp_dscto, 
				imp_bruto=_imp_bruto, 
				porcent_igv=_porcent_igv, 
				id_estado=_id_estado, 
				modo_texto=_modo_texto, 
				id_usuario=_id_usuario, 
				fecha_actualiza=now(),
				total_dolares=_total_dolares,
				peso=_peso
			 WHERE id_cotizaorden=_id_cotizaorden and item=_item and id_producto=_id_producto and id_unidad=_id_unidad and id_listaprecio=_id_listaprecio;
			res:=array['0','Actualización efectuada con exito'];
		ELSE
			RES:=ARRAY['504','Seleccione correctamente el producto con el codigo' || _id_producto];
		END IF;
	ELSE
		RES:=ARRAY['503','No existe la orden de compra'];
	END IF;
END IF;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



create or replace function ventas.fn_anular_resumen( 
_resumen_id bigint
)
returns text[] as $$
declare
	dat record;
	res text[];
begin


update ventas.tbl_resumen set status_id=7 where resumen_id=_resumen_id;
for dat in select *from ventas.tbl_detresumen where resumen_id=_resumen_id loop
	update ventas.tbl_facturacion set enviado_status=0 where id_facturacion=dat.id_facturacion and id_sucursal=dat.id_sucursal;
end loop;
res:=array['0','Resumen Anulado'];
return res;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION ventas.corregir_correlativo()
  RETURNS text AS
$BODY$
declare
	dat record;
	num bigint;
begin
  num:=6331;
 for dat in select id_facturacion,id_sucursal from ventas.tbl_facturacion 
	where fecha_venta::date>'13/07/2020' 
	--and numdoc_facturacion::integer>6330 
	and id_comprobante=2   
	order by fecha_venta asc,id_facturacion asc loop
	update ventas.tbl_facturacion set serie_facturacion='B001',numdoc_facturacion= lpad(num::text,7,'0'),enviado_status=0 
	where id_facturacion=dat.id_facturacion and id_sucursal=dat.id_sucursal;
	num:=num+1;
	RAISE NOTICE 'num %', num;
end loop;
return '';
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION almacen.corregir_codigo_producto()
  RETURNS text AS
$BODY$
declare
	dat record;
	num bigint;
begin
  num:=1000;
 for dat in select *from almacen.tbl_producto 
	order by id_producto::integer asc loop
	update almacen.tbl_producto set codigo= num::text
	where id_producto=dat.id_producto ;
	num:=num+1;
	RAISE NOTICE 'num %', num;
end loop;
return '';
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select  *from almacen.corregir_codigo_producto();

CREATE OR REPLACE FUNCTION ventas.ISP_NOTADEBITO(
    op integer,
    _id_facturacion integer,
    _numdoc_facturacion character,
    _id_detatencion character,
    _id_tipoventa integer,
    _id_tipocambio integer,
    _id_igv integer,
    _id_direccion bigint,
    _id_pedido character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _serie_facturacion character,
    _fecha_venta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _imp_neto numeric,
    _imp_igv numeric,
    _imp_redondeo numeric,
    _imp_total numeric,
    _tasa_persepcion numeric,
    _valor_venta numeric,
    _id_moneda integer,
    _id_estado integer,
    _id_cliente character varying,
    _id_operacion integer,
    _id_sucursal integer,
    _id_facturacionref integer,
    _id_sucursalref integer,
    _id_vendedor character varying,
    _nota_credito boolean,
    _id_motivonotacredito character varying,
    _glosa text,
    _dni_cliente character varying,
    _nomape_cliente text,
    _direccion_cliente text)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
begin
if op=1 then
	if not exists(select *from ventas.tbl_facturacion where 
				numdoc_facturacion=_numdoc_facturacion and 
				serie_facturacion=_serie_facturacion and  id_comprobante=_id_comprobante ) then
		if exists(select *from planillas.tbl_persona where id_persona=_id_vendedor) then
			select max(id_facturacion) into correl from ventas.tbl_facturacion where id_sucursal=_id_sucursal;
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
				end if;
				insert into ventas.tbl_facturacion(
						id_facturacion,
						numdoc_facturacion,
						id_detatencion,
						id_tipoventa,
						id_tipocambio,
						id_igv,
						id_direccion,
						id_pedido   ,
						id_comprobante ,
						id_tranzaccion ,
						serie_facturacion,
						fecha_venta      ,
						imp_bruto        ,
						imp_dscto        ,
						imp_neto         ,
						imp_igv          ,
						imp_redondeo     ,
						imp_total        ,
						tasa_persepcion  ,
						valor_venta  ,
						id_moneda        ,
						id_estado        ,
						id_cliente       ,
						id_operacion     ,
						id_sucursal,
						id_facturacionref ,
						id_sucursalref ,
						id_vendedor,
						nota_debito,
						id_motivonotadebito,
						glosa,
					       dni_cliente,
					       nomape_cliente,
					       direccion_cliente
						
				)values(
						correl,
						_numdoc_facturacion,
						_id_detatencion,
						_id_tipoventa,
						_id_tipocambio,
						_id_igv,
						_id_direccion,
						_id_pedido   ,
						_id_comprobante ,
						_id_tranzaccion ,
						_serie_facturacion,
						to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS')      ,
						_imp_bruto        ,
						_imp_dscto        ,
						_imp_neto         ,
						_imp_igv          ,
						_imp_redondeo     ,
						_imp_total        ,
						_tasa_persepcion  ,
						_valor_venta ,
						_id_moneda        ,
						_id_estado        ,
						_id_cliente       ,
						_id_operacion     ,
						_id_sucursal,
						case when _id_facturacionref=0 then null else _id_facturacionref end  ,
						case when _id_sucursalref =0 then null else _id_sucursalref  end,
						_id_vendedor,
						true,
						_ID_MOTIVONOTACREDITO,
						_glosa,
						_dni_cliente,
					        _nomape_cliente,
					        _direccion_cliente
				) returning array['0',tbl_facturacion.id_facturacion::text, 
						tbl_facturacion.id_sucursal::text
						]into res;
				if not found then
					res:=array['504','Ocurrio un error al registar el documento de venta\n verefique que los datos esten ingresados correctamente'];
				end if;
			else
				res:=array['501','Seleccione correctamente el cliente'];
			end if;
		else
			res:=array['502','Seleccione correctamente el vendedor'];
			--exit;
		end if;
	else
		res:=array['504','El documento con serie ' || _serie_facturacion ||' Nro : ' || _numdoc_facturacion || ' ya se encuentran registrados'];
		--exit;
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		
			update ventas.tbl_facturacion set 
						numdoc_facturacion=_numdoc_facturacion,
						id_detatencion=_id_detatencion,
						id_tipoventa=_id_tipoventa,
						id_tipocambio=_id_tipocambio,
						id_igv=_id_igv,
						id_direccion=_id_direccion,
						id_pedido=_id_pedido,
						id_comprobante=_id_comprobante ,
						id_tranzaccion=_id_tranzaccion ,
						serie_facturacion=_serie_facturacion,
						fecha_venta=to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
						imp_bruto=_imp_bruto,
						imp_dscto=_imp_dscto,
						imp_neto=_imp_neto,
						imp_igv=_imp_igv,
						imp_redondeo=_imp_redondeo,
						imp_total=_imp_total,
						tasa_persepcion=_tasa_persepcion,
						valor_venta=_valor_venta,
						id_moneda=_id_moneda,
						id_estado=_id_estado,
						id_cliente=_id_cliente,
						id_operacion=_id_operacion,
						id_facturacionref=case when _id_facturacionref=0 then null else _id_facturacionref end ,
						id_sucursalref=case when _id_sucursalref =0 then null else _id_sucursalref  end ,
						id_vendedor=_id_vendedor,
						nota_credito=_nota_credito,
						id_motivonotadebito=_ID_MOTIVONOTACREDITO,
						glosa=_glosa,
						dni_cliente=_dni_cliente,
					        nomape_cliente=_nomape_cliente,
					        direccion_cliente=_direccion_cliente
						 where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						res:=array['0',_id_facturacion::text,_id_sucursal::text];
		
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
RETURN RES;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION hotel.isp_grabarCheckIn(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,--23
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,--30
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono  varchar(50),--39
    _orden_compra text,
    _fecha_ingreso text,
    _hora_ingreso text,
    _fecha_salida text,
    _hora_salida text,
    _id_habitacion integer
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		if (_id_cliente='000'  and _imp_total>750 )  then
			res:=array['506','Es obligatorio ingresar datos completos del cliente(DNI,Nombres y apellidos,direccion) a partir de 750.00  soles'];
			return res;
		end if;
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI,
			    orden_compra,
			    habitacion_id
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    _numero, 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono,
			    _orden_compra,
			    _id_habitacion
			    			    
		) RETURNING ARRAY['0',id_cotizapreventa::TEXT,id_sucursal::TEXT] INTO RES;
		IF NOT FOUND THEN
			RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    serie=_serie, 
				    numero=_numero, 
				    id_comprobante=_id_comprobante, 
				    fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono,
				    orden_compra=_orden_compra,
				    habitacion_id=_id_habitacion
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
	END IF;
END IF;


return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;





CREATE OR REPLACE FUNCTION ventas.isp_segimcotizacion(
    op integer,
    _id_seguimiento bigint,
    _fecha text,
    _tema text,
    _concepto text,
    _fec_proximacita text,
    _hora_cita text,
    _id_estado integer,
    _id_usuario character,
    _id_cotizapreventa bigint,
    _id_sucursal integer)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl bigint;
BEGIN
if op=1 then
	if exists(select * from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
		select max(id_seguimiento) into correl from VENTAS.TBL_SEGIMCOTIZACION;
		if correl is null then 
			correl:=1;
		else
			correl:=correl+1;
		end if;
		INSERT INTO ventas.tbl_segimcotizacion(
			    id_seguimiento, 
			    fecha, 
			    tema, 
			    concepto, 
			    fec_proximacita, 
			    hora_cita, 
			    id_estado, 
			    id_usuario, 
			    id_cotizapreventa, 
			    id_sucursal
			)
		VALUES (
			    correl, 
			    to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _tema, 
			    _concepto, 
			    to_timestamp(_fec_proximacita,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _hora_cita, 
			    _id_estado, 
			    _id_usuario, 
			    _id_cotizapreventa, 
			    _id_sucursal
		) returning array['0',id_seguimiento] into res;
		if not found then
			res:=array['504','Inconsitencia inesperada al registrar el proceso'];
		end if;
	else
		res:=array['503','Verefique que exista el presupuesto seleccionado'];
	end if;
end if;
if op=2 then
	if exists (select 1 from ventas.tbl_segimcotizacion where id_seguimiento=_id_seguimiento) then
		UPDATE ventas.tbl_segimcotizacion
		   SET  fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			tema=_tema, 
			concepto=_concepto, 
			fec_proximacita=to_timestamp(_fec_proximacita,'YYYY-MM-DD HH24:MI:SS.MS'), 
			hora_cita=_hora_cita, 
			id_estado=_id_estado, 
			id_usuario=_id_usuario, 
			id_cotizapreventa=_id_cotizapreventa, 
		       id_sucursal=_id_sucursal
		 WHERE id_seguimiento=_id_seguimiento;
		res:=array['0','Proceso efectuado con exito'];
	else
		res:=array['502','Verefique exita el regitro al momento de actualizar'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from creditos.fn_letras_x_cobrar_fechas('01/01/2019','31/12/2019')

create or replace function creditos.fn_letras_x_cobrar_fechas(f1 text,f2 text)
returns table(
	dni varchar(12),
	cliente varchar(500),
	direccion text,
	zona varchar(200),
	sector varchar(200),
	documento text,
	fec_credito text,
	fec_vencimiento text,
	credito numeric(20,4),
	imp_nc numeric(20,4),
	pagos numeric(20,4),
	saldo numeric(20,4),
	total_venta numeric(20,4),
	tipo_venta text,
	moneda varchar(5),
	id_facturacion integer,
	id_sucursal integer,
	id_cliente varchar(15),
	id_direccion bigint,
	id_credito integer,
	id_sucursal_credito integer,
	comprobante char(3),
	serie_facturacion char(4),
	numdoc_facturacion char(7),
	id_empresa integer,
	id_sector integer,
	id_zona integer,
	id_vendedor varchar(15),
	vendedor varchar(500),
	dias integer,
	tlf_cliente text,
	ultimo_pago text,
	ubigeo text,
	garante text,
	id_distrito varchar(8),
	ruc_empresa char(12),
	empresa varchar(200),
	dir_sucursal varchar(100)
)
as $$
declare
begin

 return query SELECT
  cli.doc_persona AS dni,
  cli.nombre_razon AS cliente,
  dir.direccion,
  zon.zona,
  r.sector,
        CASE
            WHEN fac.id_unidad IS NULL THEN ((((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie_facturacion::text) || '-'::text) || fac.numdoc_facturacion::text)::character varying
            ELSE ( SELECT prod.descripcion_larga
               FROM almacen.tbl_producto prod
              WHERE prod.id_producto::text = fac.id_unidad::text)
        END::text AS documento,
    to_char(fac.fecha_venta,'dd/MM/yyyy') AS fec_credito,   
    to_char(ven.fec_vencimiento::date::timestamp with time zone, 'dd/MM/yyyy'::text) AS fecha_vencimiento,
    COALESCE(z.imp_credito, 0::numeric) AS credito,
    COALESCE(nc.imp_nc,0.00) as imp_nc,
    COALESCE(pcr.imp_pago, 0::numeric) AS pagos,
    ((COALESCE(z.imp_credito, 0::numeric)-COALESCE(nc.imp_nc,0.00) -COALESCE(pcr.imp_pago, 0::numeric)))::numeric(20,2) as saldo,
    fac.imp_neto + COALESCE(( SELECT sum(c.imp_interes) AS sum
           FROM creditos.tbl_cuota c
          WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito), 0.00) AS total_venta,
    tbl_tipoventa.descripcion_larga::text AS tipo_venta,
    tbl_moneda.simbolo AS moneda,
    fac.id_facturacion,
    fac.id_sucursal,
    fac.id_cliente,
    fac.id_direccion,
    cred.id_credito,
    cred.id_sucursal_credito,
    tbl_comprobante.descripcion_corta AS comprobante,
    fac.serie_facturacion,
    fac.numdoc_facturacion,    
    suc.id_empresa,
    r.id_sector,
    r.id_zona,
    fac.id_vendedor,
    vend.nombre_razon as vendedor,
    now()::Date-fac.fecha_venta::date as dias,
    COALESCE((select replace(replace(t.telefono::text,'{"telefono":"',''),'"}','') from (
	select 
		(
	      select array_to_json(array_agg(row_to_json(d)))
	      from (
		select  telefono		 
		from COMMON.tbl_telefono  tl
		where cli.id_persona=tl.id_persona
	      ) d
	    ) as telefono
	) t),'') as tlf_cliente,
     COALESCE(to_char(pagf.fecha_mov,'dd/MM/yyyy'),'') as ultimo_pago,
    trim(dist.distrito) ||'-'|| trim(prov.provincia) as ubigeo,
    '' as garante,
    zon.id_distrito,
    emp.ruc as ruc_empresa,
    emp.nombre as empresa,
    suc.direccion as dir_sucursal
   FROM ventas.tbl_facturacion fac
     JOIN creditos.tbl_ventacredito vc ON fac.id_sucursal = vc.id_sucursal AND vc.id_facturacion = fac.id_facturacion AND fac.id_tipoventa = 2 AND vc.id_estado = 1
     JOIN creditos.tbl_credito cred ON cred.id_credito = vc.id_credito AND cred.id_sucursal_credito = vc.id_sucursal_credito
     JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
     JOIN common.tbl_moneda ON fac.id_moneda = tbl_moneda.id_moneda
     JOIN ventas.tbl_direccion dir ON dir.id_persona::text = fac.id_cliente::text AND dir.id_direccion = fac.id_direccion
     INNER JOIN ventas.tbl_sector r on r.id_sector=dir.id_sector
     INNER JOIN ventas.tbl_zona zon ON zon.id_zona=r.id_zona
     INNER JOIN common.tbl_distrito dist on dist.id_distrito=zon.id_distrito
     INNER JOIN common.tbl_provincia prov on prov.id_provincia=dist.id_provincia
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = dir.id_persona::text
     JOIN common.tbl_tipoventa ON tbl_tipoventa.id_tipoventa = fac.id_tipoventa
     JOIN common.tbl_sucursal suc ON suc.id_sucursal = fac.id_sucursal
     JOIN common.tbl_empresa emp on emp.id_empresa=suc.id_empresa
     JOIN planillas.tbl_persona vend on vend.id_persona=fac.id_vendedor
     INNER JOIN ( SELECT tbl_cuota.id_credito,
            tbl_cuota.id_sucursal_credito,
            max(tbl_cuota.fec_vencimiento::date) AS fec_vencimiento
           FROM creditos.tbl_cuota
          GROUP BY tbl_cuota.id_credito, tbl_cuota.id_sucursal_credito
     ) ven ON ven.id_credito = cred.id_credito AND ven.id_sucursal_credito = cred.id_sucursal_credito
     INNER JOIN (
		SELECT c.id_credito,c.id_sucursal_credito as id_sucursal, sum(c.imp_cuota) AS imp_credito
		FROM creditos.tbl_cuota c       
		group by c.id_credito,c.id_sucursal_credito 
	) Z on z.id_credito=cred.id_credito and z.id_sucursal=cred.id_sucursal_credito
    LEFT JOIN ( 
	SELECT ccc.id_credito,
            ccc.id_sucursal_credito,       
            sum(dpc.imp_pago) AS imp_pago
           FROM creditos.tbl_cuota ccc
             JOIN creditos.tbl_detpagocuota dpc ON ccc.id_cuotas = dpc.id_cuotas AND ccc.id_credito = dpc.id_credito AND ccc.id_sucursal_credito = dpc.id_sucursal_credito
             JOIN caja.tbl_movcaja mov ON mov.id_movimcaja = dpc.id_movimcaja AND mov.id_sucursal = dpc.id_sucursal
          WHERE ccc.nro_cuota <> 0 AND mov.id_estado = 1 and mov.fecha_mov::date<=f2::date
          GROUP BY ccc.id_credito, ccc.id_sucursal_credito
	) pcr ON pcr.id_credito = cred.id_credito AND pcr.id_sucursal_credito = cred.id_sucursal_credito
   LEFT JOIN (
	select sum(COALESCE(NC.imp_dscto,0)) as imp_nc,nc.id_credito,nc.id_sucursal_cred as id_sucursal  from creditos.tbl_cuota_notacredito NC 
	where nc.id_estado=1
	group by nc.id_credito,nc.id_sucursal_cred
	) nc ON nc.id_credito = cred.id_credito AND nc.id_sucursal = cred.id_sucursal_credito
LEFT JOIN  (SELECT max(mc.fecha_mov) as fecha_mov,dp.id_credito,dp.id_sucursal_credito
           FROM creditos.tbl_detpagocuota dp
             JOIN caja.tbl_movcaja mc ON mc.id_movimcaja = dp.id_movimcaja AND mc.id_sucursal = dp.id_sucursal 
	     where mc.id_estado=1 and dp.id_estado=1 and mc.fecha_mov::Date<=f2::date
	     group by dp.id_credito,dp.id_sucursal_credito
         -- ORDER BY mc.fecha_mov DESC
         ) pagf on pagf.id_credito = cred.id_credito AND pagf.id_sucursal_credito = cred.id_sucursal_credito 
  WHERE fac.id_estado = 1 and fac.nota_credito=false and fac.fecha_venta::date>=f1::date and fac.fecha_venta::date<=f2::date;
end;$$
language 'plpgsql';




create or replace function creditos.fn_letras_x_cobrar_fechas_detallado(f1 text,f2 text)
returns table(
	dni varchar(12),
	cliente varchar(500),
	direccion text,
	zona varchar(200),
	sector varchar(200),
	documento text,
	fec_credito text,
	fec_vencimiento text,
	credito numeric(20,4),
	imp_nc numeric(20,4),
	pagos numeric(20,4),
	saldo numeric(20,4),
	total_venta numeric(20,4),
	tipo_venta text,
	moneda varchar(5),
	id_facturacion integer,
	id_sucursal integer,
	id_cliente varchar(15),
	id_direccion bigint,
	id_credito integer,
	id_sucursal_credito integer,
	comprobante char(3),
	serie_facturacion char(4),
	numdoc_facturacion char(7),
	id_empresa integer,
	id_sector integer,
	id_zona integer,
	id_vendedor varchar(15),
	vendedor varchar(500),
	dias integer,
	tlf_cliente text,
	ultimo_pago text,
	ubigeo text,
	garante text,
	id_distrito varchar(8),
	ruc_empresa char(12),
	empresa varchar(200),
	dir_sucursal varchar(100)
)
as $$
declare
begin

 return query SELECT
  cli.doc_persona AS dni,
  cli.nombre_razon AS cliente,
  dir.direccion,
  zon.zona,
  r.sector,
        CASE
            WHEN fac.id_unidad IS NULL THEN ((((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie_facturacion::text) || '-'::text) || fac.numdoc_facturacion::text)::character varying
            ELSE ( SELECT prod.descripcion_larga
               FROM almacen.tbl_producto prod
              WHERE prod.id_producto::text = fac.id_unidad::text)
        END::text AS documento,
    to_char(fac.fecha_venta,'dd/MM/yyyy') AS fec_credito,   
    to_char(ven.fec_vencimiento::date::timestamp with time zone, 'dd/MM/yyyy'::text) AS fecha_vencimiento,
    COALESCE(z.imp_credito, 0::numeric) AS credito,
    COALESCE(nc.imp_nc,0.00) as imp_nc,
    COALESCE(pcr.imp_pago, 0::numeric) AS pagos,
    ((COALESCE(z.imp_credito, 0::numeric)-COALESCE(nc.imp_nc,0.00) -COALESCE(pcr.imp_pago, 0::numeric)))::numeric(20,2) as saldo,
    fac.imp_neto + COALESCE(( SELECT sum(c.imp_interes) AS sum
           FROM creditos.tbl_cuota c
          WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito), 0.00) AS total_venta,
    tbl_tipoventa.descripcion_larga::text AS tipo_venta,
    tbl_moneda.simbolo AS moneda,
    fac.id_facturacion,
    fac.id_sucursal,
    fac.id_cliente,
    fac.id_direccion,
    cred.id_credito,
    cred.id_sucursal_credito,
    tbl_comprobante.descripcion_corta AS comprobante,
    fac.serie_facturacion,
    fac.numdoc_facturacion,    
    suc.id_empresa,
    r.id_sector,
    r.id_zona,
    fac.id_vendedor,
    vend.nombre_razon as vendedor,
    now()::Date-fac.fecha_venta::date as dias,
    COALESCE((select replace(replace(t.telefono::text,'{"telefono":"',''),'"}','') from (
	select 
		(
	      select array_to_json(array_agg(row_to_json(d)))
	      from (
		select  telefono		 
		from COMMON.tbl_telefono  tl
		where cli.id_persona=tl.id_persona
	      ) d
	    ) as telefono
	) t),'') as tlf_cliente,
     COALESCE(to_char(pagf.fecha_mov,'dd/MM/yyyy'),'') as ultimo_pago,
    trim(dist.distrito) ||'-'|| trim(prov.provincia) as ubigeo,
    '' as garante,
    zon.id_distrito,
    emp.ruc as ruc_empresa,
    emp.nombre as empresa,
    suc.direccion as dir_sucursal
   FROM ventas.tbl_facturacion fac
     JOIN creditos.tbl_ventacredito vc ON fac.id_sucursal = vc.id_sucursal AND vc.id_facturacion = fac.id_facturacion AND fac.id_tipoventa = 2 AND vc.id_estado = 1
     JOIN creditos.tbl_credito cred ON cred.id_credito = vc.id_credito AND cred.id_sucursal_credito = vc.id_sucursal_credito
     JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
     JOIN common.tbl_moneda ON fac.id_moneda = tbl_moneda.id_moneda
     JOIN ventas.tbl_direccion dir ON dir.id_persona::text = fac.id_cliente::text AND dir.id_direccion = fac.id_direccion
     INNER JOIN ventas.tbl_sector r on r.id_sector=dir.id_sector
     INNER JOIN ventas.tbl_zona zon ON zon.id_zona=r.id_zona
     INNER JOIN common.tbl_distrito dist on dist.id_distrito=zon.id_distrito
     INNER JOIN common.tbl_provincia prov on prov.id_provincia=dist.id_provincia
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = dir.id_persona::text
     JOIN common.tbl_tipoventa ON tbl_tipoventa.id_tipoventa = fac.id_tipoventa
     JOIN common.tbl_sucursal suc ON suc.id_sucursal = fac.id_sucursal
     JOIN common.tbl_empresa emp on emp.id_empresa=suc.id_empresa
     JOIN planillas.tbl_persona vend on vend.id_persona=fac.id_vendedor
     inner join creditos.tbl
     INNER JOIN ( SELECT tbl_cuota.id_credito,
            tbl_cuota.id_sucursal_credito,
            max(tbl_cuota.fec_vencimiento::date) AS fec_vencimiento
           FROM creditos.tbl_cuota
          GROUP BY tbl_cuota.id_credito, tbl_cuota.id_sucursal_credito
     ) ven ON ven.id_credito = cred.id_credito AND ven.id_sucursal_credito = cred.id_sucursal_credito
     INNER JOIN (
		SELECT c.id_credito,c.id_sucursal_credito as id_sucursal, sum(c.imp_cuota) AS imp_credito
		FROM creditos.tbl_cuota c       
		group by c.id_credito,c.id_sucursal_credito 
	) Z on z.id_credito=cred.id_credito and z.id_sucursal=cred.id_sucursal_credito
    LEFT JOIN ( 
	SELECT ccc.id_credito,
            ccc.id_sucursal_credito,       
            sum(dpc.imp_pago) AS imp_pago
           FROM creditos.tbl_cuota ccc
             JOIN creditos.tbl_detpagocuota dpc ON ccc.id_cuotas = dpc.id_cuotas AND ccc.id_credito = dpc.id_credito AND ccc.id_sucursal_credito = dpc.id_sucursal_credito
             JOIN caja.tbl_movcaja mov ON mov.id_movimcaja = dpc.id_movimcaja AND mov.id_sucursal = dpc.id_sucursal
          WHERE ccc.nro_cuota <> 0 AND mov.id_estado = 1 and mov.fecha_mov::date<=f2::date
          GROUP BY ccc.id_credito, ccc.id_sucursal_credito
	) pcr ON pcr.id_credito = cred.id_credito AND pcr.id_sucursal_credito = cred.id_sucursal_credito
   LEFT JOIN (
	select sum(COALESCE(NC.imp_dscto,0)) as imp_nc,nc.id_credito,nc.id_sucursal_cred as id_sucursal  from creditos.tbl_cuota_notacredito NC 
	where nc.id_estado=1
	group by nc.id_credito,nc.id_sucursal_cred
	) nc ON nc.id_credito = cred.id_credito AND nc.id_sucursal = cred.id_sucursal_credito
LEFT JOIN  (SELECT max(mc.fecha_mov) as fecha_mov,dp.id_credito,dp.id_sucursal_credito
           FROM creditos.tbl_detpagocuota dp
             JOIN caja.tbl_movcaja mc ON mc.id_movimcaja = dp.id_movimcaja AND mc.id_sucursal = dp.id_sucursal 
	     where mc.id_estado=1 and dp.id_estado=1 and mc.fecha_mov::Date<=f2::date
	     group by dp.id_credito,dp.id_sucursal_credito
         -- ORDER BY mc.fecha_mov DESC
         ) pagf on pagf.id_credito = cred.id_credito AND pagf.id_sucursal_credito = cred.id_sucursal_credito 
  WHERE fac.id_estado = 1 and fac.nota_credito=false and fac.fecha_venta::date>=f1::date and fac.fecha_venta::date<=f2::date;
end;$$
language 'plpgsql';



select * from creditos.fn_letras_x_cobrar_fechas('01/09/2017','22/09/2020')where id_empresa=1   and cliente ilike '%silva sa%'

select *from  creditos.tbl_cuota_notacredito 

select *from caja.tbl_movcaja

CREATE OR REPLACE FUNCTION ventas.isp_grabarCheckIn(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,--23
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,--30
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono  varchar(50),--39
    _orden_compra text,
    _fecha_ingreso text,
    _hora_ingreso text,
    _fecha_salida text,
    _hora_salida text,
    _id_habitacion integer
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		if (_id_cliente='000'  and _imp_total>750 )  then
			res:=array['506','Es obligatorio ingresar datos completos del cliente(DNI,Nombres y apellidos,direccion) a partir de 750.00  soles'];
			return res;
		end if;
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI,
			    orden_compra
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    _numero, 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono,
			    _orden_compra
			    			    
		) RETURNING ARRAY['0',id_cotizapreventa::TEXT,id_sucursal::TEXT] INTO RES;
		IF NOT FOUND THEN
			RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    serie=_serie, 
				    numero=_numero, 
				    id_comprobante=_id_comprobante, 
				    fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono,
				    orden_compra=_orden_compra
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
	END IF;
END IF;


return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;




CREATE OR REPLACE FUNCTION ventas.fn_verificacion_comprobantes_sunat(
_id_facturacion integer,
_id_sucursal integer,
_estado_comprobante text ,
_estado_contribuyente text,
_condicion_contribuyente text,
_observaciones_sunat text
)
returns text[] as $$
declare
begin
update ventas.tbl_facturacion 
	set 
		estado_comprobante =_estado_comprobante ,
		estado_contribuyente=_estado_contribuyente,
		condicion_contribuyente=_condicion_contribuyente,
		observaciones_sunat=_observaciones_sunat
	where id_facturacion=_id_facturacion
	and id_sucursal=_id_sucursal;
return array['0','Comprobante verificado'];
end;$$
language 'plpgsql';

select *from creditos.fn_estado_cuenta_proveedor('01/01/2019','31/12/2020');

CREATE OR REPLACE FUNCTION creditos.fn_estado_cuenta_proveedor(
	f1 text,
	f2 text
)
returns table(
	letra varchar(15),
	documento text,
	fec_credito timestamp,
	dias integer,
	moneda varchar(5),
	_proveedor varchar(100),
	fec_vencimiento timestamp,
	cargo numeric(14,6),
	abono numeric(14,6),
	saldo numeric(14,6),
	total_venta numeric(14,6),
	tipo_venta text,
	_id_compra integer,
	_id_sucursalcompra integer,
	_id_proveedor varchar(15),
	_id_dirproveedor bigint,
	_id_credito integer,
	_id_sucursal_credito integer,
	comprobante char(3),
	serie char(4),
	_nro_doc_compra char(7),
	_dni varchar(11),
	estado text,
	id_estado integer,
	banco text,
	nro_unico_pago varchar(100),
	fecha_protesto timestamp,
	importe numeric(14,6),
	fec_documento timestamp
) as $$
declare
begin
return query 
 SELECT cc.nro_letra AS letra,
    c.documento,
    cred.fec_emision AS fec_credito,
    cc.fec_vencimiento::date - cred.fec_emision::date AS dias,
    c.moneda::character varying(5) AS moneda,
    c.proveedor::character varying(100) AS _proveedor,
    cc.fec_vencimiento,
    cc.imp_cuota AS cargo,
    COALESCE(( SELECT sum(dp_1.imp_pago) AS sum
           FROM creditos.tbl_detpagocuota dp_1
	    inner join caja.tbl_movcaja mmvv on mmvv.id_movimcaja=dp_1.id_movimcaja and mmvv.id_sucursal=dp_1.id_sucursal
          WHERE dp_1.id_credito = cc.id_credito AND 
		dp_1.id_sucursal_credito = cc.id_sucursal_credito AND 
		dp_1.id_estado = 1 AND  mmvv.fecha_mov::date<=f2::date and
		cc.id_cuotas = dp_1.id_cuotas
		and mmvv.id_estado=1), 0::numeric) AS abono,
	cc.imp_cuota - COALESCE(( SELECT sum(cmov_1.imp_pago) AS sum
           FROM creditos.tbl_detpagocuota cmov_1
		inner join caja.tbl_movcaja mmvv on mmvv.id_movimcaja=cmov_1.id_movimcaja and mmvv.id_sucursal=cmov_1.id_sucursal --select *from caja.tbl_movcaja  select *from creditos.tbl_detpagocuota
          WHERE cred.id_credito = cmov_1.id_credito 
		AND cred.id_sucursal_credito = cmov_1.id_sucursal_credito 
		AND cmov_1.id_estado = 1 
		AND cc.id_cuotas = cmov_1.id_cuotas
		and mmvv.fecha_mov::date<=f2::date
		and mmvv.id_estado=1
		), 0::numeric) - COALESCE(( SELECT sum(nc_1.imp_dscto) AS sum
		FROM creditos.tbl_cuota_notacredito nc_1
		WHERE   cred.id_credito = nc_1.id_credito 
			AND cred.id_sucursal_credito = nc_1.id_sucursal_cred
		), 0::numeric) AS saldo,
		(c.imp_total + COALESCE(( SELECT sum(c_1.imp_interes) AS sum
           FROM creditos.tbl_cuota c_1
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0.00))::numeric(14,6) AS total_venta,
    c.tipo_venta,
    0 AS _id_compra,
    1 AS _id_sucursalcompra,
    c.id_proveedor::character varying(15) AS _id_proveedor,
    0::bigint AS _id_dirproveedor,
    cred.id_credito AS _id_credito,
    cred.id_sucursal_credito AS _id_sucursal_credito,
    c.comprobante,
    ''::character(4) AS serie,
    ''::character(7) AS _nro_doc_compra,
    c.doc_persona::varchar(11) AS _dni,
    e.des_estado::text AS estado,
    cred.id_estado,
    COALESCE(cb.descripcion, ''::text)::text AS banco,
    cc.nro_unico_pago,
    cc.fecha_protesto,
    COALESCE(( SELECT sum(nc_1.imp_dscto) AS sum
           FROM creditos.tbl_cuota_notacredito nc_1
          WHERE cred.id_credito = nc_1.id_credito AND cred.id_sucursal_credito = nc_1.id_sucursal_cred), 0::numeric) AS importe_nc,
  c.fec_documento
   FROM creditos.tbl_credito cred
     JOIN creditos.tbl_cuota cc ON cc.id_credito = cred.id_credito AND cc.id_sucursal_credito = cred.id_sucursal_credito
     LEFT JOIN planillas.tbl_nrocuenta nc ON nc.id_nrocuenta = cred.id_nrocuenta
     LEFT JOIN caja.tbl_cajabanco cb ON cb.id_cajabanco = nc.id_banco
     LEFT JOIN common.tbl_estado e ON e.id_estado = cred.id_estado
     JOIN LATERAL creditos.list_agrupadocscompras(cred.id_credito, cred.id_sucursal_credito) c(documento, id_credito, id_sucursal, moneda, tipo_venta, proveedor, imp_total, doc_persona, comprobante, id_proveedor, id_moneda,fec_documento) ON cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal
  WHERE cred.id_estado = 1 and c.fec_documento::date>=f1::date and c.fec_documento::date<=f2::date
  ORDER BY (c.id_proveedor::bigint), cc.id_cuotas;

end;$$
language 'plpgsql';

 


CREATE OR REPLACE FUNCTION creditos.list_agrupadocscompras(
    IN __id_credito integer,
    IN __id_sucursal integer
)
  RETURNS TABLE(
	documento text, 
	id_credito integer, 
	id_sucursal integer, 
	moneda text, 
	tipo_venta text, 
	proveedor text, 
	imp_total numeric, 
	doc_persona text, 
	comprobante character, 
	id_proveedor text, 
	id_moneda integer,
	fec_documento timestamp
) AS
$BODY$
declare
	dat record;
	rec_docs record;
	docs text;
	_proveedor text;
	_id_credito integer;
	_id_sucursal integer;
	_moneda text;
	_doc_persona text;
	_tipo_venta text;
	_imp_total numeric(20,4);
	_comprobante char(3);
	numbers_regs integer;
	rows integer;
	documents text;
begin
	/*CREATE TEMPORARY TABLE  imp_documentos (
			_documento text,
			_nombre_razon text,
			_id_credito integer,
			_id_sucursal integer,
			_moneda text,
			_tipo_venta text,
			_proveedor text,
			_imp_total numeric(20,4),
			_doc_persona  text,
			_comprobante char(3)
			
		)ON COMMIT DROP;*/
		rows:=0;
		for rec_docs in select 
			(((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie::text) || '-'::text) || fac.nro_doc_compra::text AS documento
					
			FROM compras.tbl_compra fac
				inner  JOIN creditos.tbl_creditoscompra vc ON fac.id_sucursalcompra=vc.id_sucursalcompra and  fac.id__compra=vc.id__compra 
				inner JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
				where vc.id_credito=__id_credito and vc.id_sucursal_credito=__id_sucursal
				
			loop
				
					documents:=COALESCE(documents ,'') || COALESCE(rec_docs.documento,'') || ', ' ;		
			rows:=rows+1;
		end loop;
		docs:= substring(trim(documents) from 1 for (length(trim(documents))-1));
		return query 
		select 
			docs::text documento,			
			vc.id_credito	,
			vc.id_sucursal_credito,	
			m.simbolo::text AS moneda,		
			tv.descripcion_larga::text as tipo_venta,	
			cli.nombre_razon::text as proveedor,	
			sum(fac.imp_total) as imp_total,		
			cli.doc_persona::text as doc_persona	,			
			tbl_comprobante.descripcion_corta::char(3) AS comprobante,
			cli.id_persona::text as id_proveedor,
			fac.id_moneda,
			fac.fec_documento --select *from compras.tbl_compra
			FROM compras.tbl_compra fac
				inner  JOIN creditos.tbl_creditoscompra vc ON fac.id_sucursalcompra=vc.id_sucursalcompra and  fac.id__compra=vc.id__compra and vc.id_estado=1
				JOIN planillas.tbl_persona cli ON cli.id_persona::text = fac.id_proveedor::text
				inner JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
				JOIN common.tbl_moneda m ON fac.id_moneda = m.id_moneda
				JOIN common.tbl_tipoventa tv ON tv.id_tipoventa = fac.id_tipocompra 
				where vc.id_credito=__id_credito and vc.id_sucursal_credito=__id_sucursal
				group by vc.id_sucursal_credito,vc.id_credito,	
					m.simbolo,		
					tv.descripcion_larga,	
					cli.nombre_razon,							
					cli.doc_persona	,			
					tbl_comprobante.descripcion_corta,cli.id_persona,fac.id_moneda,fac.fec_documento
				;
		
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE VIEW creditos.v_estado_cuenta_proveedor 
AS 
 SELECT cc.nro_letra AS letra,
    c.documento,
    cred.fec_emision AS fec_credito,
    cc.fec_vencimiento::date - cred.fec_emision::date AS dias,
    c.moneda::character varying(5) AS moneda,
    c.proveedor::character varying(100) AS _proveedor,
    cc.fec_vencimiento,
    cc.imp_cuota AS cargo,
    COALESCE(( SELECT sum(dp_1.imp_pago) AS sum
           FROM creditos.tbl_detpagocuota dp_1
          WHERE dp_1.id_credito = cc.id_credito AND dp_1.id_sucursal_credito = cc.id_sucursal_credito AND dp_1.id_estado = 1 AND cc.id_cuotas = dp_1.id_cuotas), 0::numeric) AS abono,
    cc.imp_cuota - COALESCE(( SELECT sum(cmov_1.imp_pago) AS sum
           FROM creditos.tbl_detpagocuota cmov_1
          WHERE cred.id_credito = cmov_1.id_credito AND cred.id_sucursal_credito = cmov_1.id_sucursal_credito AND cmov_1.id_estado = 1 AND cc.id_cuotas = cmov_1.id_cuotas), 0::numeric) 
	- COALESCE(( SELECT sum(nc_1.imp_dscto) AS sum
           FROM creditos.tbl_cuota_notacredito nc_1
          WHERE cred.id_credito = nc_1.id_credito AND cred.id_sucursal_credito = nc_1.id_sucursal_cred), 0::numeric) AS saldo,
    c.imp_total + COALESCE(( SELECT sum(c_1.imp_interes) AS sum
           FROM creditos.tbl_cuota c_1
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0.00) AS total_venta,
    c.tipo_venta,
    0 AS _id_compra,
    1 AS _id_sucursalcompra,
    c.id_proveedor::character varying(15) AS _id_proveedor,
    0::bigint AS _id_dirproveedor,
    cred.id_credito AS _id_credito,
    cred.id_sucursal_credito AS _id_sucursal_credito,
    c.comprobante,
    ''::character(4) AS serie,
    ''::character(7) AS _nro_doc_compra,
    c.doc_persona::character(11) AS _dni,
    e.des_estado::text AS estado,
    cred.id_estado,
    COALESCE(cb.descripcion, ''::character varying) AS banco,
    cc.nro_unico_pago,
    cc.fecha_protesto,
    COALESCE(( SELECT sum(nc_1.imp_dscto) AS sum
           FROM creditos.tbl_cuota_notacredito nc_1
          WHERE cred.id_credito = nc_1.id_credito AND cred.id_sucursal_credito = nc_1.id_sucursal_cred), 0::numeric) AS importe_nc
   FROM creditos.tbl_credito cred
     JOIN creditos.tbl_cuota cc ON cc.id_credito = cred.id_credito AND cc.id_sucursal_credito = cred.id_sucursal_credito
     LEFT JOIN planillas.tbl_nrocuenta nc ON nc.id_nrocuenta = cred.id_nrocuenta
     LEFT JOIN caja.tbl_cajabanco cb ON cb.id_cajabanco = nc.id_banco
     LEFT JOIN common.tbl_estado e ON e.id_estado = cred.id_estado
     JOIN LATERAL creditos.list_agrupadocscompras(cred.id_credito, cred.id_sucursal_credito) c(documento, id_credito, id_sucursal, moneda, tipo_venta, proveedor, imp_total, doc_persona, comprobante, id_proveedor, id_moneda) 
ON cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal
  WHERE cred.id_estado = 1
  ORDER BY (c.id_proveedor::bigint), cc.id_cuotas;



CREATE TRIGGER trig_gencod_corel_comprobante_pesaje
  BEFORE INSERT
  ON ventas.tbl_pesaje
  FOR EACH ROW
  EXECUTE PROCEDURE ventas.func_correlativo_comprobantes_pesaje();



CREATE OR REPLACE FUNCTION ventas.func_correlativo_comprobantes_pesaje()
  RETURNS trigger AS
$BODY$
DECLARE
	CORRELATIVO NUMERIC(20,0);
	MUMERO_CORREL TEXT;
BEGIN
	IF exists(select *from COMMON.TBL_CONFIGSERIE where  
								id_comprobante=new.id_comprobante and 
								serie=new.serie and id_estado=1 and id_sucursal=new.sucursal_id ) then
		
			select  max(numero::NUMERIC) into CORRELATIVO from  COMMON.TBL_CONFIGSERIE where  
									 
									id_comprobante=NEW.id_comprobante and 
									serie=NEW.serie and id_estado=1 and id_sucursal=new.sucursal_id;
			if CORRELATIVO IS NULL THEN
				MUMERO_CORREL='1';
			ELSE
				MUMERO_CORREL=(CORRELATIVO+1)::TEXT;
			END IF;
			UPDATE COMMON.TBL_CONFIGSERIE SET NUMERO =MUMERO_CORREL::integer WHERE   
								 
								id_comprobante=NEW.id_comprobante and 
								serie=NEW.serie  and id_estado=1 and id_sucursal=new.sucursal_id;
		
	ELSE
		RAISE NOTICE 'new.sucursal_id %', new.sucursal_id;
		RAISE EXCEPTION 'NO SE HA GENERADO EL CORRELATIVO OPERACION BLOQUEDA' ;
	end if;
RETURN NEW;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

delete  from ventas.tbl_pesaje 
select*  from ventas.tbl_pesaje 
alter table ventas.tbl_pesaje  add column status_id integer default 1

select * from ventas.spi_pesaje(1,0,1,44,'-','0000001','22',194,'','','','','25'::numeric,'4'::numeric,'21.0'::numeric,'')

CREATE OR REPLACE FUNCTION ventas.spi_pesaje(
	_op integer,
	_pesaje_id bigint ,
	_sucursal_id integer,
	_id_comprobante integer,
	_serie varchar(5),
	_numero varchar(10),
	_id_cliente varchar(15),
	_id_direccion bigint,
	_placa varchar(30),
	_marca varchar(30),
	_color varchar(50),
	_modelo varchar(50),
	_peso_bruto numeric(20,4),
	_peso_tara numeric(20,4),
	_peso_neto numeric(20,4),
	_observaciones text
)
returns text[] as $$
declare
	res text[];
begin
if _op then
	if not exists(select * from ventas.tbl_pesaje where serie=_serie and numero=_numero) then
		INSERT INTO ventas.tbl_pesaje(
			sucursal_id, 
			id_comprobante, 
			serie, 
			numero, 
			id_cliente, 
			id_direccion, 
			placa, 
			marca, 
			color, 
			modelo, 
			peso_bruto, 
			peso_tara, 
			peso_neto, 
			observaciones)
		VALUES ( 
			_sucursal_id, 
			_id_comprobante, 
			_serie, 
			_numero, 
			_id_cliente, 
			_id_direccion, 
			_placa, 
			_marca, 
			_color, 
			_modelo, 
			_peso_bruto, 
			_peso_tara, 
			_peso_neto, 
			_observaciones
		) returning array['0','Registro generado'] into res;
		if not found then
			res:=array['501','Inconsistencia inesperada intentelo nuevamente'];
		end if;
	else
		res:=array['503','Ya existe un regisstro con el mismo número'];
	end if;
end if;
if _op=2 then
	if exists(select 1 from ventas.tbl_pesaje where pesaje_id=_pesaje_id) then
		if exists(select 1 from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
			UPDATE ventas.tbl_pesaje
			   SET id_comprobante=_id_comprobante, 
				serie=_serie, 
				numero=_numero, 
				id_cliente=_id_cliente, 
				id_direccion=_id_direccion, 
				placa=_placa, 
				marca=_marca, 
				color=_color,
				modelo=_modelo, 
				peso_bruto=_peso_bruto, 
				peso_tara=_peso_tara, 
				peso_neto=_peso_neto, 
				observaciones=_observaciones
			 WHERE pesaje_id=_pesaje_id;
			res:=array['0','Registro actualizado'];
		else
			res:=array['501','Seleccione correctamente el cliente'];
		end if;
	else
		res:=array['502','Seleccione correctamente el registro que desea modificar'];
	end if;
end if;
return res;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION public.registra_ctrlcierre_grifo(
    _id_turno integer,
    _id_sucursal integer,
    anno integer DEFAULT 0)
  RETURNS text AS
$BODY$
Declare 
	NroDia Integer;
	cFecLiq Char(8); 
	FecLiq timestamp; 
	FecReg  Char(20);
	--
begin
NroDia:= 0;
IF Anno=0 then
    Anno= date_part('year',now());
end if;
  RAISE NOTICE 'row = %', NroDia;
While NroDia <= 364 loop

      FecLiq = Cast('01/01/' || Cast(Anno As Char(4))  As DATE) +  CAST( NroDia || ' DAY' AS INTERVAL) ;	----Case When @NroDia=1 Then 0 Else @NroDia End
	--cFecLiq= Cast(Year(FecLiq) As Char(4)) + Right('0'+Rtrim(Cast(Month(FecLiq) As Char(2))),2) + Right('0'+Rtrim(Cast(Day(FecLiq) As Char(2))),2);

      cFecLiq= Cast(date_part('year',FecLiq) As Char(4)) ||  Right('0' || Rtrim(Cast(date_part('Month',FecLiq) As Char(2))),2) || Right('0' || Rtrim(Cast( date_part('Day',FecLiq) As Char(2))),2);
      --FecReg = Convert(Char(10), FecLiq, 103);
      FecReg = cast(FecLiq as timestamp);

   --Registro del control de cierre para los MESES DEL AÑO 
      Insert Into GRIFO.TBL_CTRLCIERRE_GRIFO (id_sucursal,id_turno,cfecliqudacion,FecLiquidacion)
	   Select id_sucursal,id_turno,CAST(cFecLiq AS DATE),cast(FecReg as timestamp) From COMMON.TBL_SUCURSAL_TURNO G Where id_sucursal= _id_sucursal  And id_turno= _id_turno And 
			Not Exists (Select id_turno From GRIFO.TBL_CTRLCIERRE_GRIFO Where id_sucursal= G.id_sucursal And id_turno= G.id_turno And cfecliqudacion=cast(cFecLiq as date));

  RAISE NOTICE 'row = %', cFecLiq;

    NroDia = NroDia+ 1;
   end loop;
   RETURN 'OKS';
  end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;




select *from ventas.order_list(1,'01/01/2021','31/12/2021');
CREATE OR REPLACE FUNCTION ventas.order_list(
	_vendedor bigint,
	_f1 text,
	_f2 text
)
    RETURNS TABLE(order_id bigint, branch_office_id integer, order_date text, serie_order character, number_order character, customer_ducument character varying, customer character varying, sale_amount numeric, tax_amount numeric, total numeric, customer_id character varying, address_id bigint, sale_type_id integer, gloss text, sale_type character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
declare
begin
return query select	
	id_cotizapreventa as order_Id,
	id_sucursal,
	to_char(fecha,'dd/MM/yyyy hh:mm:ss') as order_date,
	serie as serie_order,
	numero as number_order,
	p.doc_persona as customer_document,
	p.nombre_razon as customer,
	valor_venta as sale_amount,
	imp_igv as tax_amount,
	imp_total as total,
	id_cliente as customer_id,
	id_direccion as address_id,
	o.id_tipoventa as sale_type_id,
	glosa  as gloss ,
	tv.descripcion_larga as type_sale
from ventas.tbl_cotizacionpreventa o
inner join planillas.tbl_persona p on p.id_persona=o.id_cliente
inner join common.tbl_tipoventa tv on tv.id_tipoventa=o.id_tipoventa
where o.fecha::date>=_f1::date and o.fecha::date<=_f2::date
order by  o.fecha::date asc,serie,numero;
--limit 100;
end;
$BODY$;

select *from planillas.tbl_persona

select *from ventas.tbl_cotizacionpreventa o


CREATE OR REPLACE FUNCTION planillas.fn_batch_apertura_turno()
  RETURNS text AS
$BODY$
declare
	dat record;
	res text[];
begin
	 for dat in select generate_series(
           (date '2021-01-01')::timestamp,
           (date '2021-12-31')::timestamp,
           interval '1 day'
         ) as _fecha loop
         res:=(select planillas.isp_gestion_turno(1,1,1,dat._fecha::text,'1',1,'1','AUTOMATICO',false,false,1,0));
        end loop;
        return '';
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select planillas.fn_batch_apertura_turno()
  



CREATE OR REPLACE FUNCTION planillas.fn_batch_resumen()
  RETURNS text AS
$BODY$
declare
	dat record;
	res text[];
begin
	 for dat in select generate_series(
           (date '2020-11-01')::timestamp,
           (date '2021-02-03')::timestamp,
           interval '1 day'
         ) as _fecha loop
         res:=(select planillas.spi_resumen('',_fecha::text,_fecha::text));
        end loop;
        return '';
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION planillas.fn_batch()
  OWNER TO postgres;


CREATE OR replace function caja.spi_apertura_turno_automatico(_id_usuario char(5),_id_colaborador varchar(15))
returns text as $$
declare
	rec record;
	res text[];
begin

for rec in select i::date from generate_series('2017-06-01', 
  '2017-07-31', '1 day'::interval) i loop
	res:=(select *from planillas.isp_gestion_turno( 
	    1,-- op integer,
	    1,--_id_turno integer,
	    1,--_item integer,
	    rec.i::text,--_fecha text,
	    _id_usuario,--_id_usuarior character,
	    1,--_id_estado integer,
	    _id_colaborador,--_id_colaborador character varying,
	    'Automativo',--_observacion text,
	    true,--_asistio boolean,
	    false,--_turno_cerrado boolean,
	    1,--_id_sucursal integer,
	    1,--_id_isla integer
	));
end loop;
returns '';
end;$$
language 'plpgsql';

select i::date from generate_series('2017-06-01', 
  '2017-07-31', '1 day'::interval) i


CREATE OR REPLACE FUNCTION seguridad.authorizeuser(
    _camp1 character varying,
    _camp2 character varying)
  RETURNS text AS
$BODY$
DECLARE
cadena text;
codigo character(10);
_id_persona text;
_user_data text;
BEGIN   
    codigo=NULL;
    
    SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2);

if exists(select 1   FROM seguridad.tbl_usuario where camp2=lower(_camp2)) then
	if exists(select 1 from   seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1) then
		--to_json(); 
		_user_data:=(
			
select row_to_json(t)
from (
  select 
	trim(id_usuario) as id, 
	camp2 as user,
	uss.id_persona as person_id,
	COALESCE(uper.apell_paterno,'') || ' ' || COALESCE(uper.apell_materno,'') || ' ' || COALESCE(uper.nombres,'') as colaborador,
	uss.lista_precio as list_price,
	uss.serie_pedido as serie_order,
	uss.modifica_precio as modify_price,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select alm.id_almacen, alm.descalmacen as almacen
        from seguridad.tbl_usuarioalmacen ussal
        inner join almacen.tbl_almacen alm on alm.id_almacen=ussal.id_almacen
        where uss.id_usuario=ussal.id_usuario
        order by alm.id_almacen asc
      ) d
    ) as almacen,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select alm.id_almacen, alm.descalmacen as almacen
        from seguridad.tbl_usuarioalmacen ussal
        inner join almacen.tbl_almacen alm on alm.id_almacen=ussal.id_almacen
        where uss.id_usuario=ussal.id_usuario and ussal.predeterminado=true
        order by alm.id_almacen asc
      ) d
    ) as almacendefault,
    (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        select distinct suc.id_sucursal, suc.nombre as sucursal
        from seguridad.tbl_usuariosucursal ussuc
        inner join common.tbl_sucursal suc on suc.id_sucursal=ussuc.id_sucursal
        where uss.id_usuario=ussuc.id_usuario
        order by suc.id_sucursal asc
      ) d
    ) as sucursal,
     (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        
       select id_persona as person_id,COALESCE(vend.apell_paterno,'') || ' ' || COALESCE(vend.apell_materno,'') || ' ' || COALESCE(vend.nombres,'') as vendedor 
       from planillas.tbl_persona vend 
       --inner join seguridad.tbl_usuario uss on uss.id_persona=uss.id_persona   --select * from seguridad.tbl_usuario
       where empleado is true and  vend.id_persona=uss.id_persona
      
       
      ) d
    ) as vendedores,
    (
	select to_json(t) from (select 0.00 as igv,700.00 as tope,1 as frontera,0 as tcam,0 as tcme) t
    ) as configuracion,
    (
	select to_json(t) from 
		(
			select suc.id_sucursal as codtie,suc.nombre as nomtie,ussuc.id_usuario  from seguridad.tbl_usuariosucursal ussuc
			inner join common.tbl_sucursal suc on suc.id_sucursal= ussuc.id_sucursal
			where ussuc.id_usuario=uss.id_usuario and ussuc.predeterminado=true
		) t
    ) as tienda
  from seguridad.tbl_usuario uss
  inner join planillas.tbl_persona as uper on uper.id_persona=uss.id_persona
  where id_usuario = '1'
) t
		);

		/*(select row_to_json(t)
		from (
		 select id_usuario,camp2 as user,camp1 as password,id_persona as persona_id from   seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1
		) t)::text;*/
		
		cadena:=to_json(message('success', replace(_user_data,'\\',''),'0',''))::text;  	
	else
		cadena:=to_json(message('error','Contraseña Incorrecta','502',''))::text;  
	end if;
else
	cadena:=to_json(message('error','Usuario Incorrecto','501',''))::text;  
end if;

RETURN cadena;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION audit.if_modified_func_existencias()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    v_old_data TEXT;
    v_new_data TEXT;
BEGIN
 
    IF (TG_OP = 'UPDATE') THEN    
		UPDATE almacen.tbl_existenciakardex set stock_inicial=new.stock_inicial,consto_inicial=new.consto_inicial
		where id_producto=new.id_producto and id_unidadventa=new.id_unidadventa and id_almacen=new.id_almacen;
        RETURN NULL;
    ELSIF (TG_OP = 'DELETE') THEN        
        RETURN NULL;
    ELSIF (TG_OP = 'INSERT') THEN        
       INSERT INTO almacen.tbl_existenciakardex(
				stock_fisico, 
				id_almacen, 
				id_producto, 
				id_unidadventa, 
				stock_reserva, 
				stocktransito, 
				id_lote, 
				id_inventario, 
				fec_inventario, 
				valor_incial, 
				stock_inicial, 
				ubicacion, 
				stock_reparto, 
				id_estado, 
				observaciones,
				UND_INVENTARIO,
				stockMin,
				StockMax,
				ctrlstock
			    )
			VALUES (
				NEW.stock_fisico, 
				NEW.id_almacen, 
				NEW.id_producto, 
				NEW.id_unidadventa, 
				NEW.stock_reserva, 
				NEW.stocktransito, 
				NEW.id_lote, 
				NEW.id_inventario, 
				NEW.fec_inventario, 
				NEW.valor_incial, 
				NEW.stock_inicial, 
				NEW.ubicacion, 
				NEW.stock_reparto, 
				NEW.id_estado, 
				NEW.observaciones,
				NEW.UND_INVENTARIO,
				NEW.stockMin,
				NEW.StockMax,
				NEW.ctrlstock
			 );
        RETURN NEW;
    ELSE
        RAISE WARNING '[AUDIT.if_modified_func_existencias] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;
 
EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[AUDIT.IF_MODIFIED_FUNC] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[AUDIT.IF_MODIFIED_FUNC] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[AUDIT.IF_MODIFIED_FUNC] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$BODY$;



CREATE TRIGGER t_if_modified_trg_existencias
    AFTER INSERT OR DELETE OR UPDATE 
    ON almacen.tbl_existencia
    FOR EACH ROW
    EXECUTE PROCEDURE audit.if_modified_func_existencias();


CREATE OR REPLACE FUNCTION id_generator() AS $$
DECLARE
    our_epoch bigint := 1314220021721;
    seq_id bigint;
    now_millis bigint;
    -- the id of this DB shard, must be set for each
    -- schema shard you have - you could pass this as a parameter too
    shard_id int := 1;
    result bigint;
BEGIN
    SELECT nextval('global_id_sequence') % 1024 INTO seq_id;

    SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;
    result := (now_millis - our_epoch) << 23;
    result := result | (shard_id << 10);
    result := result | (seq_id);
END;
$$ LANGUAGE PLPGSQL;

select id_auxiliar,* from contabilidad.tbl_auxiliar
select * from contabilidad.list_diario(2,1,1,1,1,1,9)


select *from common.fn_ubigeo(1);

select * from almacen.isp_seriecotizacionpreventa(1,1,1,23,1,4,0,NULL,'1    ',18,'')

 
ventas.list_cantidadproductotrimestralxanio
 
select * from ventas.list_cantidadproductotrimestralxanio(1,'',1)order by __year
select * from ventas.lis_ventasdiariasproductovendedorComercial(2018,11,1)

select * from creditos.list_saldos_cliente('000',1)

select * from contabilidad.list_consultarAsientos(0,0,1)

select * from contabilidad.fn_get_asiento_contable(60)

select * from contabilidad.fn_get_asiento_contable(49)

select * from ventas.list_facvales_ventas('1','1130','1')

select *from almacen.tbl_familia




SELECT *FROM contabilidad.tbl__asiento__contable WHERE glosa_asi='CANCELACION DE FACTURA N°OP-066309'
select *from contabilidad.tbl__detalle__asiento__contable where id_asiento=173

select *from contabilidad.tbl_subdiario order by 1

update planillas.tbl_persona set nombre_razon='OBERLUYS VILCHEZ EVELYN GIUSSELLY' where doc_persona='47722437'

update planillas.tbl_persona where doc_persona='47722437'

select compras.gen_correl_compra(2019,2,true)

select * from ALMACEN.isp_grabarexistencias(1,'1103',11,1,1,'Registro por productos','FALSE','0.00','0.00','FALSE')


select * from almacen.usp_despacho(1,1,'01/03/2019','7','1    ',1)


select *from almacen.tbl_detdespacho

select * from almacen.tbl_despacho

select *from ventas.fn_list_estadistico_ventas()

select *from ventas.list_ventas_vendedor_resumen('01/03/2019','01/03/2019')


select * from ventas.tbl_facturacion

select *from common.tbl_dpto


select * from common.spi_auditoria(NULL,'Insert','common.tbl_dpto','"Departamento registrado"',NULL,NULL,NULL,'select * from common.fn_departamentos(1,''0'',''Metropolitana de Santiago'',6)','1','1','1')
select  *from ventas.fn_listfamiliaventa(2019,6)


select *from ventas.list_ranking_ventas_producto('01/06/2019','22/07/2019');

select *from caja.fn_liquidaciones_caja_diarios()

select * from ventas.USP_AUTORIZASOLICITUD(1,1,'371279',1)

select * from ventas.spi_facturacionanticipo(1,0,4925,1,4924,4924,1,'1    ')

select *from ventas.tbl_facturacionanticipo
"{0,0000001}"
select PLANILLAS.SPI_CORRELATIVO_DOCCLIENTE(1)


select *from almacen.tbl_kardex

select * from ALMACEN.SPI_LOTES(0,1,'4545','1'::numeric,'4.5200'::numeric,'4.52'::numeric,'02/01/2020','1258',1,1)

select *from almacen.tbl__lote 

select * from COMMON.fn_TipoReporte(1,0,'REPORTE AGRUPADO MES DE ENERO-2019',NULL,1)


create or replace view creditos.v_detallepagoproveedores
as
select
c.serie ||'-' || c.nro_doc_compra as comprobante,
c.fec_documento as fecha_compra,
prov.doc_persona as doc_proveedor,
prov.nombre_razon as proveedor,
mc.fecha_mov,
CASE WHEN dpp.id_moneda=1 then dpp.imp_pago else 0 end as imp_soles,
CASE WHEN dpp.id_moneda=2 then dpp.imp_pago else 0 end as imp_dolares,
mc.serie || '-'|| mc.numero as numero_movimiento,
prov.id_persona as id_proveedor
from compras.tbl_compra c
inner join planillas.tbl_persona prov on prov.id_persona=c.id_proveedor
inner join creditos.tbl_creditoscompra cp on c.id__compra=cp.id__compra and c.id_sucursalcompra=cp.id_sucursalcompra
inner join creditos.tbl_credito cr on cr.id_credito=cp.id_credito and cr.id_sucursal_credito=cp.id_sucursal_credito
inner join creditos.tbl_detpagocuota dpc on cr.id_credito=dpc.id_credito and cr.id_sucursal_credito=dpc.id_sucursal_credito
inner join caja.tbl_movcaja mc on mc.id_movimcaja=dpc.id_movimcaja and mc.id_sucursal=dpc.id_sucursal
inner join caja.tbl_detmovpago dpp on  mc.id_movimcaja=dpp.id_movimcaja and mc.id_sucursal=dpp.id_sucursal
inner join common.tbl_moneda m on m.id_moneda=dpp.id_moneda
where mc.id_estado=1

--CREATE OR REPLACE FUNCTION ALMACEN.FN_

select *from almacen.v_kardex

select *from caja.tbl_detmovpago
select *from compras.tbl_compra

select *from caja.tbl_movcaja 
select * from ALMACEN.V_UNIDAD  order by id_unidadventa::integer

select * from ALMACEN.v_precios   WHERE id_producto  = '2765'

select *from ventas.fn_consolidadoventas(2,'01/03/2019','31/03/2019');


select * from hotel.spi_tipohabitacion(1,0,'DB','DOBLE',2,4,1)

select * from hotel.tbl_tipohabitacion

create or replace function hotel.spi_tipohabitacion(
	op integer,
	_id integer,
	_codigo varchar(20),
	_descripcion text,
	_nro_personas integer,
	_nro_habitaciones integer,
	_id_estado integer
)returns text[] as $$
declare
	res text[];
begin
if op=1 then
	if not exists(select 1 from hotel.tbl_tipohabitacion WHERE descripcion=_descripcion) then
		select max(id) into _id from hotel.tbl_tipohabitacion;
		if _id is null then
			_id:=1;
		else
			_id:=_id+1;
		end if;
		insert into hotel.tbl_tipohabitacion(
			id,
			codigo,
			descripcion,
			nro_personas,
			nro_habitaciones,
			id_estado
		)values(
			_id,
			_codigo,
			_descripcion,
			_nro_personas,
			_nro_habitaciones,
			_id_estado
		) returning array['0','Registro realizado'] into res;
		if not found then
			res:=array['501','Intente nuevamente'];
		end if;
	else
		res:=array['500','Ya existe un registro con los mismos datos'];
	end if;
end if;
if op=2 then
	if exists(select 1 from hotel.tbl_tipohabitacion where id=_id) then
		update hotel.tbl_tipohabitacion set
			codigo=_codigo,
			descripcion=_descripcion,
			nro_personas=_nro_personas,
			nro_habitaciones=_nro_habitaciones,
			id_estado=_id_estado
		where id=_id;
		res:=array['0','Registro actualizado'];
	else
		res:=array['502','Verifique que exista el registro'];
	end if;
end if;
return res;
end;$$
language 'plpgsql';


alter table hotel.tbl_tipohabitacion add column uuid  character varying(36)  NOT NULL DEFAULT upper((uuid_in((md5(((random())::text || (now())::text)))::cstring))::text);
alter table hotel.tbl_habitacion add column uuid  character varying(36)  NOT NULL DEFAULT upper((uuid_in((md5(((random())::text || (now())::text)))::cstring))::text);

create or replace function hotel.fn_tipohabitacion_add_or_update(
	op integer,
	_uuid varchar(36) ,
	_codigo varchar(20),
	_descripcion text,
	_nro_personas integer,
	_nro_habitaciones integer,
	_id_estado integer
)returns table(
	statuscode integer, 
	statusmessage text
) as $$
declare
	res text[];
	_id integer;
begin
if op=1 then
	if not exists(select 1 from hotel.tbl_tipohabitacion WHERE upper(trim(descripcion))=upper(trim(_descripcion))) then
		select max(id) into _id from hotel.tbl_tipohabitacion;
		if _id is null then
			_id:=1;
		else
			_id:=_id+1;
		end if;
		insert into hotel.tbl_tipohabitacion(
			id,
			codigo,
			descripcion,
			nro_personas,
			nro_habitaciones,
			id_estado
		)values(
			_id,
			_codigo,
			_descripcion,
			_nro_personas,
			_nro_habitaciones,
			_id_estado
		) returning array['0','Registro realizado'] into res;
		if not found then
			return query select 0 as StatusCode, 'Intente nuevamente.' as StatusMessage;
		end if;
		return query select 1 as StatusCode, 'Se registro correctamente el tipo de habitacion.' as StatusMessage;
	else
		--res:=array['500','Ya existe un registro con los mismos datos'];
		return query select 2 as StatusCode, 'Ya existe un registro con los mismos datos.' as StatusMessage;
	end if;
end if;
if op=2 then
	if exists(select 1 from hotel.tbl_tipohabitacion where uuid=_uuid) then
		update hotel.tbl_tipohabitacion set
			codigo=_codigo,
			descripcion=_descripcion,
			nro_personas=_nro_personas,
			nro_habitaciones=_nro_habitaciones,
			id_estado=_id_estado
		where uuid=_uuid;
		return query select 1 as StatusCode, 'El tipo de habitacion se actualizo correctamente.' as StatusMessage;
	else
		return query select 2 as StatusCode, 'Verefique que exista el registro.' as StatusMessage;
	end if;
end if;
end;$$
language 'plpgsql';



create or replace function hotel.fn_habitacion_add_or_update(
	op integer,
	_uuid varchar(36) ,
	_codigo character varying(10),
	_descripcion text,
	_id_tipohabitacion varchar(36),
	_id_situacionhabitacion varchar(36),
	_id_estado integer	 
)returns table(
	statuscode integer, 
	statusmessage text
) as $$
declare
	res text[];
	_id integer;
       _id_tipohabitacion integer;
begin
select t.id into _id_tipohabitacion
	from public.tbl_tipohabitacion t
	where uuid=_id_tipohabitacion;

if op=1 then
	if not exists(select 1 from hotel.tbl_habitacion WHERE upper(trim(descripcion))=upper(trim(_descripcion))) then
		select max(id) into _id from hotel.tbl_habitacion;
		if _id is null then
			_id:=1;
		else
			_id:=_id+1;
		end if;
		insert into hotel.tbl_habitacion(
			id, 
			codigo, 
			descripcion, 
			id_tipohabitacion, 
			id_situacionhabitacion, 
			id_estado 
		)values(
			_codigo, 
			_descripcion, 
			_id_tipohabitacion, 
			_id_situacionhabitacion, 
			_id_estado 
		) returning array['0','Registro realizado'] into res;
		if not found then
			return query select 0 as StatusCode, 'Intente nuevamente.' as StatusMessage;
		end if;
		return query select 1 as StatusCode, 'Se registro correctamente el tipo de habitacion.' as StatusMessage;
	else
		--res:=array['500','Ya existe un registro con los mismos datos'];
		return query select 2 as StatusCode, 'Ya existe un registro con los mismos datos.' as StatusMessage;
	end if;
end if;
if op=2 then
	if exists(select 1 from hotel.tbl_habitacion where uuid=_uuid) then
		update hotel.tbl_habitacion set
			 
			codigo=_codigo, 
			descripcion=_descripcion, 
			id_tipohabitacion=_id_tipohabitacion, 
			id_situacionhabitacion=_id_situacionhabitacion, 
			id_estado=_id_estado 
		where uuid=_uuid;
		return query select 1 as StatusCode, 'El tipo de habitacion se actualizo correctamente.' as StatusMessage;
	else
		return query select 2 as StatusCode, 'Verefique que exista el registro.' as StatusMessage;
	end if;
end if;
end;$$
language 'plpgsql';



create or replace function ventas.fn_consolidadoventas(
	op integer,
	desde text ,
	hasta text
)
returns table(
	dia integer,
	mes integer,
	anio integer,
	serie char(4),	
	inicio bigint,	
	fin bigint,
	imp_igv numeric(20,4),
	imp_venta numeric(20,4),
	imp_total numeric(20,4),
	empresa  varchar(200),
	ruc_empresa char(12),
	dir_empresa  varchar(100)	
) as $$
declare
begin
if op=1 then
	return query 
	select 
		x.dia::integer as dia,
		'0'::integer as mes,
		'0'::integer as anio,
		x.serie,	
		x.inicio,
		x.fin,
		x.imp_igv,
		x.imp_venta,
		x.imp_total,
		x.empresa,
		x.ruc_empresa,
		x.dir_sucursal
	from (select 
		0 as dia,
		f.serie_facturacion as serie,
		min(f.numdoc_facturacion::bigint) as inicio,
		max(f.numdoc_facturacion::bigint) as fin,
		sum(CASE WHEN f.id_estado=1 then f.imp_igv else 0 end) as imp_igv,
		sum(CASE WHEN f.id_estado=1 then f.valor_venta else 0 end) as imp_venta,
		sum(CASE WHEN f.id_estado=1 then f.imp_total else 0 end) as imp_total ,	
		emp.nombre as empresa,
		emp.ruc as ruc_empresa,
		s.direccion as dir_sucursal	
	from ventas.tbl_facturacion f
	 JOIN common.tbl_sucursal s ON s.id_sucursal = f.id_sucursal
	 JOIN common.tbl_empresa emp on emp.id_empresa=s.id_empresa
	where f.fecha_venta::date>=desde::date and f.fecha_venta::date<=hasta::date
	group by serie_facturacion,emp.nombre ,
	emp.ruc ,
	s.direccion
	) x;
end if;
if op=2 then
	return query 
	select 
		x.dia::integer as dia,
		x.mes::integer as mes,
		x.anio::integer as anio,
		x.serie,	
		x.inicio,
		x.fin,
		x.imp_igv,
		x.imp_venta,
		x.imp_total,
		x.empresa,
		x.ruc_empresa,
		x.dir_sucursal
	from (
	select 
		date_part('day',fecha_venta) as dia,
		date_part('month',fecha_venta) as mes,
		date_part('year',fecha_venta) as anio,
		f.serie_facturacion as serie,
		min(f.numdoc_facturacion::bigint) as inicio,
		max(f.numdoc_facturacion::bigint) as fin,
		sum(CASE WHEN f.id_estado=1 then f.imp_igv else 0 end) as imp_igv,
		sum(CASE WHEN f.id_estado=1 then f.valor_venta else 0 end) as imp_venta,
		sum(CASE WHEN f.id_estado=1 then f.imp_total else 0 end) as imp_total ,	
		emp.nombre as empresa,
		emp.ruc as ruc_empresa,
		s.direccion as dir_sucursal		
	from ventas.tbl_facturacion f
	 JOIN common.tbl_sucursal s ON s.id_sucursal = f.id_sucursal
	 JOIN common.tbl_empresa emp on emp.id_empresa=s.id_empresa
	where f.fecha_venta::date>=desde::date and f.fecha_venta::date<=hasta::date
	group by serie_facturacion,emp.nombre ,
	emp.ruc ,
	s.direccion,date_part('day',f.fecha_venta),date_part('year',f.fecha_venta) ,date_part('month',f.fecha_venta)
	)x;
end if;
end;$$
language 'plpgsql';

select *from ventas.fn_resumen_comprobantes_enviados('01/02/2020','29/02/2020');

CREATE OR REPLACE FUNCTION ventas.fn_resumen_comprobantes_enviados(
	desde text ,
	hasta text,
	estado integer
)
returns  table(
	dia integer,
	mes integer,
	anio integer,
	serie varchar(13),
	inicio bigint,
	fin bigint,
	imp_igv numeric(20,2),
	imp_venta numeric(20,2),
	impt_total numeric(20,2),
	nombre_archivo text,
	ticket varchar(25),
	tipo_resumen text
) as $$
declare
begin
return query 
select 
		x.dia::integer as dia,
		x.mes::integer as mes,
		x.anio::integer as anio,
		x.serie,	
		x.inicio,
		x.fin,
		x.imp_igv,
		x.imp_venta,
		x.imp_total,
		X.nombre_archivo,
		x.ticket,
		x.tipo_resumen
	from (
	select 
		date_part('day',documentos_emision_fecha) as dia,
		date_part('month',documentos_emision_fecha) as mes,
		date_part('year',documentos_emision_fecha) as anio,
		s.serie_documento as serie,
		min(s.numero_documento::bigint) as inicio,
		max(s.numero_documento::bigint) as fin,
		sum(igv) as imp_igv,
		sum(venta_exonerada+venta_gravada) as imp_venta,
		sum(total_cobrado) as imp_total,
		replace(replace(f.resumen_enviado_Archivo,'R-',''),'XML','') as nombre_archivo,
		f.resumen_ticket as ticket,
		f.tipo_resumen
				
	from ventas.tbl_resumen f
	 JOIN ventas.tbl_detresumen s ON s.resumen_id = f.resumen_id
	where f.documentos_emision_fecha::date>=desde::date and f.documentos_emision_fecha::date<=hasta::date and resumen_enviado_status=estado
	group by serie_documento,
	 date_part('day',f.documentos_emision_fecha),
		date_part('year',f.documentos_emision_fecha) ,
		date_part('month',f.documentos_emision_fecha),
		f.resumen_enviado_Archivo,f.resumen_ticket,f.tipo_resumen
	)x;
end;$$
language 'plpgsql';



select *from almacen.tbl_resumen r
inner join almacent


 select *from ventas.tbl_detresumen

select *from ventas.tbl_resumen

select *from ventas.v_resumen

select 
	f.serie_facturacion,
	min(f.numdoc_facturacion::bigint) as inicio,
	max(f.numdoc_facturacion::bigint) as fin,
	sum(f.imp_igv) as imp_igv,
	sum(f.valor_venta) as imp_venta,
	sum(f.imp_total) as imp_total ,
	date_part('year',f.fecha_venta) as anio,
	date_part('month',f.fecha_venta) as mes,
	emp.nombre as empresa,
	emp.ruc as ruc_empresa,
	s.direccion as dir_sucursal
from ventas.tbl_facturacion f
 JOIN common.tbl_sucursal s ON s.id_sucursal = f.id_sucursal
 JOIN common.tbl_empresa emp on emp.id_empresa=s.id_empresa
where date_part('year',fecha_venta)=2020 and date_part('month',fecha_venta)=1
group by serie_facturacion,emp.nombre ,
	emp.ruc ,
	s.direccion,date_part('year',f.fecha_venta) ,date_part('month',f.fecha_venta)




select *from compras.fn_costocompra('2765',2,190.512);

create or replace function compras.fn_costocompra(
	_id_producto text,
	_id_unidad integer,
	_importe numeric(20,4) 
)
returns table(
	id_producto varchar(30),
	id_unidad integer,
	costo_unitario numeric(20,4)
) as $$
declare
	dat record;
        _val_unidad integer;
	_costo numeric(20,4);
begin
/*create LOCAL  TEMPORARY table tbl_temp(
	id_producto varchar(30),
	id_unidad integer,
	costo numeric(20,4)
) on commit drop;*/
select val_unidad into _val_unidad  from almacen.tbl_detproducto dp where dp.id_producto=_id_producto and dp.id_unidadventa=_id_unidad;
if _val_unidad>0 then
	_costo:=_importe/_val_unidad;
end if;

return query  select dp.id_producto,dp.id_unidadventa,_costo*val_unidad from almacen.tbl_detproducto dp where dp.id_producto=_id_producto;
/*select *from almacen.tbl_detproducto where id_producto=_id_producto loop
	
end loop;*/
--for dat 
end;$$
language 'plpgsql';


select serie_facturacion,min(numdoc_facturacion::bigint) as inicio,max(numdoc_facturacion::bigint) as fin from ventas.tbl_facturacion
where date_part('year',fecha_venta)=2019 and date_part('month',fecha_venta)=4
group by serie_facturacion



CREATE OR REPLACE FUNCTION compras.isp_anular_documento_compra(
    _id_compra integer,
    _id_sucursalcompra integer,
    _id_estado integer,
    _glosa text)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	rec_cuotas record;
	i integer;
	rec_mov record;
	_id_credito integer;
	_id_sucursal integer;
	_importe numeric(20,4);
	dat record;
begin
if exists(select *from  compras.tbl_compra where id_sucursalcompra=_id_sucursalcompra  and id__compra=_id_compra) then
	update compras.tbl_compra set id_estado=_id_Estado where id_sucursalcompra=_id_sucursalcompra and id__compra=_id_compra;
	for dat in select id_producto,id_unidadventa,id_almacen,cantidad 
					from compras.tbl_detcompra where id_sucursalcompra=_id_sucursalcompra  and id__compra=_id_compra LOOP
		res:=(select almacen.spi_actualizar_existencias(1,dat.id_almacen,dat.id_producto,dat.id_unidadventa,dat.cantidad,0.00));
	end loop;
	res:=array['0','Registro anulado'];
	i:=0;
	for rec_cuotas in select cc.id_credito,cc.id_sucursal_credito from 
		creditos.tbl_creditoscompra cc 
		where cc.id_sucursalcompra=_id_sucursalcompra and  cc.id__compra=_id_compra loop
		update creditos.tbl_cuota set id_estado=7 where id_credito=rec_cuotas.id_credito and id_sucursal_credito=rec_cuotas.id_sucursal_credito;
		update creditos.tbl_credito set id_estado =7 where id_credito=rec_cuotas.id_credito and id_sucursal_credito=rec_cuotas.id_sucursal_credito;
		_id_credito:=rec_cuotas.id_credito;
		_id_sucursal:=rec_cuotas.id_sucursal_credito;
		i:=i+1;
	end loop;
	for  rec_mov in select dp.imp_pago from creditos.tbl_detpagocuota dp 
		inner join caja.tbl_movcaja cm on (cm.id_movimcaja=dp.id_movimcaja and  cm.id_sucursal=dp.id_sucursal) 
		where dp.id_credito=_id_credito and dp.id_sucursal_credito=_id_sucursal and cm.id_estado=1 loop
		_importe:=COALESCE(_importe,0)+COALESCE(rec_mov.imp_pago,0);
	end loop;
	
	res:=array['0','Registro Anulado satisfactoriamente '];
	if _importe>0 then
		res:=array['507','El Documento  ya tiene pagos asociados'];
	end if;
	if i>1 then
		res:=array['507','El Documento esta asociado con otros documentos al momento de generar Letras de pagos'];
	end if;
else
	res:=array['504','Verefique que exista el registro'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;




CREATE OR REPLACE FUNCTION compras.isp_anular_nota_credito(
    _id_compra integer,
    _id_sucursalcompra integer,
    _id_estado integer,
    _glosa text)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	rec_cuotas record;
	i integer;
	rec_mov record;
	_id_credito integer;
	_id_sucursal integer;
	_importe numeric(20,4);
	dat record;
begin
if exists(select *from  compras.tbl_compra where id_sucursalcompra=_id_sucursalcompra  and id__compra=_id_compra) then
	update compras.tbl_compra set id_estado=_id_Estado where id_sucursalcompra=_id_sucursalcompra and id__compra=_id_compra;	 
	update creditos.tbl_cuota_notacredito set id_estado=7  where id__compra=_id_compra and id_sucursalnc=_id_sucursalcompra;
	--select *from creditos.tbl_cuota_notacredito
	res:=array['0','Registro Anulado satisfactoriamente'];
	/*if _importe>0 then
		res:=array['507','El Documento  ya tiene pagos asociados'];
	end if;
	if i>1 then
		res:=array['507','El Documento esta asociado con otros documentos al momento de generar Letras de pagos'];
	end if;*/
else
	res:=array['504','Verefique que exista el registro'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.fn_stock_compra(
    IN _id_producto character varying,
    IN _id_unidad integer,
    IN _id_almacen integer,
    IN _cantidad numeric,
    IN _cantidad_old numeric)
  RETURNS TABLE(product_id character varying, unit_id integer, val_unit integer, stock numeric, cantidad numeric) AS
$BODY$
declare 
	_stock numeric(20,4);
	_val_unidad integer;
	_id_unidad_inventario integer;
	_val_unidad_inventario integer;
	_val_unidad_venta integer;
	_descuento numeric(20,4);
	_descuento_old numeric(20,4);
	_stock_saldo numeric(20,4);	 
begin
_descuento:=0;
_descuento_old:=0;
stock:=0;
_val_unidad:=0;
_val_unidad_venta:=0;
_stock_saldo:=0;
	select dp.id_unidadventa,dp.val_unidad into _id_unidad_inventario,_val_unidad_inventario from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto
	inner join almacen.tbl_existencia ex on ex.id_producto=dp.id_producto and ex.id_unidadventa=dp.id_unidadventa
	where ex.id_producto=_id_producto and ex.id_almacen=_id_almacen and dp.unidad_inventario=true;

	select dp.val_unidad into _val_unidad_venta from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto	 
	where dp.id_producto=_id_producto and dp.id_unidadventa=_id_unidad and dp.id_estado=1 ;

	RAISE NOTICE '_val_unidad_venta %', _val_unidad_venta;
	RAISE NOTICE '_id_unidad_inventario %', _id_unidad_inventario;
	RAISE NOTICE '_val_unidad_inventario %', _val_unidad_inventario;
	select stock_fisico into _stock from almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen and id_unidadventa=_id_unidad_inventario;
	RAISE NOTICE 'stock-01  %', _stock ;
	_descuento:=(_cantidad*_val_unidad_venta)/case when _val_unidad_inventario>0 then _val_unidad_inventario else 1 end;
	_descuento_old:=(_cantidad_old*_val_unidad_venta)/case when _val_unidad_inventario>0 then _val_unidad_inventario else 1 end;
	_stock_saldo :=_stock+COALESCE(_descuento,0)-COALESCE(_descuento_old,0);
	RAISE NOTICE '_descuento %', _descuento ;
	IF (SELECT COUNT(*) FROM almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen )>1 THEN
		RAISE NOTICE 'stock-02  %', _stock_saldo ;
		return query select COALESCE(_id_producto,'1'), COALESCE(_id_unidad_inventario,1), COALESCE(_val_unidad_inventario,1),COALESCE(_stock_saldo,0),COALESCE(_descuento,0);	
	ELSE
	return query select  ex.id_producto,ex.id_unidadventa,dp.val_unidad::integer, (ex.stock_fisico+_descuento-_descuento_old)::numeric(20,4) ,_descuento::numeric(20,4) 
		from almacen.tbl_existencia ex 
		inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
		where dp.id_producto=_id_producto and ex.id_almacen=_id_almacen and ex.id_unidadventa=_id_unidad_inventario and dp.unidad_inventario=true;
	END IF;

end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

CREATE OR REPLACE FUNCTION almacen.fn_stok_real(IN _id_producto character varying)
  RETURNS TABLE(product_id character varying, code text, id_familia text, familia text, producto text, stock_text character varying, unidades numeric, costo_unitario numeric, total_valorizado numeric, id_almacen integer, id_empresa integer) AS
$BODY$
DECLARE
	rec_stock record;--almacena el listado de stock de  todos los productos
	rec_unidades record;--almacena el listado de unidades de medida por producto
	_nro_packs numeric(20,4);--cantidad de packas al realizar un division del stock entre el valor de la unidad
	_saldo numeric(20,4);--almacena el saldo de stock una vez dividido entre un valor de unidades
	_num_unidades integer;--detalla la cantidad de unidades de medida de un producto
	_nom_unidad text;--nombre de la unidad de medida
	n_unidades 	numeric(20,6);
	stock_text text;
	rec_valunidades record;
BEGIN
_nro_packs:=0;
CREATE TEMPORARY TABLE TEMP_PRODUCTO(
	product_id varchar(30),
	codigo text,
	id_familia text,
	familia text,
	producto text,
	stock varchar(200),
	num_unidades numeric(20,2),
	costo_promedio numeric(20,2),
	valorizado numeric(20,2),
	almacen_id integer,
	empresa_id integer
)on commit drop;

CREATE TEMPORARY TABLE TEM_REGUND(
	id_producto varchar(30),
	stock text,
	id_unidad integer,
	val_unidad integer
)ON COMMIT DROP;
stock_text:='';
for rec_stock in select 
	ex.id_producto,
	p.codigo,
	ex.id_unidadventa,
	stock_fisico as stock,
	p.descripcion_larga as producto,
	costo_promedio,
	f.descripcion_larga as familia,
	f.id_familia,
	stock_fisico*costo_promedio as valorizado ,
	ex.id_almacen,
	suc.id_empresa
from almacen.tbl_existencia ex 
inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=ex.id_producto
inner join almacen.tbl_familia f on f.id_familia=p.id_familia
inner join almacen.tbl_almacen alm on alm.id_almacen=ex.id_almacen
inner join common.tbl_sucursal suc on suc.id_sucursal=alm.id_sucursal
 where  dp.unidad_inventario is true and p.id_estado=1 --and stock_fisico>0 
 order by p.id_familia --and ex.id_producto=_id_producto 
	loop
	n_unidades=rec_stock.stock;
	stock_text:='';
	delete from TEM_REGUND;
	for rec_unidades in select dp.id_unidadventa,dp.id_producto,dp.val_unidad from almacen.tbl_detproducto dp 
		where dp.id_producto=rec_stock.id_producto and dp.id_estado=1
		order by dp.val_unidad desc loop
			if n_unidades>0 then
				if rec_unidades.val_unidad>0 then 
				_nro_packs:=trunc(n_unidades/rec_unidades.val_unidad);	
				end if;			 
				_saldo:=n_unidades%rec_unidades.val_unidad;
				RAISE NOTICE '_nro_packs(%)', _nro_packs ||'  residuo: ' || _saldo::text ||  '  Stock :'  || n_unidades::text ||   '  val_unidad : ' || rec_unidades.val_unidad::text  || '  _nro_packs : ' || _nro_packs::text  || '  id_unidadventa:' || rec_unidades.id_unidadventa::text;
				if _nro_packs>0 then
					--if not exists(select 1 from TEM_REGUND where id_unidad not in(rec_unidades.id_unidadventa)) then
						INSERT INTO TEM_REGUND(id_producto,stock,id_unidad,val_unidad)values(rec_stock.id_producto,_nro_packs,rec_unidades.id_unidadventa,rec_unidades.val_unidad);
					--end if;			
				end if;
			end if; 
		 n_unidades:= _saldo;
	end loop;
	for rec_valunidades in select id_producto,stock,id_unidad,und.desc_corta as unidad,r.val_unidad  from TEM_REGUND r inner join almacen.tbl_unidad und on und.id_unidadventa=r.id_unidad loop 
		stock_text:=stock_text || ' ' || (rec_valunidades.stock::NUMERIC(20,0))::TEXT || ' ' || rec_valunidades.unidad || '('||rec_valunidades.val_unidad::text ||') ';
	end loop;
	RAISE NOTICE 'stock_text(%)', stock_text; 
	INSERT INTO TEMP_PRODUCTO(product_id,codigo,id_familia,familia,producto,stock,num_unidades,costo_promedio,valorizado,almacen_id,empresa_id)values(rec_stock.id_producto,rec_stock.id_producto,rec_stock.id_familia,rec_stock.familia,rec_stock.producto,stock_text,rec_stock.stock,rec_stock.costo_promedio,rec_stock.valorizado,rec_stock.id_almacen,rec_stock.id_empresa);
end loop;
return QUERY SELECT *FROM TEMP_PRODUCTO t   ;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


create or replace function almacen.fn_inventario_permanente_valorizado(almacen_id integer,f1 text,f2 text)
returns table(
	codarti text,--1
	articulo varchar(200),--2
	grupo varchar(100),--3
	linea varchar(100),--4
	unidadm varchar(20),--5
	almacen varchar(100),--6
	cant_anterior numeric(20,4),--7
	cant_ingresos numeric(20,4),--8
	cant_salidas numeric(20,4),--9
	cant_saldo numeric(20,4),--10
	costo numeric(20,4),--11
	importe numeric(20,4),--12
	idunimed integer,--13
	id_almacen integer,--14
	id_familia char(5),--15
	codigo char(30)--16
) as $$
declare
begin
return  query 

select
x.codarti,--1
x.articulo,--2
x.grupo,--3
x.linea,--4
x.unidadm,--5
x.almacen ,--6
COALESCE(x.saldo_a,0) as cant_anterior,--7
COALESCE(x.cantidad_ing,0) as cant_ingresos,--8
COALESCE(x.cantidad_sali,0) as cant_salida,--9
(COALESCE(x.saldo_a,0)+COALESCE(x.cantidad_ing,0)-COALESCE(x.cantidad_sali,0))::numeric(20,4) as saldo,--10
x.costo as costo,--11
((COALESCE(x.saldo_a,0)+COALESCE(x.cantidad_ing,0)-COALESCE(x.cantidad_sali,0))::numeric(20,4))*x.costo::numeric(20,4) as importe,--12
x.idunimed,--13
x.id_almacen,--14
x.id_familia,--15
x.codigo--16
from (
	
	select  sa.codarti,sa.articulo,sa.grupo,sa.linea,sa.unidadm,sa.almacen,sa.idunimed,sa.id_familia,sa.codigo,sa.saldo as saldo_a,cc.cantidad_ing,ss.cantidad_sali,sa.costo,sa.id_almacen  
		from (
		select 
			p.id_producto::text codarti,
			p.descripcion_larga as articulo,
			gr.descripcion_larga as grupo,
			fa.descripcion_larga as linea,
			und.desc_corta as unidadm,
			alm.descalmacen as almacen,
			dp.id_unidadventa as idunimed,
			fa.id_familia,
			p.codigo,
			sxa.saldo,
			ex.costo_promedio as costo,
			ex.id_almacen 
		 from almacen.tbl_existencia ex
		inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa and dp.unidad_inventario=true	
		inner join almacen.tbl_unidad und on und.id_unidadventa =dp.id_unidadventa
		inner join almacen.tbl_producto p on p.id_producto=dp.id_producto
		inner join almacen.tbl_familia fa on fa.id_familia=p.id_familia
		inner join almacen.tbl_grupo gr on gr.id_grupo=fa.id_grupo	
		INNER JOIN almacen.tbl_almacen alm on alm.id_almacen=ex.id_almacen		
		left join (
				select 
					ssa.codarti,
					ssa.articulo,
					ssa.grupo,
					ssa.linea,
					ssa.unidadm,
					ssa.almacen,
					ssa.idunimed,
					ssa.id_familia,
					ssa.codigo,
					COALESCE(abs(ssa.cantidad),0)-COALESCE(abs(sv.cantidad),0) as saldo 
				from (
					select k.codarti,k.articulo,k.grupo,k.linea,k.unidadm,k.almacen,k.idunimed,k.id_familia,k.codigo,sum(k.cant) as cantidad from almacen.v_kardex k
					where movi='C' and fecha::date<f1::date
					group by  k.codarti,k.articulo,k.grupo,k.linea,k.unidadm,k.almacen,k.idunimed,k.id_familia,k.codigo
			 
					
				) ssa
				 
				left join (
					
					select  k.codarti,k.idunimed,sum(abs(k.cant)) as cantidad from almacen.v_kardex k
					where movi='V' and fecha::date<f1::date-- and 
					group by  k.codarti,k.idunimed
				) as sv on ssa.codarti=sv.codarti and ssa.idunimed=sv.idunimed
		) sxa  on sxa.codarti=ex.id_producto and sxa.idunimed=ex.id_unidadventa

	) sa 
	left join (
		select k.codarti,k.idunimed,sum(abs(k.cant)) as cantidad_ing from almacen.v_kardex k
			where movi='C' and fecha::date>=f1::date and fecha::date<=f2::date
			group by  k.codarti,k.idunimed
	) as cc on cc.codarti=sa.codarti and cc.idunimed=sa.idunimed
	left join (
		select k.codarti,k.idunimed,sum(abs(k.cant)) as cantidad_sali from almacen.v_kardex k
			where movi='V' and fecha::date>=f1::date and fecha::date<=f2::date
			group by  k.codarti,k.idunimed
	) as ss on ss.codarti=sa.codarti and sa.idunimed=ss.idunimed

) x
order by x.id_familia::integer desc;
end;$$
language 'plpgsql';


create or replace function common.fn_TipoReporte(
	_op integer,
	_id bigint ,
	_nombre varchar(500),	
	_id_usuario char(5),
	_id_estado integer
	
) returns text[] as $$
declare
	res text[];
begin
if _op=1 then
if not exists(select *from common.tbl_tiporeporte where upper(nombre)=upper(_nombre)) then
	insert into common.tbl_tiporeporte(nombre,id_usuario,id_estado)values(_nombre,_id_usuario,_id_estado) returning array['0','Registro procesado',id::text] into res;
	if not found then
		res:=array['501','Inconsistencia inesperada intente nuevamente'];
	end if;

end if;
end if;
if _op=2 then
	if exists(select *from common.tbl_tiporeporte where id=_id) then
		update common.tbl_tiporeporte  set nombre=_nombre,id_usuario=_id_usuario,id_estado=_id_estado
		where id=_id;
		res:= array['0','Registro actualizado',_id::text];
	end if;
end if;
return res;
end;$$
language 'plpgsql';

create or replace function almacen.fn_removeItemReporteProducto(
	_id bigint
)
returns text[] as  $$
declare
	res text[];
begin
if exists(select *from almacen.tbl_ProductosReporte where id=_id) then
	update almacen.tbl_ProductosReporte  
		set 
		  id_estado=3
	where id=_id
	returning array['0','Registro actualizado'] into res;
end if;
return res;
end;$$
language 'plpgsql';

select *from common.tbl_estado

create or replace function almacen.fn_ProductosReporte(
	op integer,
	_id bigint ,
	_nombre text,
	_id_producto varchar(30),
	_id_tiporeporte bigint ,	
	_id_usuario char(5),
	_id_estado integer
) returns text[] as $$
declare
	res text[];
begin
if op=1 then
	if not exists(select *from almacen.tbl_ProductosReporte where id_producto=_id_producto and id_tiporeporte=_id_tiporeporte) then
		insert into almacen.tbl_ProductosReporte(
			nombre,
			id_producto,
			id_tiporeporte,
			id_usuario,
			id_estado
		)values(
			_nombre,
			_id_producto,
			_id_tiporeporte,
			_id_usuario,
			_id_estado
		) returning array['0','Registro procesado'] into res;
		if not found then
			res:=array['501','Inconsistencia inesperada intente nuevamente'];
		end if;

	end if;
end if;
if op=2 then
	if exists(select *from almacen.tbl_ProductosReporte where id=_id) then
		update almacen.tbl_ProductosReporte  
			set 
				nombre=_nombre,
				id_producto=_id_producto,
				id_tiporeporte=_id_tiporeporte,
				id_usuario=_id_usuario,
				id_estado=_id_estado
		returning array['0','Registro actualizado'] into res;
	end if;
end if;
return res;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION ALMACEN.SPI_LOTES(
	__id__lote BIGINT,
	_id_almacen integer, 
	_lote text, 
	_cantidad numeric(20,6), 
	_precio numeric(20,6), 
	_imp_total numeric(20,6), 
	_fecha_lote text ,
	_id_producto varchar(30), 
	_id_unidadventa integer, 
	_id_estado_lote integer, 
	_id_usuario varchar(5)
)
RETURNS TEXT[] AS $$
DECLARE
	--__id__lote BIGINT;
	res text[];
BEGIN

if not exists(select 1 from almacen.tbl__lote 
		where nro__lote=_lote 
		and id__producto=_id_producto 
		and id__almacen=_id_almacen 
		and id__unidadventa=_id_unidadventa)then
		select max(id__lote) into __id__lote from almacen.tbl__lote ;
		if __id__lote is null then
			__id__lote:=1;
		else
			__id__lote:=__id__lote+1;
		end if;
	INSERT INTO almacen.tbl__lote
	(
		id__lote, 
		id__sucursal, 
		id__almacen, 
		nro__lote, 
		stock, 
		stock__inicial, 
		costo__inicial, 
		valor__actual, 
		fecha__registro, 
		fecha__vencimiento, 
		id__producto, 
		id__unidadventa, 
		id__estado, 
		id__usuario__reg
	)
    VALUES (
		__id__lote, 
		1, 
		_id_almacen, 
		_lote, 
		_cantidad, 
		_cantidad, 
		_precio, 
		_imp_total, 
		now(), 
		 _fecha_lote::DATE ,
		_id_producto, 
		_id_unidadventa, 
		_id_estado_lote, 
		_id_usuario
		
    )returning array['0','Registro procesado'] into res;

   -- update compras.tbl_detcompra  set id__lote=__id__lote,id__sucursal__lote=_id_sucursalcompra where id__detcompra=__id; 
else
	update almacen.tbl__lote set stock=stock+_cantidad 
		where nro__lote=_lote 
		and id__producto=_id_producto 
		and id__almacen=_id_almacen 
		and id__unidadventa=_id_unidadventa returning array['0',id__lote::text,id__sucursal::text] into res;
		--update compras.tbl_detcompra  set id__lote=res[2]::bigint,id__sucursal__lote=res[3]::integer where id__detcompra=__id; 
		res:=array['0','Registro procesado'];
end if;
return res;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE function common.fn_lista_common_tables(op integer)
returns table(
	Id integer,
	Name text
) as  $$
declare 
begin
if op=1 then
	return query select id_sucursal as Id,nombre::text as name from common.tbl_sucursal;
end if;
if op=2 then
	return query select id_persona::integer as Id,nombre_razon::text as name from planillas.tbl_persona where empleado is true;
end if;
if op=3 then
	return query select id_tipoventa::integer as Id,descripcion_larga::text as name from common.tbl_tipoventa ;
end if;

if op=4 then
	return query select id_comprobante::integer as Id,descripcion_larga::text as name from common.tbl_comprobante ;
end if;

if op=5 then
	return query select id_moneda::integer as Id,simbolo::text as name from common.tbl_moneda ;
end if;


end;$$
language 'plpgsql';


select *from common.tbl_moneda
select *from common.fn_lista_common_tables(3);

CREATE OR REPLACE FUNCTION almacen.spiu_marca(
    op integer,
    codigo character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _id_estado integer)
  RETURNS text[] AS
$BODY$
declare
   cadena character varying;
   item_id   VARCHAR;
   id        INT8;
   regs	     record;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from almacen.tbl_marca where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id_marca::integer) INTO item_id FROM almacen.tbl_marca ;
		IF item_id IS NULL THEN
		   item_id='1';
		ELSE
		  id = item_id::int+1;
		  item_id = id::text ;
		END IF;
		
		insert into almacen.tbl_marca (
			id_marca,
			descripcion_larga, 
			descripcion_corta,
			id_estado
			)
		values(
			item_id, 
			_descripcion_larga, 
			_descripcion_corta,
			_id_estado
		) RETURNING array['0',tbl_marca.id_marca::text,tbl_marca.descripcion_larga::text] INTO cadena;
		if not found then
			cadena:=array['504','Inconsistencia inesperada al registrar'];--||cadena; // si la operacion  ha sido efectuada correctamente
		end if;
		
	else
		cadena:=array['1'];
	    end if;
end if;
if op=2 then
	if(exists (select * from almacen.tbl_marca where id_marca=codigo)) then
		update almacen.tbl_marca set descripcion_larga = _descripcion_larga , id_estado = _id_estado, descripcion_corta = _descripcion_corta where id_marca = codigo;
		cadena:=array['0',codigo::text];
	else
		cadena:=array['1'];
	end if;
end if;
return cadena;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION almacen.spiu_sync_marca(
    op integer,
    codigo character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _id_estado integer)
  RETURNS table(statuscode integer,statusmessage text) AS
$BODY$
declare
   cadena character varying;
   item_id   VARCHAR;
   id        INT8;
   regs	     record;
   res       TEXT[];
begin
if(not exists (select * from almacen.tbl_marca where id_marca = codigo)) then		 		
	insert into almacen.tbl_marca (
		id_marca,
		descripcion_larga, 
		descripcion_corta,
		id_estado
		)
	values(
		codigo, 
		_descripcion_larga, 
		_descripcion_corta,
		_id_estado
	) ;
return query select 1 as statuscode,'Marca registrada' as statusmessage;
else	 
	update 
		almacen.tbl_marca 
	set 
		descripcion_larga = _descripcion_larga , 
		id_estado = _id_estado, 
		descripcion_corta = _descripcion_corta 
	where id_marca = codigo;
	return query select 1 as statuscode,'Marca actualizada' as statusmessage;
end if;
 
end;$BODY$
  LANGUAGE plpgsql VOLATILE


create or replace function almacen.spiu_sync_familia_marca(
	_id_familia char(5),
	_id_marca char(4),
	_id_estado integer
)
RETURNS table(statuscode integer,statusmessage text) AS $$
declare
begin
if not exists(select  *from almacen.tbl_familiamarca where id_familia=_id_familia and id_marca=_id_marca) then
	insert into almacen.tbl_familiamarca(id_familia,id_marca,id_estado)values(_id_familia,_id_marca,_id_estado);
	return query select 1 as statuscode,'Familia marca registrada' as statusmessage;
else
	update 
		almacen.tbl_familiamarca 
	set 
		id_estado=_id_estado
	where id_familia=_id_familia and id_marca=_id_marca;
	return query select 1 as statuscode,'Familia marca Actualizada' as statusmessage;
end if;
end;$$
language 'plpgsql';
  
 select  *from almacen.tbl_familiamarca

CREATE OR REPLACE FUNCTION ventas.isp_regla_descuento(
    op integer,
    _id_catalogo_dscto bigint,
    _id_sucursal integer,
    _nombre text,
    _cantidad_desde numeric,
    _fecha_desde text,
    _fecha_hasta text,
    _descuento numeric,
    _id_moneda integer,
    _id_tipodscto integer,
    _id_estado integer,
    _glosa text)
  RETURNS text[] AS
$BODY$
declare
	__id bigint;
	res text[];
begin
if op=1 then
	if not exists(select 1 from VENTAS.TBL_CATALOGO_DSCTO where nombre=_nombre and id_estado=1)then
		select max(id_catalogo_dscto) into __id from VENTAS.TBL_CATALOGO_DSCTO;
		if __id is null then
			__id:=1;
		else
			__id:=__id+1;
		end if;
		INSERT INTO ventas.tbl_catalogo_dscto
		(
			id_catalogo_dscto, 
			id_sucursal, 
			nombre,
			cantidad_desde, 
			fecha_desde, 
			fecha_hasta, 
			descuento, 
			id_moneda, 
			id_tipodscto, 
			id_estado, 
			glosa
		)
		VALUES (
			__id, 
			_id_sucursal, 
			_nombre,
			_cantidad_desde, 
			to_timestamp(_fecha_desde,'YYYY-MM-DD HH24:MI:SS.MS') , 
			to_timestamp(_fecha_hasta,'YYYY-MM-DD HH24:MI:SS.MS') , 
			_descuento, 
			_id_moneda, 
			_id_tipodscto, 
			_id_estado, 
			_glosa
		)returning array['0',id_catalogo_dscto::text]into res;
		if not found then
			res:=array['504','Inconsitencia Inesperada al registra el descuento'];
		end if;
	else
		res:=array['502','Existe un registro con la misma descripción'];
	end if;
end if;
if op=2 then
	if exists(select * from ventas.tbl_catalogo_dscto where id_catalogo_dscto=_id_catalogo_dscto ) then
		UPDATE ventas.tbl_catalogo_dscto
		   SET 
			id_sucursal=_id_sucursal, 
			nombre=_nombre,
			cantidad_desde=_cantidad_desde, 
			fecha_desde=to_timestamp(_fecha_desde,'YYYY-MM-DD HH24:MI:SS.MS') , 
			fecha_hasta=to_timestamp(_fecha_hasta,'YYYY-MM-DD HH24:MI:SS.MS') , 
			descuento=_descuento, 
			id_moneda=_id_moneda, 
			id_tipodscto=_id_tipodscto, 
			id_estado=_id_estado, 
			glosa=_glosa
		 WHERE id_catalogo_dscto=_id_catalogo_dscto; 
		res:=array['0',_id_catalogo_dscto::text];
	else
		res:=Array['503','Verefique que el registro exista'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from almacen.fn_view_kardex()

create or replace function almacen.fn_view_kardex()
returns text[] as $$
declare
begin
delete from   almacen.tbl_kardex;
delete from temp_detproducto;
delete from temp_existencia;
delete from temp_producto;
insert into almacen.tbl_kardex
select *from almacen.v_kardex;

insert into temp_detproducto
select *from almacen.tbl_detproducto;

insert into temp_existencia
select *from almacen.tbl_existencia;

insert into temp_producto
select *from almacen.tbl_producto;

return array['0','Kardex Generado'];
end;$$
language 'plpgsql';


select *from  ventas.tbl_detfacturacion


delete from almacen.tbl_kardex

select * from ventas.USP_PREMIO(1,0,'FALSE','FALSE','3 GEL. UNIVERSAL FRESA X 250GR+ DULCERA','','2596',1,'1'::numeric,'0.00'::numeric,'0.00'::numeric,'500'::numeric)

select *from  almacen.fn_productos_almacen(1,'CORBATA',2)


select 
k.id__kit,
k.id__sucursal,
k.serie__kit || '-' || k.numero__kit as numero,
fecha__reg as fecha, 
trim(p.codigo) as codigo,
p.descripcion_larga as producto,
u.desc_larga as unidad,
k.cantidad,
k.costo,
k.id__producto,
k.id__unidadventa,
k.id__concepto,
k.serie__ni,
k.numero__ni,
k.serie__ns,
k.numero__ns,
k.id__almacen,
k.id__estado,
k.concepto_id
from almacen.tbl__kitproducto k
inner join almacen.tbl_detproducto dp on k.id__producto=dp.id_producto and k.id__unidadventa=dp.id_unidadventa
inner join almacen.tbl_unidad u on u.id_unidadventa=dp.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=dp.id_producto

select *from almacen.tbl__kitproducto

CREATE OR REPLACE FUNCTION seguridad.spi_grabarusuarios(
    _op integer,
    _id_usuario character,
    _id_personal character varying,
    _camp1 character varying,
    _camp2 character varying,
    _online boolean,
    _rpta character varying,
    _id_estado integer,
    _id_perfil integer,
    _lista_precio text,
    _clave_credito text,
    _autoriza_credito boolean,
    _controla_stock boolean,
    _anular_docsventa boolean,
    _anular_docscompra boolean,
    _anular_guiasventa boolean,
    _anular_cuotaporcobrar boolean,
    _anular_movcoutas boolean,
    _generar_descargocuotas boolean,
    _generar_anticipos boolean,
    _serie_pedido text,
    _modifica_precio boolean,
    _aprobar_lineacredito boolean,
    _otorga_descuentos boolean,
    _editar_pedidos boolean,
    _editar_ventas boolean,
    _solicitar_clave boolean,
    _todas_ventas boolean,
    _visualiza_liquidacioncaja boolean ,
    _visualiza_costo boolean ,
    _unsolomenu boolean,
    _multi_pago boolean,
    _precio_minimo integer,
    _comprobante_predeterminado integer,
    _mov_caja_obligatorio boolean,
    _modifica_correlativo boolean
)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	id integer;
	item_id text;
	
begin
res:=array['-1',''];
 if (_op=1) then
	SELECT MAX(id_usuario::integer) INTO item_id      FROM seguridad.tbl_usuario ;
		IF item_id IS NULL THEN
		   item_id='1';
		ELSE
		  id=item_id::integer+1;
		  item_id= id::text;
		END IF;
	if (not exists (select *from seguridad.tbl_usuario where camp2=_camp2)) then
		   insert into seguridad.tbl_usuario(
				id_usuario ,
				id_persona ,
				camp1  ,
				camp2  ,
				online ,
				rpta  ,
				fec_registro    ,
				id_estado ,
				id_perfil ,
				lista_precio,
				clave_credito,
				autoriza_credito,
				controla_stock,
				anular_docsventa,
				anular_docscompra,
				anular_guiasventa,
				anular_cuotaporcobrar,
				anular_movcoutas,
				generar_descargocuotas,
				generar_anticipos,
				serie_pedido,
				modifica_precio,
				aprobar_lineacredito,
				OTORGA_DESCUENTOS,
				editar_pedidos,
				editar_ventas,
				solicitar_clave,
				todas_ventas,
				visualiza_liquidacioncaja,
				visualiza_costo,
				unsolomenu ,
				multi_pago,
				precio_minimo,
				comprobante_predeterminado,
				mov_caja_obligatorio,
				modifica_correlativo
			  )values(
				item_id ,
				_id_personal  ,
				_camp1  ,
				_camp2  ,
				_online ,
				_rpta  ,
				now(),
				_id_estado ,
				_id_perfil ,
				_lista_precio,
				_clave_credito,
				_autoriza_credito,
				_controla_stock,
				_anular_docsventa,
				_anular_docscompra,
				_anular_guiasventa,
				_anular_cuotaporcobrar,
				_anular_movcoutas,
				_generar_descargocuotas,
				_generar_anticipos,
				_serie_pedido,
				_modifica_precio,
				_aprobar_lineacredito,
				_OTORGA_DESCUENTOS,
				_editar_pedidos,
				_editar_ventas,
				_solicitar_clave,
				_todas_ventas,
				_visualiza_liquidacioncaja,
				_visualiza_costo,
				_unsolomenu ,
				_multi_pago,	
				_precio_minimo,
				_comprobante_predeterminado,
				_mov_caja_obligatorio,
				_modifica_correlativo
			  ) returning array['0',tbl_usuario.id_usuario::text] into res;
	 else
		res:=array['-504',''];
	end if;
end if;
if (_op=2) then
	if ( exists (select *from seguridad.tbl_usuario where id_usuario=_id_usuario)) then
		update seguridad.tbl_usuario 
			set camp1=_camp1  ,
				id_estado=_id_estado ,
				id_perfil=_id_perfil,
				id_persona=_id_personal,
				lista_precio=_lista_precio,
				clave_credito=_clave_credito,
				autoriza_credito=_autoriza_credito,
				controla_stock=_controla_stock,
				anular_docsventa=_anular_docsventa,
				anular_docscompra=_anular_docscompra,
				anular_guiasventa=_anular_guiasventa,
				anular_cuotaporcobrar=_anular_cuotaporcobrar,
				anular_movcoutas=_anular_movcoutas,
				generar_descargocuotas=_generar_descargocuotas,
				generar_anticipos=_generar_anticipos,
				serie_pedido=_serie_pedido,
				modifica_precio=_modifica_precio,
				aprobar_lineacredito=_aprobar_lineacredito,
				OTORGA_DESCUENTOS=_OTORGA_DESCUENTOS,
				editar_pedidos=_editar_pedidos,
				editar_ventas=_editar_ventas,
				solicitar_clave=_solicitar_clave,
				todas_ventas=_todas_ventas,
				visualiza_liquidacioncaja=_visualiza_liquidacioncaja,
				visualiza_costo=_visualiza_costo,
				unsolomenu =_unsolomenu ,
				multi_pago=_multi_pago,
				precio_minimo=_precio_minimo,
				comprobante_predeterminado=_comprobante_predeterminado,
				mov_caja_obligatorio=_mov_caja_obligatorio,
				modifica_correlativo=_modifica_correlativo
			where id_usuario=_id_usuario;
		res:=array['0',cast(_id_usuario as text) ];
	else
		res:=array['-504',''];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select * from CAJA.spi_operacionbanco(1,'2020-10-08 16:18:48.522',7,'0001','0000001','22','1',0,2,1305,1,'45'::numeric,'0.00'::numeric,'55','',1,?,?)
select * from CAJA.spi_operacionbanco(1,0,'2020-10-08 20:28:31.56',7,'0001','0000001','15',1,2,0,702,1,'45'::numeric,'0.00'::numeric,'45','',1,1,1)

select *from caja.tbl_operacionbanco

CREATE OR REPLACE FUNCTION caja.spi_operacionbanco(
	op integer,
	_id bigint ,
	_fecha text,
	_id_comprobante integer,
	_serie text,
	_numero text,
	_id_persona text,
	_tipo_operacion integer,
	_id_cuentaorigen integer,
	_id_cuentadestino integer,
	_concepto_id bigint,
	_id_moneda integer,
	_importe numeric(20,4),
	_tipo_cambio numeric(20,4),
	_nro_operacion text,
	_glosa text,
	_id_estado integer,
	_usuario_add integer,
	_id_sucursal integer	
) returns text[] as $$
declare
	res text[];
	_operacionbancoref_id bigint;
	--1: DEPOSITO, 
	--2: TRANSFERENCIA, 
	--3: RETIRO
begin

if op=1 then
	if (_tipo_operacion=1 or _tipo_operacion=3) then
		if exists(select * from caja.tbl_cuentabancaria where id_cuenta=_id_cuentaorigen) then
			if exists(select *from common.tbl_concepto where id=_concepto_id) then
				if exists(select *from planillas.tbl_persona where id_persona=_id_persona)then
					INSERT INTO caja.tbl_operacionbanco(
						fecha, 
						id_comprobante, 
						serie, 
						numero, 	
						id_persona, 
						tipo_operacion, 
						id_cuentabancaria, 
						concepto_id, 
						id_moneda, 
						importe, 
						tipo_cambio, 
						nro_operacion, 
						glosa, 
						id_estado, 
						usuario_add, 
						id_sucursal,
						operacion
					)
				    VALUES (
						_fecha::timestamp, 
						_id_comprobante, 
						_serie, 
						_numero, 	
						_id_persona, 
						_tipo_operacion, 
						_id_cuentaorigen, 
						_concepto_id, 
						_id_moneda, 
						_importe, 
						_tipo_cambio, 
						_nro_operacion, 
						_glosa, 
						_id_estado, 
						_usuario_add, 
						_id_sucursal,
						case when _tipo_operacion=1 then 1 else 2 end
					);
					res:=array['0','Operación generada'];
					if not found then
						res:=array['100','Inconsitencia inesperada intente nuevamente'];
					end if;
				else
					res:=Array['102','Verifique que el responsable este seleccionada correctamente'];
				end if;
			else
				res:=array['103','Seleccione correctamente el concepto'];
			end if;
		else
			res=array['104','seleccione la cuenta bancaria correctamente'];
		end if;
	end if;
	if (_tipo_operacion=2) then
		if exists(select * from caja.tbl_cuentabancaria where id_cuenta=_id_cuentaorigen) then
			if exists(select *from common.tbl_concepto where id=_concepto_id) then
				if exists(select *from planillas.tbl_persona where id_persona=_id_persona)then
					INSERT INTO caja.tbl_operacionbanco(
						fecha, 
						id_comprobante, 
						serie, 
						numero, 	
						id_persona, 
						tipo_operacion, 
						id_cuentabancaria, 
						concepto_id, 
						id_moneda, 
						importe, 
						tipo_cambio, 
						nro_operacion, 
						glosa, 
						id_estado, 
						usuario_add, 
						id_sucursal,
						operacion
					)
				    VALUES (
						_fecha::timestamp, 
						_id_comprobante, 
						_serie, 
						_numero, 	
						_id_persona, 
						_tipo_operacion, 
						_id_cuentaorigen, 
						_concepto_id, 
						_id_moneda, 
						_importe, 
						_tipo_cambio, 
						_nro_operacion, 
						_glosa, 
						_id_estado, 
						_usuario_add, 
						_id_sucursal,
						2
					) returning id into _operacionbancoref_id;
					if not found then
						res:=array['100','Inconsitencia inesperada intente nuevamente'];
					end if;
					if exists(select 1 from caja.tbl_operacionbanco where id=_operacionbancoref_id) then
						INSERT INTO caja.tbl_operacionbanco(
							fecha, 
							id_comprobante, 
							serie, 
							numero, 	
							id_persona, 
							tipo_operacion, 
							id_cuentabancaria, 
							concepto_id, 
							id_moneda, 
							importe, 
							tipo_cambio, 
							nro_operacion, 
							glosa, 
							id_estado, 
							usuario_add, 
							id_sucursal,
							operacionbancoref_id,
							operacion
						)
					    VALUES (
							_fecha::timestamp, 
							_id_comprobante, 
							_serie, 
							_numero, 	
							_id_persona, 
							_tipo_operacion, 
							_id_cuentadestino, 
							_concepto_id, 
							_id_moneda, 
							_importe, 
							_tipo_cambio, 
							_nro_operacion, 
							_glosa, 
							_id_estado, 
							_usuario_add, 
							_id_sucursal,
							_operacionbancoref_id,
							1
						);
						res:=array['0','Operación generada'];
					else
						res:=Array['105','Verifique que la cuenta origen este correctamente'];
					end if;					
				else
					res:=Array['102','Verifique que el responsable este seleccionada correctamente'];
				end if;
			else
				res:=array['103','Seleccione correctamente el concepto'];
			end if;
		else
			res=array['104','seleccione la cuenta bancaria correctamente'];
		end if;
	end if;
	 
end if;
return res;
end;$$
language 'plpgsql';



select *from almacen.v_precios


select * from ALMACEN.FN_PRODUCTOS_ALMACEN(1,'DET035',1)
select * from ALMACEN.FN_PRODUCTOS_ALMACEN(1,'a',1)

select *from almacen.tbl_precio

CREATE OR REPLACE FUNCTION almacen.fn_productos_almacen(
    IN __id_sucursal integer,
    IN __filtro text,
    IN __op integer
)
  RETURNS TABLE(
	_id_producto character varying, --0
	_codigo character, --1
	_producto character varying, --2
	_marca character varying, --3
	_almacen character varying, --4
	_transito numeric, --5
	_disponible text, --6
	_precio1 numeric, --7
	_precio2 numeric, --8
	_precio3 numeric, --9
	_unidad character varying, --10
	_id_estado integer, --11
	_servicio boolean, --12
	_impuesto numeric, --13
	_id_listaprecio integer, --14
	_id_unidadventa integer, --15
	_val_unidad numeric, --16
	_val_minimo numeric, --17
	_coste numeric, --18
	_id_empresa integer,--19 
	_familia character varying, --20
	_grupo character varying, --21
	_stock_ordencompra numeric, --22
	_suject_percepcion boolean, --23
	_imp_igv numeric, --24
	_id_tipoventa integer,--25 
	_undpred_compra boolean, --26
	_gestiona_series boolean, --27
	_gestiona_lotes boolean, --28
	_venta_retaceo boolean, --29
	_id_sucursal integer, --30
	_ctl_stock boolean, --31
	_cod_barra character varying, --32
	_precio4 numeric, --33
	_precio5 numeric, --34
	_precios text,--35
	_cantidad_fraccionada boolean--36
) AS
$BODY$
DECLARE
	__id__producto char(30);
	__id__unidad integer;
BEGIN
	select id_producto ,id_unidadventa into __id__producto,__id__unidad  from almacen.tbl_detproducto where trim(codigo_barra) = ''|| trim(__filtro) ||'';
	--if exists(select 1 from almacen.tbl_detproducto where id_producto=__id__producto and id_unidadventa=__id__unidad) then
	IF __id__producto IS NOT NULL THEN
		return query 
		select 
			id_producto,
			codigo,
			producto,
			marca,
			almacen,
			transito ,
			disponible ,
			precio1,
			precio2,
			precio3,
			unidad,
			id_estado ,
			servicio ,
			impuesto ,
			id_listaprecio ,
			id_unidadventa ,
			val_unidad ,
			val_minimo,
			coste ,
			id_empresa ,
			famila ,
			grupo ,
			stock_ordencompra ,
			sujet_percepcion ,
			imp_igv ,
			id_tipoventa ,
			undpred_compra ,
			gestiona_series ,
			gestiona_lotes ,
			venta_retaceo ,
			id_sucursal ,
			ctl_stock ,
			cod_barra ,
			precio4 ,
			precio5 ,
			(
		      select array_to_json(array_agg(row_to_json(d)))::text
		      from (
			select  *				 
			from  almacen.v_precios pre where pre.id_producto=list.id_producto and pre.id_unidadventa=__id__unidad			  		
		      ) d
		    ) as precios,
		    cantidad_fraccionada
		from  ALMACEN.V_PRODUCTOSALMACEN  list
		where id_producto=__id__producto and id_sucursal=__id_sucursal;
	else
		return query select 
			id_producto,
			codigo,
			producto,
			marca,
			almacen,
			transito ,
			disponible ,
			precio1,
			precio2,
			precio3,
			unidad,
			id_estado ,
			servicio ,
			impuesto ,
			id_listaprecio ,
			id_unidadventa ,
			val_unidad ,
			val_minimo,
			coste ,
			id_empresa ,
			famila ,
			grupo ,
			stock_ordencompra ,
			sujet_percepcion ,
			imp_igv ,
			id_tipoventa ,
			undpred_compra ,
			gestiona_series ,
			gestiona_lotes ,
			venta_retaceo ,
			id_sucursal ,
			ctl_stock ,
			cod_barra ,
			precio4 ,
			precio5 ,
			(
		      select array_to_json(array_agg(row_to_json(d)))::text
		      from (
			select  *				 
			from  almacen.v_precios pre where pre.id_producto=list.id_producto and pre.id_unidadventa=list.id_unidadventa		  		
		      ) d
		    ) as precios,
		cantidad_fraccionada
		from almacen.V_PRODUCTOSALMACEN  list
		where id_sucursal=__id_sucursal and  id_estado in(1,26) and  (producto || trim(COALESCE(cod_barra,'')) || codigo) ilike ( case when __op=1 then '%'||__filtro||'%' else ''||__filtro||'%' end );
	end if;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


select *from almacen.v_precios


CREATE OR REPLACE FUNCTION almacen.spiu_grupo(
    op integer,
    _codigo character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _id_estado integer)
  RETURNS text[] AS
$BODY$
declare
   cadena character varying;
   item_id   VARCHAR;
   id        INT8;
   regs	     record;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from almacen.tbl_grupo where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id_grupo::integer) INTO item_id FROM almacen.tbl_grupo ;
		IF item_id IS NULL THEN
		   item_id='1';
		ELSE
		  id = item_id::int+1;
		  item_id = id::text ;
		END IF;
		
		insert into almacen.tbl_grupo (
			id_grupo,
			descripcion_larga, 
			id_estado,
			descripcion_corta
			)
		values(
			item_id, 
			_descripcion_larga, 
			_id_estado, 
			_descripcion_corta
		) RETURNING array['0',tbl_grupo.id_grupo::text] INTO cadena;
		if not found then
			cadena:=array['504','Inconsistencia inesperada al registrar'];--||cadena; // si la operacion  ha sido efectuada correctamente
		end if;
		
	else
		cadena:=array['1'];
	    end if;
end if;
if op=2 then
	if(exists (select * from almacen.tbl_grupo where id_grupo=_codigo)) then
		update almacen.tbl_grupo set descripcion_larga = _descripcion_larga , id_estado = _id_estado, descripcion_corta = _descripcion_corta where id_grupo = _codigo;
		cadena:=array['0',_codigo::text];
	else
		cadena:=array['1'];
	end if;
end if;
return cadena;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION VENTAS.USP_PREMIO(
	op integer,--1
	_id bigint,--2
	_genera_cupon boolean,--3
	_descuenta_stock boolean,-4
	_descripcion_premio text,--5
	_glosa text ,--6
	_id_producto varchar(20),--7
	_id_unidadventa integer,--8
	_cantidad numeric(20,2),--9
	_precio numeric(20,2),--10
	_puntos numeric(20,2)--11
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
if op=1 then
	if exists(select 1 from almacen.tbl_detproducto where id_producto=_id_producto and id_unidadventa=_id_unidadventa) then
		insert into VENTAS.TBL_PREMIO(
				genera_cupon,
				descuenta_stock,
				descripcion_premio,
				glosa,
				id_producto,
				id_unidadventa,
				cantidad,
				precio ,
				puntos ,
				id_estado
		)values(
				_genera_cupon,
				_descuenta_stock,
				_descripcion_premio,
				_glosa,
				_id_producto,
				_id_unidadventa,
				_cantidad,
				_precio ,
				_puntos ,
				1
		) returning array['0','Registro generado'] into res;
		if not found then
			res:=array['501','Inconsistencia inesperada intente nuevamente'];
		end if;
	else
		res:=array['503','Verifique que existe el premio en el padro de productos'];
	end if;
end if;
if op=2 then
	if exists(select 1 from VENTAS.TBL_PREMIO where id=_id) then
		update VENTAS.TBL_PREMIO set
				genera_cupon=_genera_cupon,
				descuenta_stock=_descuenta_stock,
				descripcion_premio=_descripcion_premio,
				glosa=_glosa,
				id_producto=_id_producto,
				id_unidadventa=_id_unidadventa,
				cantidad=_cantidad,
				precio=_precio ,
				puntos=_puntos  
		where id=_id;
		res:=array['0','Registro actualizado'];
	else
		res:=array['501','Verifique que el registro este seleccionado correctamente'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';





CREATE OR REPLACE FUNCTION ventas.fn_programacion_visitas(
    op integer,
    __id_programacion bigint,
    __fecha text,
    __id_diasemana integer,
    __atendido boolean,
    __observaciones text,
    __saldo numeric,
    __abonado numeric,
    __id_estado integer,
    __id_cliente character varying,
    __id_direccion bigint,
    __id_vendedor character varying,
    __id_sucursal integer,
    __id_usuario character)
  RETURNS text[] AS
$BODY$
DECLARE 
	__id bigint;
	__res text[];
BEGIN
if op=1 then
	if exists(select 1 from ventas.tbl_direccion where id_persona=__id_cliente and id_direccion=__id_direccion)then
		if exists(select 1 from planillas.tbl_persona where id_persona=__id_vendedor) then
			select max(Id_programacion) into __id from VENTAS.TBL_PROGRAMACIONVISITA;
			if __id is null then
				__id:=1;				
			else
				__id:=__id+1;
			end if;
			INSERT INTO ventas.tbl_programacionvisita(
				id_programacion, 
				fecha, 
				id_diasemana, 
				atendido, 
				observaciones, 
				saldo, 
				abonado, 
				id_estado, 
				id_cliente, 
				id_direccion, 
				id_vendedor, 
				id_sucursal
				)
			VALUES (
				__id, 
				__fecha::Date, 
				__id_diasemana, 
				__atendido, 
				__observaciones, 
				__saldo, 
				__abonado, 
				__id_estado, 
				__id_cliente, 
				__id_direccion, 
				__id_vendedor, 
				__id_sucursal
			) returning array['0','Proceso efectuado con exito'] into  __res;
			if not found then
				__res:=array['504','No se realizo la programación Inconsistencia inesperada'];
			end if;
		else
			__res:=array['503','Verefique que el vendedor este seleccionado correctamente'];
		end if;
	else
		__Res:=array['501','Verefique que los datos del cliente esten registrados correctamente'];
	end if;
end if;
return __res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION PLANILLAS.SPI_CORRELATIVO_DOCCLIENTE(
	id integer
)
RETURNS TEXT[] AS $$
DECLARE
	correl bigint;
	corre_text text;
BEGIN
	
select max(doc_persona) into correl from planillas.tbl_persona WHERE id_tipdocidentidad=7;
if correl is null then
	correl:=1;
	corre_text:=lpad(correl::text,8,'0');
else
	correl:=correl+1;
	corre_text:=lpad(correl::text,8,'0');
end if;
return array['0',corre_text];
END;$$
LANGUAGE 'plpgsql';
 
select *from ventas.tbl_facturacionanticipo

 create or replace function ventas.spi_facturacionanticipo(
	op integer,
	_id bigint,
	_id_facturacion integer,
	_id_sucursal integer,
	_id_anticipo integer,
	_id_sucursalanticipo integer,
	_id_estado integer,
	_id_usuario varchar(5),
	_paidamount numeric(2,2)
)returns text[] as  $$
declare
	res text[];
	correl bigint;
begin
if op=1 then
	if exists(select *from ventas.tbl_Facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		if exists(select 1 from ventas.tbl_Facturacion where id_facturacion=_id_anticipo and id_sucursal=_id_sucursalanticipo) then
			select max(id) into correl from ventas.tbl_facturacionanticipo;
			if correl is null then
				correl:=1;
			else
				correl:=correl+1;
			end if;
			insert into  ventas.tbl_facturacionanticipo(
				id,
				fecha,
				id_facturacion,
				id_sucursal,
				id_anticipo,
				id_sucursalanticipo,
				id_estado,
				id_usuario_r,
				paidamount
			)values(
				correl,
				now(),
				_id_facturacion,
				_id_sucursal,
				_id_anticipo,
				_id_sucursalanticipo,
				_id_estado,
				_id_usuario::integer,
				__paidamount
			) returning array['0','Registro procesado'] into res;
			if not found then
				res:=array['501','Inconsitencia inesperada al registrar el anticipo'];
			end if;
		else
			res:=array['503','Verifique que exista los anticipos'];
		end if;
	else
		res:=array['502','Verifique que existe el comprobante'];
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacionanticipo where id=_id) then
		update ventas.tbl_facturacionanticipo set id_estado=_id_estado where id=_id;
		res:=array['0','Regisro actualizado'];
	else
		res:=array['0','Verifique que exista el registrp'];
	end if;
end if;
RETURN RES;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION VENTAS.USP_AUTORIZASOLICITUD(
	_id bigint,
	_usuario_id integer,
	_clave text,
	_tipo integer
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN

IF EXISTS(SELECT 1 FROM ventas.tbl_solicitudcomprobante WHERE id=_id) THEN
	IF EXISTS(SELECT * FROM ventas.tbl_solicitudcomprobante WHERE id=_id AND atendido is false) THEN
		if _tipo=1 then		
			
				update ventas.tbl_solicitudcomprobante 
				set 
					clave=_clave,
					aprobado=true ,
					fecha_aprobacion=now(),
					usuario_aprueba=_usuario_id,
					id_estado=1,
					atendido=true
				WHERE id=_id;
				res:=array['0','Proceso aprobado'];
			
		end if;
		if _tipo=2 then		 
				UPDATE ventas.tbl_solicitudcomprobante 
				set 
					clave='',
					aprobado=false ,
					fecha_denegacion=now(),
					usuario_aprueba=_usuario_id,
					id_estado=7,
					atendido=true
				WHERE id=_id;
			res:=array['0','Proceso denegado'];
		end if;
	ELSE
		res:=array['506','La solicitud ya se encuentra atendida'];
	END IF;
ELSE
	res:=array['505','Verifique que exista el registro'];
END IF;
return res;
END;$$
LANGUAGE 'plpgsql';

select * from ventas.spu_validateSolicitudCodigo(1,4918,1,'dsd')

select * from ventas.spu_validateSolicitudCodigo(1,4920,1,'889480')

CREATE OR REPLACE FUNCTION ventas.spu_validateSolicitudCodigo(
	_tipo integer,	
	_id_facturacion integer,
	_id_sucursal integer,
	_clave text
	
)
returns text[] as $$
declare
begin
if _tipo=1 then
	if exists(select *from ventas.tbl_solicitudcomprobante where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal and clave=_clave and anulacion=true) then
		return array['0','Autorizacion correcta'];
	else
		return array['504','Verifique que la clave este correctamente, y/o tenga una solicitudad de anulacion'];
	end if;
end if;
if _tipo=2 then
	if exists(select *from ventas.tbl_solicitudcomprobante where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal and clave=_clave and modificacion=true) then
		return array['0','Autorizacion correcta'];
	else
		return array['504','Verifique que la clave este correctamente, y/o tenga una solicitudad de modificación'];
	end if;
end if;
end;$$
language 'plpgsql';

update ventas.tbl_solicitudcomprobante set atendido=false

CREATE OR REPLACE FUNCTION ventas.usp_solicitudcomprobante(
	_usuario_solicita integer,
	_id_facturacion integer,
	_id_sucursal integer,
	_anulacion boolean,
	_modificacion boolean,
	_justificacion text
)
returns text[] as $$
declare
	res text[];
begin
 
if exists(select *from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal and id_estado=1 )then
	if _anulacion is true then
		if not exists(select 1 from ventas.tbl_solicitudcomprobante where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal and id_estado=1 and anulacion=true) then
			insert into ventas.tbl_solicitudcomprobante (
				usuario_solicita,
				id_facturacion,
				id_sucursal,
				anulacion,
				modificacion,
				justificacion,
				atendido
			)values(
				_usuario_solicita,
				_id_facturacion,
				_id_sucursal,
				true,
				false,
				_justificacion,
				false
			) returning array['0','Registro procesado'] into res;
			if not found then
				res:=array['502','Inconsitencia inesperada verifique correctamente los datos'];
			end if;
		else
			res=array['501','Ya existe una solicitud de anulación'];
		end if;
	end if;
	if _modificacion is true then
		if not exists(select * from ventas.tbl_solicitudcomprobante where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal and id_estado=1 and modificacion=true) then
			insert into ventas.tbl_solicitudcomprobante (
				usuario_solicita,
				id_facturacion,
				id_sucursal,
				anulacion,
				modificacion,
				justificacion
			)values(
				_usuario_solicita,
				_id_facturacion,
				_id_sucursal,
				false,
				true,
				_justificacion
			) returning array['0','Registro procesado'] into res;
			if not found then
				res:=array['502','Inconsitencia inesperada verifique correctamente los datos'];
			end if;
		else
			res=array['501','Ya existe una solicitud de modificación'];
		end if;
	end if;
else
	res:=array['504','El comprobante ya se encuentra anulado'];
end if;
return res;
end;$$
language 'plpgsql';

select * from planillas.v_persona  where cliente_proveedor is true and id_persona || doc_persona || nombre_razon ilike '%%' order by TRIM(id_persona) desc


CREATE OR REPLACE FUNCTION ventas.isp_visita(
    op integer,
    _id_diasemana integer,
    _id_persona character varying,
    _id_visita bigint,
    _id_estado integer,
    _id_sucursal integer)
  RETURNS text[] AS
$BODY$

DECLARE
	correlId bigint;
	res text[];
BEGIN
if op=1 then
	if not exists(select *from ventas.TBL_VISITA where id_diasemana=_id_diasemana and id_persona=_id_persona-- and id_sucursal=_id_sucursal
				 )then
		if exists(select *from ventas.TBL_DIASEMANA where id_diasemana=_id_diasemana ) then
			select max(id_visita) into correlId from ventas.tbl_visita ;
			if correlId is null then
				correlId:=1;
			else
				correlId:=correlId+1;
			end if;	
			INSERT INTO ventas.tbl_visita(
				    id_diasemana, 
				    id_persona, 
				    id_visita, 
				    id_estado, 
				    fecha, 
				    id_sucursal
				)
			VALUES (
				    _id_diasemana, 
				    _id_persona, 
				    correlId, 
				    _id_estado, 
				    now(), 
				    _id_sucursal
				)returning array['0',id_diasemana]into res;
				if not found then
					res:=array['504','Inconsitencia inesperada al asignar los dias de visitas al cliente'];
				end if;
		else
			res:=array['503','Verfique exista el dia de la semana'];
		end if;	
	else
		res:=array['504','El cliente ya tiene asiegnado el dia visita Nro.' || cast(_id_visita as text)];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.TBL_VISITA where id_diasemana=_id_diasemana and id_persona=_id_persona and id_sucursal=_id_sucursal)then
		if exists(select *from ventas.TBL_DIASEMANA where id_diasemana=_id_diasemana ) then
			 UPDATE ventas.tbl_visita
				SET  
				id_diasemana=_id_diasemana,
				id_persona=_id_persona, 
				id_estado=_id_estado, 
				--fecha=_fecha, 
				id_sucursal=_id_sucursal
			WHERE id_visita=_id_visita;
			RES:=ARRAY['0',_id_visita::TEXT];
		ELSE
			res:=array['503','Verfique exista el dia de la semana'];
		end if;
	ELSE
		res:=array['502','Seleccione correctamente el registro que desea actualizar'];
	end if;
end if;
return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from caja.fn_liquidaciones_caja_diarios() where _fecha_liquidacion=now()::date



CREATE OR REPLACE FUNCTION caja.fn_liquidaciones_caja_diarios()
  RETURNS TABLE(
	_liquidacion_id bigint, 
	_fecha_liquidacion date, 
	_dni character varying, 
	_colaborador text, 
	_apertura numeric, 
	_deposito numeric, 
	_tarjeta numeric, 
	_efectivo numeric, 
	_credito numeric, 
	_egresos numeric, 
	_imp_saldo_final numeric, 
	_imp_recibido numeric, 
	_imp_diferencia numeric, 
	_liquidado boolean, 
	_correo_liq text, 
	_caja_id integer, 
	_caja character varying,
	_id_colaborador varchar(15)
) AS
$BODY$
declare
	dat record;
begin
  CREATE TEMPORARY TABLE  tmp_liquidacion_val(
	liquidacion_id bigint,
	fecha_liquidacion date,
	dni varchar(12),
	colaborador text,
	APERTURA NUMERIC(20,2),
	DEPOSITO numeric(20,2),
	TARJETA numeric(20,2),
	EFECTIVO numeric(20,2),
	CREDITO numeric(20,2),
	EGRESOS numeric(20,2),
	correo_liq text,
	caja_id integer
  )ON COMMIT DROP;
  for dat in select * from caja.v_liquidacion_diaria_cajas loop
	if not exists(select *from tmp_liquidacion_val where liquidacion_id=dat.liquidacion_id) then
		insert into tmp_liquidacion_val(
			liquidacion_id,
			fecha_liquidacion ,
			dni,
			colaborador ,
			APERTURA,
			DEPOSITO,
			TARJETA,
			EFECTIVO,
			CREDITO,
			EGRESOS,
			correo_liq,
			caja_id
		)values(
			dat.liquidacion_id,
			dat.fecha_liquidacion ,
			dat.dni,
			dat.colaborador ,
			dat.apertura,
			case when dat.formapago='DEPOSITO' then dat.importe else 0.00 end ,
			case when dat.formapago='TARJETA' then dat.importe else 0.00 end,
			case when dat.formapago='EFECTIVO' then dat.importe else 0.00 end,
			dat.imp_credito,--case when dat.formapago='CREDITO' then dat.importe else 0.00 end,
			case when dat.formapago='EGRESOS' then abs(dat.importe) else 0.00 end,
			dat.correo_liq,
			dat.id_caja
		);
	else
	update tmp_liquidacion_val set 
			DEPOSITO=case when dat.formapago='DEPOSITO' then dat.importe else deposito end,--case when COALESCE(DEPOSITO,0)=0 then (case when dat.formapago='DEPOSITO' then dat.importe  end ) end,
			TARJETA=case when dat.formapago='TARJETA' then dat.importe else TARJETA end,--case when COALESCE(TARJETA,0)=0 then (case when dat.formapago='TARJETA' then dat.importe  end ) end,
			EFECTIVO=case when dat.formapago='EFECTIVO' then dat.importe else EFECTIVO end,--case when COALESCE(EFECTIVO,0)=0 then (case when dat.formapago='EFECTIVO' then dat.importe  end ) end,
			CREDITO=case when dat.formapago='CREDITO' then dat.importe else CREDITO end,--case when COALESCE(CREDITO,0)=0 then (case when dat.formapago='CREDITO' then dat.importe  end ) end,
			EGRESOS=case when dat.formapago='EGRESOS' then abs(dat.importe) else EGRESOS end--case when COALESCE(EGRESOS,0)=0 then (case when dat.formapago='EGRESOS' then dat.importe end ) end
		where liquidacion_id=dat.liquidacion_id;
	end if;
  end loop;
  return query select 
		v.liquidacion_id ,
		v.fecha_liquidacion ,
		v.dni ,
		v.colaborador ,
		v.APERTURA,
		v.DEPOSITO ,
		v.TARJETA ,
		v.EFECTIVO-COALESCE(v.APERTURA,0) ,
		v.CREDITO ,
		v.EGRESOS ,
		tc.imp_saldo_final,
		tc.imp_recibido,
		tc.imp_diferencia,
		tc.liquidado,
		v.correo_liq,
		v.caja_id,
		cb.descripcion as caja,
		tc.id_colaborador
  from tmp_liquidacion_val V
	inner join  planillas.tbl_turnocolaborador tc on v.liquidacion_id =tc.liquidacion_id
	inner join  caja.tbl_cajabanco cb on cb.id_cajabanco=v.caja_id;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

select *from planillas.tbl_turnocolaborador

/*
CREATE OR REPLACE FUNCTION caja.fn_liquidaciones_caja_diarios()
  RETURNS TABLE(
	_liquidacion_id bigint, 
	_fecha_liquidacion date, 
	_dni character varying, 
	_colaborador text, 
	_apertura numeric(20,2),
	_deposito numeric, 
	_tarjeta numeric, 
	_efectivo numeric, 
	_credito numeric, 
	_egresos numeric, 
	_imp_saldo_final numeric, 
	_imp_recibido numeric, 
	_imp_diferencia numeric, 
	_liquidado boolean,
        _correo_liq text,
	_caja_id integer,
	_caja varchar(100)
) AS
$BODY$
declare
	dat record;
begin
  CREATE TEMPORARY TABLE  tmp_liquidacion_val(
	liquidacion_id bigint,
	fecha_liquidacion date,
	dni varchar(12),
	colaborador text,
	APERTURA NUMERIC(20,2),
	DEPOSITO numeric(20,2),
	TARJETA numeric(20,2),
	EFECTIVO numeric(20,2),
	CREDITO numeric(20,2),
	EGRESOS numeric(20,2),
	correo_liq text,
	caja_id integer
  )ON COMMIT DROP;
  for dat in select * from caja.v_liquidacion_diaria_cajas loop
	if not exists(select *from tmp_liquidacion_val where liquidacion_id=dat.liquidacion_id) then
		insert into tmp_liquidacion_val(
			liquidacion_id,
			fecha_liquidacion ,
			dni,
			colaborador ,
			APERTURA,
			DEPOSITO,
			TARJETA,
			EFECTIVO,
			CREDITO,
			EGRESOS,
			correo_liq,
			caja_id
		)values(
			dat.liquidacion_id,
			dat.fecha_liquidacion ,
			dat.dni,
			dat.colaborador ,
			dat.apertura,
			case when dat.formapago='DEPOSITO' then dat.importe else 0.00 end ,
			case when dat.formapago='TARJETA' then dat.importe else 0.00 end,
			case when dat.formapago='EFECTIVO' then dat.importe else 0.00 end,
			dat.imp_credito,--case when dat.formapago='CREDITO' then dat.importe else 0.00 end,
			case when dat.formapago='EGRESOS' then abs(dat.importe) else 0.00 end,
			dat.correo_liq,
			dat.id_caja
		);
	else
	update tmp_liquidacion_val set 
			DEPOSITO=case when dat.formapago='DEPOSITO' then dat.importe else deposito end,--case when COALESCE(DEPOSITO,0)=0 then (case when dat.formapago='DEPOSITO' then dat.importe  end ) end,
			TARJETA=case when dat.formapago='TARJETA' then dat.importe else TARJETA end,--case when COALESCE(TARJETA,0)=0 then (case when dat.formapago='TARJETA' then dat.importe  end ) end,
			EFECTIVO=case when dat.formapago='EFECTIVO' then dat.importe else EFECTIVO end,--case when COALESCE(EFECTIVO,0)=0 then (case when dat.formapago='EFECTIVO' then dat.importe  end ) end,
			CREDITO=case when dat.formapago='CREDITO' then dat.importe else CREDITO end,--case when COALESCE(CREDITO,0)=0 then (case when dat.formapago='CREDITO' then dat.importe  end ) end,
			EGRESOS=case when dat.formapago='EGRESOS' then abs(dat.importe) else EGRESOS end--case when COALESCE(EGRESOS,0)=0 then (case when dat.formapago='EGRESOS' then dat.importe end ) end
		where liquidacion_id=dat.liquidacion_id;
	end if;
  end loop;
  return query select 
		v.liquidacion_id ,
		v.fecha_liquidacion ,
		v.dni ,
		v.colaborador ,
		v.APERTURA,
		v.DEPOSITO ,
		v.TARJETA ,
		v.EFECTIVO ,
		v.CREDITO ,
		v.EGRESOS ,
		tc.imp_saldo_final,
		tc.imp_recibido,
		tc.imp_diferencia,
		tc.liquidado,
		v.correo_liq,
		v.caja_id,
		cb.descripcion as caja
  from tmp_liquidacion_val V
	inner join  planillas.tbl_turnocolaborador tc on v.liquidacion_id =tc.liquidacion_id
	inner join  caja.tbl_cajabanco cb on cb.id_cajabanco=v.caja_id;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
*/


select * from caja.fn_liquidaciones_caja_diarios()where _fecha_liquidacion='15/11/2019'

select *from caja.tbl_movcaja where fecha_mov::date=now()::date

CREATE OR REPLACE FUNCTION caja.spiu_caja(
    op integer,
    codigo character varying,
    _descripcion character varying,
    _venta_contado boolean,
    _cobranzas boolean,
    _pagos boolean,
    _venta_credito boolean,
    _id_moneda integer,
    _id_sucursal integer,
    _id_estado integer,
    _correo_liq text
)
  RETURNS text[] AS $$
declare
   correl   integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from caja.tbl_cajabanco where descripcion = _descripcion and id_sucursal = _id_sucursal)) then
		SELECT MAX(id_cajabanco) INTO correl FROM caja.tbl_cajabanco;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into caja.tbl_cajabanco (
			id_cajabanco,
			descripcion, 
			venta_contado,
			cobranzas,
			pagos,
			venta_credito,
			caja_banco,
			id_moneda,
			id_sucursal,
			id_estado,
			correo_liq
			)
		values(
			correl,
			_descripcion, 
			_venta_contado,
			_cobranzas,
			_pagos,
			_venta_credito,
			false,
			_id_moneda,
			_id_sucursal,
			_id_estado,
			_correo_liq

		) RETURNING array['0', tbl_cajabanco.id_cajabanco::text] INTO res;

		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
	else
		res:=array['1'];
	end if;
end if;
if op=2 then
	if(exists (select * from caja.tbl_cajabanco where id_cajabanco = codigo::integer)) then
		update caja.tbl_cajabanco set 
			descripcion = _descripcion, 
			venta_contado = _venta_contado,
			cobranzas = _cobranzas,
			pagos = _pagos,
			venta_credito = _venta_credito,
			id_moneda = _id_moneda,
			id_sucursal = _id_sucursal,
			id_estado = _id_estado,
			correo_liq=_correo_liq
		where id_cajabanco = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION ventas.list_ranking_ventas_producto(
	f1 text,
	f2 text
)
returns table(
	id_producto varchar(5),
	codigo char(30),
	producto varchar(200),
	id_familia char(5),
	familia varchar(100),
	cantidad numeric(20,4),
	importe numeric(20,4)
	
) as $$
declare
begin
return query SELECT p.id_producto,p.codigo,p.descripcion_larga as producto,fa.id_familia,fa.descripcion_larga as familia,sum(df.cantidad) as cantidad,sum(df.importe) as importe FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.id_producto=df.id_producto
INNER JOIN ALMACEN.TBL_FAMILIA fa ON fa.id_familia=p.id_familia
where df.id_estado=1 and f.id_estado=1 and f.fecha_venta::date between f1::date and f2::date
group by  fa.id_familia,p.codigo,fa.descripcion_larga,p.id_producto,p.descripcion_larga
order by sum(df.cantidad) desc,fa.id_familia::integer asc;
end;$$
language 'plpgsql';

select *from almacen.tbl_producto

CREATE OR REPLACE FUNCTION ventas.fn_listfamiliaventa(
	anio integer,
	mes integer
)
RETURNS TABLE (
	id_familia char(5),
	familia varchar(100),
	importe numeric(20,4)
) AS  $$
declare
begin
return query SELECT fa.id_familia,fa.descripcion_larga as familia,sum(df.importe) as importe FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.id_producto=df.id_producto
INNER JOIN ALMACEN.TBL_FAMILIA fa ON fa.id_familia=p.id_familia
where df.id_estado=1 and f.id_estado=1 and date_part('year',fecha_venta)=anio and date_part('month',fecha_venta)=mes 
group by  fa.id_familia,fa.descripcion_larga
order by fa.id_familia::integer asc;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION ventas.fn_listfamiliaventaVendedor(
	anio integer,
	mes integer
)
RETURNS TABLE (
	id_familia char(5),
	familia varchar(100),
	importe numeric(20,4)
) AS  $$
declare
begin
return query 
SELECT 
	fa.id_familia,
	fa.descripcion_larga as familia,
	sum(df.importe) as importe 
FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.id_producto=df.id_producto
INNER JOIN ALMACEN.TBL_FAMILIA fa ON fa.id_familia=p.id_familia
LEFT JOIN (
	SELECT FROM VENTAS.TBL_METAVENTA mv
	INNER JOIN VENTAS.TBL_METAFAMILIA MF ON MV.ID=MF.ID_METAVENTA
) Z
where df.id_estado=1 and f.id_estado=1 and date_part('year',fecha_venta)=anio and date_part('month',fecha_venta)=mes 
group by  fa.id_familia,fa.descripcion_larga
order by fa.id_familia::integer asc;
end;$$
language 'plpgsql';

select *from ventas.list_metavendedorfamilia(5,6,'3');
select *from   contabilidad.tbl_procesocontable

create or replace  function ventas.list_metavendedorfamilia(
	_id_año integer,
	_id_mes integer,
	_id_vendedor varchar(15)
)
returns table(
	id bigint,
	metavendedor_id bigint,
	id_familia char(5),
	familia varchar(100),
	imp_meta numeric(20,4),
	imp_venta numeric(20,4),
	id_vendedor varchar(15),	
	status boolean,	
	op integer
) as $$
declare
	anio integer;
begin
	select descripcion::integer into anio from  contabilidad.tbl_procesocontable pc where  pc.id_proceso=_id_año;

return query select 
	COALESCE(y.id,0) as id,
	COALESCE(y.metavendedor_id,0) as  metavendedor_id , 
	m.id_familia,
	m.familia,
	COALESCE(y.imp_meta,0) as imp_meta,
	m.importe as imp_venta,
	COALESCE(m.id_vendedor,'0') as id_vendedor,	
	COALESCE(y.status,false) as status,
	COALESCE(y.op,1) as op 
 from (
	SELECT 
		F.ID_FAMILIA,
		F.DESCRIPCION_LARGA AS FAMILIA ,
		COALESCE(z.importe,0) as importe,
		z.id_vendedor
	FROM ALMACEN.TBL_FAMILIA F
	LEFT JOIN (
		SELECT
			fa.id_familia,
			fa.descripcion_larga as familia,
			sum(df.importe) as importe,
			f.id_vendedor
		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.id_producto=df.id_producto
		INNER JOIN ALMACEN.TBL_FAMILIA fa ON fa.id_familia=p.id_familia 
		where date_part('year',f.fecha_venta)=anio and date_part('month',f.fecha_venta)=_id_mes and f.id_vendedor=_id_vendedor and f.id_estado=1 and df.id_estado=1
		group by fa.id_familia,fa.descripcion_larga,f.id_vendedor
	) Z ON z.id_familia=f.id_familia
) m
left join (
	SELECT 
		mvf.id,
		mvf.metavendedor_id,
		mvf.familia_id,
		mvf.imp_meta,
		mv.id_vendedor,
		true as status ,
		2 op
	FROM VENTAS.TBL_METAVENDEDORFAMILIA mvf
	inner join VENTAS.TBL_METAVENDEDOR mv on mv.id=mvf.metavendedor_id
	inner join ventas.tbl_metaventa mm on mm.id=mv.id_metaventa
	where mm.id_anio=_id_año and mm.id_mes=_id_mes and mv.id_vendedor=_id_vendedor
) y on y.familia_id=m.id_familia and y.id_vendedor=m.id_vendedor
order by m.id_familia::integer asc;
end;$$
language 'plpgsql';


select *from  VENTAS.TBL_METAVENDEDOR mv

select * from ventas.USP_METAVENTA(1,0,7,2019,'TRUE','FALSE','FALSE','1    ')

select *from VENTAS.TBL_METAVENDEDOR mv


SELECT vend.id_persona,vend.nombre_razon as vendedor,sum(f.imp_total) as importe FROM VENTAS.TBL_FACTURACION F
inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
left join (
	select *from VENTAS.TBL_METAVENDEDOR mv
) x on x.id_vendedor=f.id_vendedor
group by vend.id_persona,vend.nombre_razon 



select *from ventas.list_vendedor_ventas(2019,6);




CREATE OR REPLACE FUNCTION ventas.list_vendedor_ventas(
	anio integer,
	mes integer
)
RETURNS TABLE (
	id_persona varchar(15),
	vendedor varchar(100),
	imp_meta numeric(20,4),
	imp_venta numeric(20,4),
	id bigint,
	id_metaventa bigint
) AS  $$
declare
begin
return query 
SELECT 
	vend.id_persona,
	vend.nombre_razon as vendedor,
	COALESCE(x.imp_meta,0) as imp_meta,
	sum(f.imp_total) as importe ,
	COALESCE(x.id,0)::bigint as id,
	COALESCE(x.id_metaventa,0) as  id_metaventa
FROM VENTAS.TBL_FACTURACION F
inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
left join (
	select mv.id_vendedor,mv.id_metaventa,mv.imp_meta,mv.id_estado,mv.id from VENTAS.TBL_METAVENDEDOR mv
) x on x.id_vendedor=f.id_vendedor
where   f.id_estado=1 and date_part('year',fecha_venta)=anio and date_part('month',fecha_venta)=mes 
group by vend.id_persona,vend.nombre_razon ,x.imp_meta,x.id,
	x.id_metaventa;

end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION VENTAS.LIST_METASVEDEDORES()
RETURNS TABLE(
	id bigint
) AS $$
DECLARE
	dat record;
BEGIN
for dat in SELECT 
	vend.id_persona,
	vend.nombre_razon as vendedor,
	sum(f.imp_total) as importe 
FROM VENTAS.TBL_FACTURACION F
inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
group by vend.id_persona,vend.nombre_razon loop
	if not exists(select *from VENTAS.TBL_METAVENDEDOR where id_vendedor=dat.id_persona) then
		INSERT INTO  VENTAS.TBL_METAVENDEDOR(				
				id_vendedor,
				id_metaventa,
				imp_meta,
				fecha_reg,
				id_usuario,
				id_estado
			)VALUES(				
				_id_vendedor,
				_id_metaventa,
				_imp_meta,
				NOW(),
				_id_usuario,
				_id_estado
			);
	end if;
end loop;
END;$$
LANGUAGE'plpgsql';

CREATE OR REPLACE FUNCTION VENTAS.USP_METAVENTA(
	op integer,
	_id bigint ,	
	_id_mes integer,
	_id_anio integer,
	_familia boolean,
	_proveedor boolean,
	_item boolean,	
	_id_usuario char(5)	
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
if op=1 then
	if not exists(select 1 from VENTAS.TBL_METAVENTA where id_anio=_id_anio and id_mes=_id_mes and id_estado=1) then
		INSERT INTO VENTAS.TBL_METAVENTA(
			 	
			id_mes,
			id_anio,
			familia,
			proveedor,
			item,
			fecha_reg,
			id_usuario
		)values(
			 
			_id_mes,
			_id_anio,
			_familia,
			_proveedor,
			_item,
			now(),
			_id_usuario::integer
		) returning array['0','Registro procesado',TBL_METAVENTA.id::text] into res;
		if not found then
			res:=array['503','Verifique ocurrio una incosistencia'];
		end if;
	else
		res:=array['504','Ya existe creado en periodo indicado'];
	end if;
end if;
if op=2 then
	if exists(select 1 from VENTAS.TBL_METAVENTA where id=_id) then
		UPDATE VENTAS.TBL_METAVENTA SET 
			id_mes=_id_mes ,
			id_anio=_id_anio ,
			familia=_familia,
			proveedor=_proveedor ,
			item=_item,
			fecha_act=now(),
			id_usuarioact=_id_usuario::integer
		where id=_id;
		res:=array['0','Registro actualizado',_id::text];
	else
		res:=array['50','Verifique que el registro exista'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';


select * from ventas.USP_METAFAMILIA(1,0,'16',0,'0.00','1    ',1)

CREATE OR REPLACE  FUNCTION VENTAS.USP_METAFAMILIA(
	op integer,
	_id bigint  ,
	_id_familia char(5),
	_id_metaventa bigint,
	_meta_porcent numeric(20,4),	
	_id_usuario char(5),
	_id_estado integer
) RETURNS TEXT[] AS $$
DECLARE
res text[];
BEGIN
if op=1 then
	if exists(  select *from VENTAS.TBL_METAVENTA where id=_id_metaventa ) then
		if exists(select * from  ALMACEN.TBL_FAMILIA where trim(id_familia)=trim(_id_familia)) then
			INSERT INTO VENTAS.TBL_METAFAMILIA(
				 
				id_familia,
				id_metaventa ,
				meta_porcent,
				id_usuario,
				id_estado
			)values(
				 
				_id_familia,
				_id_metaventa ,
				_meta_porcent,
				_id_usuario::integer,
				_id_estado
			) returning array['0','Registro procesado',id::text] into res;
			if not found then
				res:=array['503','Verifique ocurrio una incosistencia'];
			end if;
		else
			res:=array['501','Verifique que exista la familia'];
		end if;
	else
		res:=array['502','Verifique que exista la meta de venta '];
	end if;
	
end if;
if op=2 then
	if exists(select 1 from VENTAS.TBL_METAFAMILIA where id=_id) then
		UPDATE VENTAS.TBL_METAFAMILIA set 
			 
			id_familia=_id_familia ,
			id_metaventa=_id_metaventa ,
			meta_porcent=_meta_porcent ,
			fecha_act =NOW(),
			id_usuarioact =_id_usuario::integer,	
			id_estado =_id_estado
		where id=_id;
		res:=array['0','Registro actualizado',_id::text];
	else
		res:=array['502','Verifique que el registro exista'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';


select *from VENTAS.TBL_METAVENDEDOR


CREATE OR REPLACE FUNCTION VENTAS.USP_METAVENDEDOR(
	op integer,
	_id bigint ,
	_id_vendedor varchar(15),
	_id_metaventa bigint,
	_imp_meta numeric(20,4),
	_id_usuario char(5),
	_id_estado integer
)RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
if op=1 then
	if exists( select 1 from VENTAS.TBL_METAVENTA where id=_id_metaventa ) then
		if exists(select 1 from planillas.tbl_persona where id_persona=_id_vendedor) then
			INSERT INTO  VENTAS.TBL_METAVENDEDOR(				 
				id_vendedor,
				id_metaventa,
				imp_meta,
				fecha_reg,
				id_usuario,
				id_estado
			)VALUES(				 
				_id_vendedor,
				_id_metaventa,
				_imp_meta,
				NOW(),
				_id_usuario::integer,
				_id_estado
			)RETURNING ARRAY['0','Registro procesado',_id::text] INTO RES;
			if not found then
				res:=array['503','Verifique ocurrio una incosistencia'];
			end if;	
		else
			res:=array['501','Verifique que exista el vendedor'];
		end if;
	else
		res:=array['502','Verifique que exista la meta de venta'];
	end if;
end if;
if op=2 then
	if exists(select 1 from  VENTAS.TBL_METAVENDEDOR where id=_id) then
		UPDATE  VENTAS.TBL_METAVENDEDOR SET
			id_vendedor =_id_vendedor,
			id_metaventa=_id_metaventa,
			imp_meta=_imp_meta ,
			fecha_act =NOW(),
			id_usuarioact=_id_usuario::integer,	
			id_estado=_id_estado
		where id=_id;
		res:=array['0','Registro actualizado',_id::text];
	else
		res:=array['502','Verifique que el registro exista'];
	end if;
end if;
return res;
END;$$
language 'plpgsql';

select * from ventas.usp_metavendedorfamilia(2,13,12,'15   ','0.0000','1    ',1)
select * from ventas.usp_metavendedorfamilia(2,13,12,'15   ','200','1    ',1)

CREATE OR REPLACE FUNCTION VENTAS.USP_METAVENDEDORFAMILIA(
	op integer,
	_id bigint ,
	_metavendedor_id bigint,
	_familia_id char(5),
	_imp_meta numeric(20,4),
	_id_usuario char(5),	
	_id_estado integer
) returns text[] as $$
declare
	res text[];
begin
if op=1 then
	if exists(select 1 from VENTAS.TBL_METAVENDEDOR where id=_metavendedor_id) then
		if exists(select 1 from almacen.tbl_familia where id_familia=_familia_id) then
			INSERT INTO VENTAS.TBL_METAVENDEDORFAMILIA(
				metavendedor_id ,
				familia_id,
				imp_meta ,
				fecha_reg ,
				id_usuario ,
				id_estado 
			)VALUES(
				_metavendedor_id ,
				_familia_id,
				_imp_meta ,
				now(),
				_id_usuario::integer ,
				_id_estado 
			) returning array['0','Registro procesado exitosamente'] into res;
			if not found then
				res:=array['503','Verifique ocurrio una incosistencia'];
			end if;	
		else
			res:=array['506','Verifique que exista la familia seleccionada'];
		end if;
	else
		res:=array['504','Verifique el vendedor este asignado a una meta de venta'];
	end if;
end if;
if op=2 then
	if exists(select * from  VENTAS.TBL_METAVENDEDORFAMILIA where id=_id) then
		update VENTAS.TBL_METAVENDEDORFAMILIA  set			
			imp_meta=_imp_meta ,
			fecha_act =now(),
			id_usuarioact=_id_usuario::integer
		where id=_id;
		res:=array['0','Registro actualizado'];
	else
		res:=array['505','Seleccione correctamente el registro para realizar este proceso'];
	end if;
end if;
return res;
end;$$
language 'plpgsql';

SELECT *FROM ventas.list_report_metas_ventas(1,5,6,'15/06/2019') where id_familia='1'

select * from ventas.list_report_metas_ventas(1,2019,6,'15/07/2019')where id_familia::integer in ('1','3','4','5','6','7','10','14','15','16')

select date_part('day',now())::integer;

select date_part('day name', current_date);

select to_char(current_date,'D');
 select to_char('27/07/2019'::date,'D');

select to_char(now(), 'day');

create or replace function ventas.list_report_metas_ventas(
	_tipo integer,
	_id_año integer,
	_id_mes integer,
	_fecha text
	
)
returns table(
	id bigint ,
	id_familia text,
	familia text,
	id_vendedor text,
	vendedor text,
	diaria numeric(20,4),
	semana numeric(20,4),
	meta_mes numeric(20,4),
	imp_debealafecha numeric(20,4),--cuento deberia ir a la fecha de consulta
	imp_avance numeric(20,4),-- importe de cuanto va en los avances a la fecha
	porcent_avance numeric(20,4),--porcentaje de avance a la fecha
	imp_promedio numeric(20,4),--importe promedio en el avance a la fecha actual
	imp_diferencia numeric(20,4),--cuando es la difernecia lo que deberia aver avanzado menos el avance realizado
	situacion text,--POSITIVO, NEGATIVO
	imp_avanceproyectado numeric(20,4), --importe del avance proyectado segun el importe promedio
	porcent_proyectado numeric(20,4),
	total_dias integer,
	dias_trab integer,
	porcent_reque numeric(20,4)
) as $$
declare
	_familia record;
	_vendedor record;
	__number_day numeric(20,2);
	__fecha_format text;
	__año_format text;
	__porcent_reque numeric(20,4);
begin
	__number_day:=0;
	__porcent_reque=0;
	select descripcion into __año_format from contabilidad.tbl_procesocontable where id_proceso=_id_año;
	for i in 1..date_part('day',_fecha::date)::integer loop
		if i<10 then
			if _id_mes<9 then
				__fecha_format:='0'||i::text || '/'||'0'||_id_mes::integer ||'/' || __año_format;
			else
				__fecha_format:='0'||i::text || '/'||_id_mes ||'/'||  __año_format;
			end if;
		else
			if _id_mes<9 then
				__fecha_format:=i::text || '/'||'0'||_id_mes::integer ||'/'|| __año_format;
			else
				__fecha_format:=i::text || '/'||_id_mes||'/' ||  __año_format;
			end if;
		end if;	
		RAISE NOTICE '__fecha_format(%)', __fecha_format ;
		if (to_char(__fecha_format::date,'D')::integer<>1) then
			__number_day:=__number_day+1;
		end if;
	end loop;
	RAISE NOTICE '__number_day(%)', __number_day ;
	__porcent_reque:=((__number_day/26)*100);
	RAISE NOTICE '__porcent_reque(%)', __porcent_reque ;
	create temporary table t_data(
		id bigint primary key GENERATED ALWAYS AS IDENTITY,
		id_familia text,
		familia text,
		id_vendedor text,
		vendedor text,
		diaria numeric(20,4),
		semana numeric(20,4),
		meta_mes numeric(20,4),
		imp_debealafecha numeric(20,4),--cuento deberia ir a la fecha de consulta
		imp_avance numeric(20,4),-- importe de cuanto va en los avances a la fecha
		porcent_avance numeric(20,4),--porcentaje de avance a la fecha
		imp_promedio numeric(20,4),--importe promedio en el avance a la fecha actual
		imp_diferencia numeric(20,4),--cuando es la difernecia lo que deberia aver avanzado menos el avance realizado
		situacion text,--POSITIVO, NEGATIVO
		imp_avanceproyectado numeric(20,4), --importe del avance proyectado segun el importe promedio
		porcent_proyectado numeric(20,4)
	) on commit drop;
	for _vendedor in  select 
			mvv.id as id_metaventavendedor, 
			vend.id_persona as id_vendedor,
			vend.nombre_razon as vendedor  from ventas.tbl_metaventa mv
			inner join ventas.tbl_metavendedor mvv on mv.id=mvv.id_metaventa
			inner join planillas.tbl_persona vend on vend.id_persona=mvv.id_vendedor
			where mv.id_anio=_id_año and mv.id_mes=_id_mes
			  loop
		for  _familia in   select fa.id_familia,fa.descripcion_larga as familia,mvf.imp_meta from ventas.tbl_metaventa mv
			inner join ventas.tbl_metavendedor mvv on mv.id=mvv.id_metaventa
			inner join planillas.tbl_persona vend on vend.id_persona=mvv.id_vendedor
			inner join ventas.tbl_metavendedorfamilia mvf on mvv.id=mvf.metavendedor_id
			inner join almacen.tbl_familia fa on fa.id_familia=mvf.familia_id
			where mvf.metavendedor_id=_vendedor.id_metaventavendedor  loop
			insert into t_data(id_familia,familia,id_vendedor,vendedor,diaria,semana,meta_mes)values(_familia.id_familia,_familia.familia,_vendedor.id_vendedor,_vendedor.vendedor,0,0,_familia.imp_meta);
		end loop;
	end loop;
/*select 
	vend.id_persona,
	vend.nombre_razon as vendedor ,
	case when mvv.imp_meta>0 then mvv.imp_meta/26 else 0 end as diaria,
	(case when mvv.imp_meta>0 then mvv.imp_meta/26 else 0 end)*6 as semanal,
	mvv.imp_meta as meta_mes
from ventas.tbl_metaventa mv
inner join ventas.tbl_metavendedor mvv on mv.id=mvv.id_metaventa
inner join planillas.tbl_persona vend on vend.id_persona=mvv.id_vendedor
where mv.id=18
order by mv.id desc;*/
RETURN QUERY 
SELECT 
t.id ,
t.id_familia,
t.familia ,
t.id_vendedor,
t.vendedor,
case when t.meta_mes>0 then t.meta_mes/26 else 0 end diaria,
(case when t.meta_mes>0 then t.meta_mes/26 else 0 end)*6 semana,
t.meta_mes,
(case when t.meta_mes>0 then t.meta_mes/26 else 0 end)*__number_day imp_debealafecha,
x.imp_venta as imp_avance ,
(case when t.meta_mes>0then x.imp_venta/t.meta_mes else 0 end)*100 as porcent_avance,
--(case when ((case when t.meta_mes>0 then t.meta_mes/26 else 0 end)*__number_day)>0 then (x.imp_venta/((case when t.meta_mes>0 then t.meta_mes/26 else 0 end)*__number_day)) else 0 end)*100  porcent_avance ,
(x.imp_venta/__number_day) imp_promedio,
(x.imp_venta-(case when t.meta_mes>0 then t.meta_mes/26 else 0 end)*__number_day) imp_diferencia ,
case when ((case when t.meta_mes>0then x.imp_venta/t.meta_mes else 0 end)*100 )>=__porcent_reque then 'POSITIVO' ELSE 'NEGATIVO' END situacion,
((x.imp_venta/__number_day)*26) imp_avanceproyectado ,
(case when t.meta_mes>0 then (((x.imp_venta/__number_day)*26)/t.meta_mes) else 0 end)*100 porcent_proyectado,
26 total_dias,
__number_day::integer as __number_day,
__porcent_reque
FROM t_data t
left join (select p.id_familia,f.id_vendedor,sum(df.importe) as imp_venta from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto
	inner join contabilidad.tbl_procesocontable pc on pc.descripcion::integer=date_part('year',f.fecha_venta)
	where df.id_estado=1 and f.id_estado=1 and f.fecha_venta::Date<=_fecha::date and pc.id_proceso=_id_año and date_part('month',f.fecha_venta)=_id_mes
	group by p.id_familia,f.id_vendedor
	) x on x.id_familia=t.id_familia and x.id_vendedor=t.id_vendedor ;
end;$$
language 'plpgsql';

select *from contabilidad.tbl_procesocontable

select *from ventas.tbl_metaventa mv

select *from ventas.tbl_metavendedorfamilia

select *from ventas.tbl_metavendedor

--inner join VENTAS.TBL_METAVENDEDORFAMILIA mvf on mvv.id=mvf.metavendedor_id

select * from ventas.usp_metavendedorfamilia(2,2,11,'3    ','250','1    ',1)

CREATE OR REPLACE FUNCTION almacen.fn_stok_real(IN _id_producto character varying)
  RETURNS TABLE(
	product_id character varying, 
	code text, 
	id_familia text, 
	familia text, 
	producto text, 
	stock_text character varying, 
	unidades numeric, 
	costo_unitario numeric, 
	total_valorizado numeric, 
	id_almacen integer, 
	id_empresa integer
) AS
$BODY$
DECLARE
	rec_stock record;--almacena el listado de stock de  todos los productos
	rec_unidades record;--almacena el listado de unidades de medida por producto
	_nro_packs numeric(20,4);--cantidad de packas al realizar un division del stock entre el valor de la unidad
	_saldo numeric(20,4);--almacena el saldo de stock una vez dividido entre un valor de unidades
	_num_unidades integer;--detalla la cantidad de unidades de medida de un producto
	_nom_unidad text;--nombre de la unidad de medida
	n_unidades 	numeric(20,6);
	stock_text text;
	rec_valunidades record;
BEGIN
_nro_packs:=0;
CREATE TEMPORARY TABLE TEMP_PRODUCTO(
	product_id varchar(30),
	codigo text,
	id_familia text,
	familia text,
	producto text,
	stock varchar(200),
	num_unidades numeric(20,2),
	costo_promedio numeric(20,2),
	valorizado numeric(20,2),
	almacen_id integer,
	empresa_id integer
)on commit drop;

CREATE TEMPORARY TABLE TEM_REGUND(
	id_producto varchar(30),
	stock text,
	id_unidad integer,
	val_unidad integer
)ON COMMIT DROP;
stock_text:='';
for rec_stock in select 
	ex.id_producto,
	p.codigo,
	ex.id_unidadventa,
	stock_fisico as stock,
	p.descripcion_larga as producto,
	costo_promedio,
	f.descripcion_larga as familia,
	f.id_familia,
	stock_fisico*costo_promedio as valorizado ,
	ex.id_almacen,
	suc.id_empresa
from almacen.tbl_existencia ex 
inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=ex.id_producto
inner join almacen.tbl_familia f on f.id_familia=p.id_familia
inner join almacen.tbl_almacen alm on alm.id_almacen=ex.id_almacen
inner join common.tbl_sucursal suc on suc.id_sucursal=alm.id_sucursal
 where  dp.unidad_inventario is true and p.id_producto=1 --and stock_fisico>0 
 order by p.id_familia --and ex.id_producto=_id_producto 
	loop
	n_unidades=rec_stock.stock;
	stock_text:='';
	delete from TEM_REGUND;
	for rec_unidades in select dp.id_unidadventa,dp.id_producto,dp.val_unidad from almacen.tbl_detproducto dp 
		where dp.id_producto=rec_stock.id_producto and dp.id_estado=1
		order by dp.val_unidad desc loop
			if n_unidades>0 then
				if rec_unidades.val_unidad>0 then 
				_nro_packs:=trunc(n_unidades/rec_unidades.val_unidad);	
				end if;			 
				_saldo:=n_unidades%rec_unidades.val_unidad;
				RAISE NOTICE '_nro_packs(%)', _nro_packs ||'  residuo: ' || _saldo::text ||  '  Stock :'  || n_unidades::text ||   '  val_unidad : ' || rec_unidades.val_unidad::text  || '  _nro_packs : ' || _nro_packs::text  || '  id_unidadventa:' || rec_unidades.id_unidadventa::text;
				if _nro_packs>0 then
					--if not exists(select 1 from TEM_REGUND where id_unidad not in(rec_unidades.id_unidadventa)) then
						INSERT INTO TEM_REGUND(id_producto,stock,id_unidad,val_unidad)values(rec_stock.id_producto,_nro_packs,rec_unidades.id_unidadventa,rec_unidades.val_unidad);
					--end if;			
				end if;
			end if; 
		 n_unidades:= _saldo;
	end loop;
	for rec_valunidades in select id_producto,stock,id_unidad,und.desc_corta as unidad,r.val_unidad  from TEM_REGUND r inner join almacen.tbl_unidad und on und.id_unidadventa=r.id_unidad loop 
		stock_text:=stock_text || ' ' || (rec_valunidades.stock::NUMERIC(20,0))::TEXT || ' ' || rec_valunidades.unidad || '('||rec_valunidades.val_unidad::text ||') ';
	end loop;
	RAISE NOTICE 'stock_text(%)', stock_text; 
	INSERT INTO TEMP_PRODUCTO(product_id,codigo,id_familia,familia,producto,stock,num_unidades,costo_promedio,valorizado,almacen_id,empresa_id)values(rec_stock.id_producto,rec_stock.id_producto,rec_stock.id_familia,rec_stock.familia,rec_stock.producto,stock_text,rec_stock.stock,rec_stock.costo_promedio,rec_stock.valorizado,rec_stock.id_almacen,rec_stock.id_empresa);
end loop;
return QUERY SELECT *FROM TEMP_PRODUCTO t   ;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;





CREATE OR REPLACE VIEW almacen.v_serie_producto_movimientos 
AS 
 SELECT DISTINCT btrim(p.codigo::text) AS codigo,
    p.descripcion_larga AS producto,
    ''::text AS doc_compra,
    ''::text AS fec_compra,
    ''::text AS proveedor,
    COALESCE(sp.nro_serie, ''::character varying) AS nro_serie,
    ''::text AS doc_venta,
    ''::text AS fecha_venta,
    ''::text AS cliente,
    alm.descalmacen AS almacen,
    es.des_estado AS estado,
    sp.id_estado,
    alm.id_almacen,
    sp.id_producto,
    sp.id_serie
   FROM almacen.tbl_serieproducto sp
     JOIN common.tbl_estado es ON es.id_estado = sp.id_estado
     JOIN almacen.tbl_almacen alm ON alm.id_almacen = sp.id_almacen
     JOIN almacen.tbl_producto p ON p.id_producto::text = sp.id_producto::text;

select *from COMMON.TBL_AUDITORIA  limit  5

select *from ALMACEN.fn_series_movimiento()

CREATE OR REPLACE FUNCTION ALMACEN.fn_series_movimiento()
returns table(
	codigo text,
	producto varchar(200),
	doc_compra text,
	fec_compra text,
	proveedor text,
	nro_Serie text,
	doc_venta text,
	fecha_venta text,
	cliente text,
	almacen varchar(100),
	estado varchar(20),
	id_estado integer,
	id_almacen integer,
	id_producto varchar(20),
	id_Serie bigint
) as $$
declare
	dat record;
begin
create temporary table temp_serie(
	_codigo text,
	_producto varchar(200),
	_doc_compra text,
	_fec_compra text,
	_proveedor text,
	_nro_Serie text,
	_doc_venta text,
	_fecha_venta text,
	_cliente text,
	_almacen varchar(100),
	_estado varchar(20),
	_id_estado integer,
	_id_almacen integer,
	_id_producto varchar(20),
	_id_Serie bigint	
)on commit drop;

insert into temp_serie(_codigo,_producto,_nro_serie,_almacen,_estado,_id_estado,_id_almacen,_id_producto,_id_serie) 
SELECT  trim(p.codigo::text) AS codigo,
    p.descripcion_larga AS producto,    
    COALESCE(sp.nro_serie, ''::character varying) AS nro_serie,
    alm.descalmacen AS almacen,
    es.des_estado AS estado,
    sp.id_estado,
    alm.id_almacen,
    sp.id_producto,
    sp.id_serie
   FROM almacen.tbl_serieproducto sp
     JOIN common.tbl_estado es ON es.id_estado = sp.id_estado
     JOIN almacen.tbl_almacen alm ON alm.id_almacen = sp.id_almacen
     JOIN almacen.tbl_producto p ON p.id_producto::text = sp.id_producto::text ;


for dat in select sc.id_Serie,c.serie,nro_doc_compra,fec_documento as fecha_compra,prov.nombre_razon as proveedor from almacen.tbl_seriecompra sc 
	   inner join compras.tbl_compra c on c.id__compra=sc.id__compra and c.id_sucursalcompra=sc.id_sucursalcompra
	   inner join planillas.tbl_persona prov on prov.id_persona=c.id_proveedor loop
	update temp_serie set _doc_compra =dat.serie || '-' ||dat.nro_doc_compra,_fec_compra=to_char(dat.fecha_compra,'dd/MM/yyyy'),_proveedor=dat.proveedor where _id_Serie=dat.id_Serie;
end loop;
for dat in select sc.id_Serie,c.serie_facturacion,numdoc_facturacion,c.fecha_venta as fecha_venta,prov.nombre_razon as cliente from almacen.tbl_serieventa sc 
	   inner join ventas.tbl_Facturacion c on c.id_facturacion=sc.id_facturacion and c.id_sucursal=sc.id_sucursal
	   inner join planillas.tbl_persona prov on prov.id_persona=c.id_cliente loop
	update temp_serie set _doc_venta =dat.serie_facturacion || '-' ||dat.numdoc_facturacion,_fecha_venta=to_char(dat.fecha_venta,'dd/MM/yyyy'),_cliente=dat.cliente where _id_Serie=dat.id_Serie;
end loop;
return query 
select 
	_codigo ,
	_producto ,
	COALESCE(_doc_compra,'') _doc_compra,
	COALESCE(_fec_compra,'') _fec_compra,
	COALESCE(_proveedor,'') _proveedor,
	_nro_Serie ,
	COALESCE(_doc_venta,'') _doc_venta,
	COALESCE(_fecha_venta,'') ,
	COALESCE(_cliente,'') _cliente,
	_almacen ,
	_estado ,
	_id_estado ,
	_id_almacen ,
	_id_producto,
	_id_Serie 
 from temp_serie order by _fec_compra::date asc;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION almacen.fn_get_productos_ventas(
    _id_facturacion integer,
    _id_sucursal integer)
  RETURNS text AS
$BODY$
DECLARE
	_data record;
	_res text;
	ind integer;
BEGIN
	ind:=0;
	/*for _data in select CASE
            WHEN btrim(df.id_producto::text) = 'TXT-01'::text THEN df.descripcion_linea
            ELSE ((split_part(p.descripcion_larga::text, ','::text, 1) || '
'::text) || COALESCE(almacen.fn_getseriesventas(df.id_facturacion::bigint, df.id_sucursal, df.id_producto, df.id_unidadventa), ''::text)) || COALESCE(
            CASE
                WHEN df.ancho > 0::numeric AND df.largo > 0::numeric THEN split_part(df.descripcion_linea, ','::text, 2)
                ELSE NULL::text
            END, ''::text)
        END ||
        CASE
            WHEN df.precio = 0::numeric THEN '
TRANSFERENCIA GRATUITA'::text
            ELSE ''::text
        END AS producto,df.id_facturacion,df.id_sucursal from ventas.tbl_detfacturacion df	
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto
	where df.id_facturacion=_id_facturacion and df.id_sucursal=_id_sucursal
	--group by p.descripcion_larga ,df.id_facturacion,df.id_sucursal 
	loop
		if ind=0 then
			_res:='<br/>- '||     _data.producto;
		else
			_res:=_res || E'\n'  || '<br/>- '|| _data.producto ;
		end if;
		
		ind:=ind+1;
	end loop;
return _res || '<br/>';*/
return  replace(replace(replace(replace(replace(replace((select array_to_json(array_agg(row_to_json(d)))::text as item
      from (
        select trunc(df.cantidad,2) as cantidad, CASE
            WHEN btrim(df.id_producto::text) = 'TXT-01'::text THEN df.descripcion_linea
            ELSE ((split_part(p.descripcion_larga::text, ','::text, 1) || ''::text) || COALESCE(almacen.fn_getseriesventas(df.id_facturacion::bigint, df.id_sucursal, df.id_producto, df.id_unidadventa), ''::text)) || COALESCE(
            CASE
                WHEN df.ancho > 0::numeric AND df.largo > 0::numeric THEN split_part(df.descripcion_linea, ','::text, 2)
                ELSE NULL::text
            END, ''::text)
        END   AS producto from ventas.tbl_detfacturacion df	
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto
	where df.id_facturacion=_id_facturacion and df.id_sucursal=_id_sucursal
      ) d),'"cantidad":','<br/>'),'"producto":',''),',"',' '),'"},{','. '),'{',''),'"}','');
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 
 select array_to_json(array_agg(row_to_json(d)))::text as item
      from (
        select trunc(df.cantidad,2) as cantidad, CASE
            WHEN btrim(df.id_producto::text) = 'TXT-01'::text THEN df.descripcion_linea
            ELSE ((split_part(p.descripcion_larga::text, ','::text, 1) || ''::text) || COALESCE(almacen.fn_getseriesventas(df.id_facturacion::bigint, df.id_sucursal, df.id_producto, df.id_unidadventa), ''::text)) || COALESCE(
            CASE
                WHEN df.ancho > 0::numeric AND df.largo > 0::numeric THEN split_part(df.descripcion_linea, ','::text, 2)
                ELSE NULL::text
            END, ''::text)
        END ||
        CASE
            WHEN df.precio = 0::numeric THEN 'TRANSFERENCIA GRATUITA'::text
            ELSE ''::text
        END AS producto from ventas.tbl_detfacturacion df	
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto
	--where df.id_facturacion=_id_facturacion and df.id_sucursal=_id_sucursal
      ) d



CREATE OR REPLACE FUNCTION public.trimestre(date)
  RETURNS integer AS
$BODY$
DECLARE
mes int :=cast(to_char($1,'q') as integer);
BEGIN

IF mes in (1,2) THEN 
	RETURN 1;
END IF;
IF mes in (3,4) THEN 
	RETURN 2;
END IF;
IF mes in (5,6) THEN 
	RETURN 3;
END IF;
IF mes in (7,8) THEN 
	RETURN 4;
END IF;
IF mes in (9,10) THEN 
	RETURN 5;
END IF;
IF mes in (11,12) THEN 
	RETURN 6;
END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

create or replace function almacen.fn_actualiza_serie_producto(
	_id_serie bigint,
	_id_almacen integer,
	_id_estado integer,
	_nro_serie varchar(100)
)
returns text[] as $$
declare
	res text[];
begin
if(length(trim(_nro_serie))=0) then 
	return array['501','Ingrese correctamente el Nro de Serie'];
end if;
if exists(select 1 from almacen.tbl_serieproducto where id_serie=_id_serie) then
	update  almacen.tbl_serieproducto set nro_serie=_nro_serie,id_estado=_id_estado,id_almacen=_id_almacen where id_serie=_id_serie;
	res:=array['0',_id_serie::text,'Serie actualizada'];
else
	res:=array['504','Verifique que exista el registro'];
end if;
return res;
end;$$
language 'plpgsql';


create or replace function compras.fn_actualizar_correlativo_compra(
	_id__compra bigint,
	_id__sucucrsal integer,
	_correlativo integer
)returns text[] as $$
declare
	res  text[];
begin
if exists(select 1 from compras.tbl_compra where id__compra=_id__compra and id_sucursalcompra=_id__sucucrsal) then
	update compras.tbl_compra set id_compra=_correlativo where id__compra=_id__compra and id_sucursalcompra=_id__sucucrsal;
	res:=array['0','Registro Actualizando'];
else
	res:=array['501','Verifique el registro exista'];
end if;
return res;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION creditos.getfunccalmora(
_id_cuota integer,
_fecha  text
)
  RETURNS text[] AS
$BODY$
declare
	data record;
	mora numeric ;--double precision ;
	saldo numeric(30,14) ;
	return_mora numeric;
	res text[];
begin
mora:=0.00;
select --generaIntereses(x.saldo,convertirTemToTead(2), CAST( now() AS DATE)-CAST(fec_vencimiento AS DATE)) 
case when (CAST( _fecha AS DATE)-(CAST(fec_vencimiento AS DATE))-8)>0 then
((x.saldo*0.1)/100)*(CAST( _fecha AS DATE)-(CAST(fec_vencimiento AS DATE))-8)
else 0 end
into mora from
(select 
cc.id_cuotas,
cc.nro_cuota,
CC.imp_cuota,
fec_vencimiento::date, 
trunc(CC.imp_cuota-COALESCE(imp_pago,0),2) as saldo
 from creditos.tbl_cuota cc
left join (
	select  ccc.id_cuotas,ccc.id_credito,ccc.id_sucursal_credito,sum(imp_movimiento) as imp_pago from creditos.tbl_cuota ccc 
	inner join creditos.tbl_detpagocuota dpc on ccc.id_cuotas=dpc.id_cuotas and ccc.id_credito=dpc.id_credito and  ccc.id_sucursal_credito=dpc.id_sucursal_credito
	inner join caja.tbl_movcaja mov on  (mov.id_movimcaja=dpc.id_movimcaja and  mov.id_sucursal=dpc.id_sucursal)
	where mov.id_estado=1
	group by ccc.id_credito,ccc.id_sucursal_credito,ccc.id_cuotas
) pagc on pagc.id_credito=cc.id_credito and  pagc.id_sucursal_credito=cc.id_sucursal_credito and pagc.id_cuotas=cc.id_cuotas
) x
where trunc(x.saldo,2)>0 and x.fec_vencimiento<=_fecha::date and x.nro_cuota<>0 and x.ID_CUOTAs=_id_cuota;


	if mora is not Null then
		return_mora:= MORA;
	else
		return array['0','0'];
	end if;
return array['0',return_mora::text];	
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION creditos.getfunccalmora(
_id_cuota integer 
)
  RETURNS text AS
$BODY$
declare
	data record;
	mora numeric ;--double precision ;
	saldo numeric(30,14) ;
	return_mora numeric;
	res text[];
begin
mora:=0.00;
select --generaIntereses(x.saldo,convertirTemToTead(2), CAST( now() AS DATE)-CAST(fec_vencimiento AS DATE)) 
case when (CAST( now() AS DATE)-(CAST(fec_vencimiento AS DATE))-8)>0 then
((x.saldo*0.1)/100)*(CAST( now() AS DATE)-(CAST(fec_vencimiento AS DATE))-8)
else 0 end
into mora from
(select 
cc.id_cuotas,
cc.nro_cuota,
CC.imp_cuota,
fec_vencimiento::date, 
trunc(CC.imp_cuota-COALESCE(imp_pago,0),2) as saldo
 from creditos.tbl_cuota cc
left join (
	select  ccc.id_cuotas,ccc.id_credito,ccc.id_sucursal_credito,sum(imp_movimiento) as imp_pago from creditos.tbl_cuota ccc 
	inner join creditos.tbl_detpagocuota dpc on ccc.id_cuotas=dpc.id_cuotas and ccc.id_credito=dpc.id_credito and  ccc.id_sucursal_credito=dpc.id_sucursal_credito
	inner join caja.tbl_movcaja mov on  (mov.id_movimcaja=dpc.id_movimcaja and  mov.id_sucursal=dpc.id_sucursal)
	where mov.id_estado=1
	group by ccc.id_credito,ccc.id_sucursal_credito,ccc.id_cuotas
) pagc on pagc.id_credito=cc.id_credito and  pagc.id_sucursal_credito=cc.id_sucursal_credito and pagc.id_cuotas=cc.id_cuotas
) x
where trunc(x.saldo,2)>0 and x.fec_vencimiento<=now()::date and x.nro_cuota<>0 and x.ID_CUOTAs=_id_cuota;


	if mora is not Null then
		return_mora:= MORA;
	else
		return '0';
	end if;
return return_mora::text;	
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from creditos.getfunccalmora(69,'2020-05-04 08:59:38.062')

create or replace function almacen.fn_validad_unidad()
returns b

CREATE OR REPLACE FUNCTION common.fn_departamentos(
	op integer,
	_id_dpto varchar(8)	,
	_departamento varchar(30),
	_id_pais integer
)
returns text[] as $$
declare
	id integer;
	res text[];
begin
if op=1 then
	if not exists(select 1 from common.tbl_dpto where departamento=_departamento and id_pais=_id_pais) then
		select max(id_dpto::integer) into id from common.tbl_dpto;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		insert into common.tbl_dpto(id_dpto,departamento,id_pais)values(id::text,_departamento,_id_pais) returning array['0',id_dpto::text] into res;
		--res:=array['0','Departamento registrado'];
		if not found then
			res:=array['501','Inconsistencia inesperada intente nuevamente'];
		end if;
	else
		res:=array['502','Ya existe un registro con los mismos datos'];
	end if;
end if;
if op=2 then
	if exists(select 1 from common.tbl_dpto where id_dpto=_id_dpto) then
		update common.tbl_dpto set  departamento=_departamento,id_pais=_id_pais where id_dpto=_id_dpto;
		res:=array['0',_id_dpto::text];
	end if;
end if;
return res;
end;$$
language 'plpgsql';

select *from common.tbl_provincia


CREATE OR REPLACE FUNCTION common.fn_provincia(
	op integer,
	_id_provincia varchar(8)	,
	_provincia varchar(30),
	_id_dpto varchar(8)
)
returns text[] as $$
declare
	id integer;
	res text[];
begin
if op=1 then
	if not exists(select 1 from common.tbl_provincia where provincia=_provincia and id_dpto=_id_dpto) then
		select max(id_provincia::integer) into id from common.tbl_provincia;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		insert into common.tbl_provincia(id_provincia,provincia,id_dpto)values(id::text,_provincia,_id_dpto) returning array['0',id_provincia::text] into res;
		--res:=array['0','Departamento registrado'];
		if not found then
			res:=array['501','Inconsistencia inesperada intente nuevamente'];
		end if;
	else
		res:=array['502','Ya existe un registro con los mismos datos'];
	end if;
end if;
if op=2 then
	if exists(select 1 from common.tbl_provincia where id_provincia=_id_provincia) then
		update common.tbl_provincia set  provincia=_provincia,id_dpto=_id_dpto where id_provincia=_id_provincia;
		res:=array['0',_id_provincia::text];
	end if;
end if;
return res;
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION ventas.fn_cambiar_cliente_facturacion(
	_id_facturacion integer,
	_id_sucursal integer,
	_id_cliente varchar(15),
	_id_direccion bigint,
	_dni_cliente text,
	_nomape_cliente text,
	_direccion_cliente text
)
returns text[] as $$
declare
	res text[];
	
begin
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		update ventas.tbl_facturacion 
		set 
			id_cliente=_id_cliente,
			id_direccion=_id_direccion,
			dni_cliente=_dni_cliente,
			nomape_cliente=_nomape_cliente,
			direccion_cliente=_direccion_cliente
		where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
		res:=array['0','Registro actualizado correctamente'];
	else
		res:=array['501','Verifique que el registro este seleccionado correctamente'];
	end if;
return res;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION ventas.usp_status_resumen(
	_resumen_id bigint,
	_resumen_ticket character varying,
	_resumen_enviado_status integer,
	_resumen_enviado_archivo character varying,
	_message_sunat text,
	_code_sunat text)
    RETURNS text[]
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
	res text[];
begin
if exists(select * from ventas.tbl_resumen where resumen_id=_resumen_id)then
	if exists(select 1 from ventas.tbl_resumen where resumen_id=_resumen_id and resumen_enviado_status!=1)then
		update ventas.tbl_resumen set  
			resumen_ticket=_resumen_ticket,
			resumen_enviado_status =_resumen_enviado_status ,
			resumen_enviado_archivo =_resumen_enviado_archivo,
			message_sunat=_message_sunat,
			code_sunat=_code_sunat
		where resumen_id=_resumen_id ;
		res=array['0','Registro procesado'];
	else
		res=array['501','El resumen ya esta aceptado'];
	end if;
else
	res=array['502','Verifique que exista el registro'];
end if;
return res;	
end;
$BODY$;

CREATE OR REPLACE FUNCTION ventas.list_ventas_vendedor_resumen(
    IN fecha_desde text,
    IN fecha_hasta text)
  RETURNS TABLE(vendedor_id character varying, vendedor character varying, familia_id character, familia character varying, codigo text, producto character varying, unidad character varying, cantidad numeric, importe numeric, covertura bigint) AS
$BODY$
declare
begin


return query SELECT 
	vend.id_persona as id_vendedor,
	vend.nombre_razon as vendedor,
	fa.id_familia,
	fa.descripcion_larga as familia,
	trim(p.codigo)::text as codigo,
	p.descripcion_larga as producto,
	und.desc_corta as unidad,
	sum(x.cantidad) as cantidad,
	sum(df.importe) - COALESCE(nc.importe,0) as importe,
	--count(f.id_cliente) as covertura,
	z.covertura
 FROM ventas.tbl_facturacion f
inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
inner join almacen.tbl_detproducto dp on dp.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=dp.id_producto
inner join almacen.tbl_familia fa on fa.id_familia=p.id_familia
JOIN LATERAL almacen.fn_stock(df.id_producto, df.id_unidadventa, df.id_almacen, df.cantidad) x(product_id, unit_id, val_unit, stock, cantidad) ON x.product_id::text = dp.id_producto::text
inner join almacen.tbl_unidad und on und.id_unidadventa=x.unit_id
inner join (
	select df.id_producto,f.id_vendedor,count(id_cliente) as covertura from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
	where f.fecha_venta::Date>=fecha_desde::date and f.fecha_venta::Date<=fecha_hasta::date and f.id_estado=1 and df.id_estado=1 AND 
	f.nota_credito is false and f.id_estado=1
	group by df.id_producto,f.id_vendedor
	order by f.id_vendedor desc,df.id_producto
) z on z.id_producto=p.id_producto and f.id_vendedor=z.id_vendedor
     LEFT JOIN (
     select  n.id_facturacion ,n.id_sucursal,dfn.id_producto,dfn.id_unidadventa,dfn.cantidad,dfn.importe from  ventas.tbl_facturacion n
     inner join ventas.tbl_detfacturacion dfn on n.id_facturacion=dfn.id_facturacion and n.id_sucursal=dfn.id_sucursal 
     where n.fecha_venta::Date>=fecha_desde::date and n.fecha_venta::Date<=fecha_hasta::date and n.id_estado=1 and dfn.id_estado=1 AND 
	n.nota_credito is true
     ) nc ON nc.id_facturacion = f.id_facturacionref AND f.id_sucursalref = nc.id_sucursal and nc.id_producto=df.id_producto and nc.id_unidadventa=df.id_unidadventa

	WHERE f.fecha_venta::Date>=fecha_desde::date and f.fecha_venta::Date<=fecha_hasta::date and f.id_estado=1 and df.id_estado=1 AND 
	f.nota_credito is false and f.id_estado=1 /*and NOT ((f.id_facturacion::text || f.id_sucursal::text) || btrim(df.id_producto::text) IN ( SELECT (ff.id_facturacionref::text || ff.id_sucursalref::text) || btrim(dff.id_producto::text)
           FROM ventas.tbl_facturacion ff
             JOIN ventas.tbl_detfacturacion dff ON ff.id_facturacion = dff.id_facturacion AND ff.id_sucursal = dff.id_sucursal
          WHERE ff.nota_credito = true)
          )*/
 
group by vend.id_persona ,
	vend.nombre_razon,
	fa.id_familia,
	fa.descripcion_larga,
	p.codigo,
	p.descripcion_larga ,
	und.desc_corta,
	df.id_producto,
	z.covertura,nc.importe
order by fa.id_familia,vend.id_persona,df.id_producto;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


select *from ventas.list_ventas_diario_resumen('01/07/2020','31/07/2020');

CREATE OR REPLACE FUNCTION ventas.list_ventas_diario_resumen(
    IN fecha_desde text,
    IN fecha_hasta text)
  RETURNS TABLE(	
	familia_id character, 
	familia character varying, 
	codigo text, 
	producto character varying, 
	unidad character varying, 
	cantidad numeric
) AS
$BODY$
declare
begin


return query SELECT 	 
	fa.id_familia,
	fa.descripcion_larga as familia,
	trim(p.codigo)::text as codigo,
	p.descripcion_larga as producto,
	und.desc_corta as unidad,
	sum(x.cantidad) as cantidad	 	
 FROM ventas.tbl_facturacion f
inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
inner join almacen.tbl_detproducto dp on dp.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=dp.id_producto
inner join almacen.tbl_familia fa on fa.id_familia=p.id_familia
JOIN LATERAL almacen.fn_stock(df.id_producto, df.id_unidadventa, df.id_almacen, df.cantidad) x(product_id, unit_id, val_unit, stock, cantidad) ON x.product_id::text = dp.id_producto::text
inner join almacen.tbl_unidad und on und.id_unidadventa=x.unit_id
WHERE f.fecha_venta::Date>=fecha_desde::date and f.fecha_venta::Date<=fecha_hasta::date and f.id_estado=1 and df.id_estado=1 AND 
f.nota_credito is false and f.id_estado=1 /*and NOT ((f.id_facturacion::text || f.id_sucursal::text) || btrim(df.id_producto::text) IN ( SELECT (ff.id_facturacionref::text || ff.id_sucursalref::text) || btrim(dff.id_producto::text)
   FROM ventas.tbl_facturacion ff
     JOIN ventas.tbl_detfacturacion dff ON ff.id_facturacion = dff.id_facturacion AND ff.id_sucursal = dff.id_sucursal
  WHERE ff.nota_credito = true)
  )*/
 
group by 
	fa.id_familia,
	fa.descripcion_larga,
	p.codigo,
	p.descripcion_larga ,
	und.desc_corta,
	df.id_producto	
order by fa.id_familia,df.id_producto;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

select *from ventas.v_registroventas

create or replace function ventas.fn_list_estadistico_ventas()
returns table(
	tipoventa_id integer ,
	tipoventa text,
	ene numeric(20,4),
	feb numeric(20,4),
	mar numeric(20,4),
	abr numeric(20,4),
	may numeric(20,4),
	jun numeric(20,4),
	jul numeric(20,4),
	ago numeric(20,4),
	sep numeric(20,4),
	oct numeric(20,4),
	nov numeric(20,4),
	dic numeric(20,4),
	total numeric(20,4) 
) as $$
declare
	rec_data record;
	temp_year integer;
	tipy_id integer;
begin
	create temporary table temp_data(
	_tipoventa_id integer ,
	_tipoventa text,
	_ene numeric(20,4),
	_feb numeric(20,4),
	_mar numeric(20,4),
	_abr numeric(20,4),
	_may numeric(20,4),
	_jun numeric(20,4),
	_jul numeric(20,4),
	_ago numeric(20,4),
	_sep numeric(20,4),
	_oct numeric(20,4),
	_nov numeric(20,4),
	_dic numeric(20,4),
	_total numeric(20,4) 
) on commit drop;
	for rec_data in select f.id_tipoventa,descripcion_larga tipoventa,sum(imp_total) as total,date_part('month',fecha_venta) as mes,date_part('year',fecha_venta) anio from ventas.tbl_facturacion f
		inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa
		group by f.id_tipoventa,tv.descripcion_larga,date_part('month',fecha_venta),date_part('year',fecha_venta)  
		order by date_part('year',fecha_venta),date_part('month',fecha_venta)
		loop
		temp_year:=rec_data.anio;
		tipy_id:=rec_data.id_tipoventa;
		IF NOT EXISTS(select 1 from  temp_data where _tipoventa_id=rec_data.id_tipoventa)  THEN
		insert into temp_data(
			_tipoventa_id ,
			_tipoventa ,
			_ene ,
			_feb ,
			_mar ,
			_abr ,
			_may ,
			_jun ,
			_jul ,
			_ago ,
			_sep ,
			_oct ,
			_nov ,
			_dic ,
			_total )
			values(
				rec_data.id_tipoventa,	
				rec_data.tipoventa,	
				CASE WHEN  rec_data.mes=1 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=2 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=3 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=4 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=5 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=6 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=7 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=8 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=9 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=10 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=11 THEN rec_data.total ELSE 0 END, 
				CASE WHEN  rec_data.mes=12 THEN rec_data.total ELSE 0 END,
				0
			);
		else
			update temp_data set
				_ene=_ene+CASE WHEN  rec_data.mes=1 THEN rec_data.total ELSE 0 END, 
				_feb=_feb+CASE WHEN  rec_data.mes=2 THEN rec_data.total ELSE 0 END, 
				_mar=_mar+CASE WHEN  rec_data.mes=3 THEN rec_data.total ELSE 0 END, 
				_abr=_abr+CASE WHEN  rec_data.mes=4 THEN rec_data.total ELSE 0 END, 
				_may=_may+CASE WHEN  rec_data.mes=5 THEN rec_data.total ELSE 0 END, 
				_jun=_jun+CASE WHEN  rec_data.mes=6 THEN rec_data.total ELSE 0 END, 
				_jul=_jul+CASE WHEN  rec_data.mes=7 THEN rec_data.total ELSE 0 END, 
				_ago=_Ago+CASE WHEN  rec_data.mes=8 THEN rec_data.total ELSE 0 END, 
				_Sep=_sep+CASE WHEN  rec_data.mes=9 THEN rec_data.total ELSE 0 END, 
				_oct=_oct+CASE WHEN  rec_data.mes=10 THEN rec_data.total ELSE 0 END, 
				_nov=_nov+CASE WHEN  rec_data.mes=11 THEN rec_data.total ELSE 0 END, 
				_dic=_dic+CASE WHEN  rec_data.mes=12 THEN rec_data.total ELSE 0 END
			where _tipoventa_id=rec_data.id_tipoventa;
		END IF;
		
	end loop;
RETURN QUERY SELECT *FROM temp_data;
end;$$
language 'plpgsql'; 

select *from common.tbl_tipoventa 


CREATE OR REPLACE FUNCTION ALMACEN.FN_CORREGIR_INVENTARIO_INICIAL(
	_id_producto varchar(20),
	_id_unidadventa integer,
	_id_almacen integer,
	_stock_inicial numeric(20,4),
	_costo_inicial numeric(20,4),
	_unidad_inventario boolean
)
RETURNS TEXT[] AS  $$
DECLARE
	res text[];
BEGIN
	update almacen.tbl_existencia 
		set 
			consto_inicial=_costo_inicial,
			stock_inicial=_stock_inicial 
		where 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen;
	update almacen.tbl_detproducto set unidad_inventario=_unidad_inventario 
	where 
		id_producto=_id_producto and id_unidadventa=_id_unidadventa ;
	res:=array['0','Registro actualizado'];
	return res;
END;$$
LANGUAGE 'plpgsql';


SELECT *FROM  almacen.tbl_existencia 

select *from ventas.list_ventas_vendedor_resumido('01/01/2019','01/04/2019')

CREATE OR REPLACE FUNCTION ventas.list_ventas_vendedor_resumido(
	_f_desde text,
	_f_hasta text
)
returns table(
	vendedor_id varchar(15),
	vendedor text,
	unidades numeric(20,4),
	importe numeric(20,4),
	porcentaje numeric(20,4),
	utilidad numeric(20,4)
) as $$
declare
begin
	return query SELECT 
		P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		M.DESCRIPCION_LARGA AS MARCA,
		U.DESC_LARGA AS UNIDAD,
		DP.VAL_UNIDAD AS VALOR,
		SUM(DF.CANTIDAD)-COALESCE(Z.CANTIDAD,0) AS CANTIDAD,
		sum(DF.importe)/sum(df.cantidad) AS PRECIO,
		SUM(DF.importe)-COALESCE(Z.IMPORTE,0) AS TOTAL_VENTA,
		dp.coste AS precio_compra,
		dp.coste*SUM(DF.CANTIDAD) as total_compra

		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
		INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=F.ID_VENDEDOR
		INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
		INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
		INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
		INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)  
		INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL
		LEFT JOIN (SELECT 
				FF.ID_FACTURACIONREF AS ID_FACTURACION,
				FF.ID_SUCURSALREF AS ID_SUCURSAL,
				DFF.ID_PRODUCTO,DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO AS _ID_PRODUCTO ,
				SUM(DFF.CANTIDAD) AS CANTIDAD,
				SUM(DFF.importe)  AS IMPORTE				
			FROM VENTAS.TBL_FACTURACION FF 
			INNER JOIN VENTAS.TBL_DETFACTURACION DFF ON FF.ID_FACTURACION =DFF.ID_FACTURACION AND FF.ID_SUCURSAL=DFF.ID_SUCURSAL
			WHERE FF.NOTA_CREDITO=TRUE
			GROUP BY 
			        FF.ID_FACTURACIONREF,
				FF.ID_SUCURSALREF,
				DFF.ID_PRODUCTO,
				DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO 
			) Z ON Z.ID_FACTURACION=F.ID_FACTURACION AND Z.ID_SUCURSAL=F.ID_SUCURSAL AND DF.ID_PRODUCTO=Z._ID_PRODUCTO AND Z.ID_UNIDADVENTA=DF.ID_UNIDADVENTA	 
		where f.id_estado=1 and df.id_estado=1   AND 
		F.FECHA_VENTA::DATE>=_f_desde::DATE AND F.FECHA_VENTA::DATE<=_f_hasta::DATE AND F.NOTA_CREDITO=FALSE
		--AND F.ID_FACTURACION::TEXT || F.ID_SUCURSAL::TEXT NOT IN (SELECT FF.ID_FACTURACIONREF::TEXT || FF.ID_SUCURSALREF::TEXT FROM VENTAS.TBL_FACTURACION FF WHERE FF.NOTA_CREDITO=TRUE and ff.id_estado=1 )
		GROUP BY P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA ,
		Fa.DESCRIPCION_LARGA ,
		M.DESCRIPCION_LARGA ,
		U.DESC_LARGA ,
		DP.VAL_UNIDAD,
		dp.id_producto,
		dp.id_unidadventa,
		dp.coste,
		z.cantidad,z.importe
		ORDER BY Fa.DESCRIPCION_LARGA;
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION ventas.rpt_ventasporcliente(
    refcursor,
    fec_desde text,
    fec_hasta text,
    _id_cliente text,
    op integer,
    _id_empresa integer,
    text)
  RETURNS refcursor AS
$BODY$
declare
	cad text;
begin
if op=1 then -- todas las ventas todos los clientes
	cad:='select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,''"'','''')) as cliente, 
	    sum(tbl_facturacion.valor_venta) as valor_venta,
	    sum(tbl_facturacion.imp_igv) as imp_igv,
	    sum(tbl_facturacion.imp_total) as imp_total
	   from  ventas.tbl_facturacion
	   JOIN common.tbl_comprobante ON tbl_facturacion.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_facturacion.id_direccion = tbl_direccion.id_direccion  AND tbl_facturacion.id_cliente = tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_facturacion.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_facturacion.id_sucursal) where tbl_facturacion.id_estado=1 and suc.id_empresa='''|| _id_empresa ||'''  and tbl_facturacion.id_comprobante in(2,3)   
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon 
	    ';
	
	 open $1 for execute cad;
end if;
if op=2 then -- todas las ventas por cliente
	 open $1 for select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,'"','')) as cliente,  
	    sum(tbl_facturacion.valor_venta) as valor_venta,
	    sum(tbl_facturacion.imp_igv) as imp_igv,
	    sum(tbl_facturacion.imp_total) as imp_total
	   from  ventas.tbl_facturacion
	   JOIN common.tbl_comprobante ON tbl_facturacion.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_facturacion.id_direccion = tbl_direccion.id_direccion  AND tbl_facturacion.id_cliente = tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_facturacion.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_facturacion.id_sucursal)
	   where tbl_facturacion.id_cliente=_id_cliente and   tbl_facturacion.id_estado=1 and suc.id_empresa=_id_empresa
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	  ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;

if op=3 then -- todos los clientes y las ventas entre vechas
	 open $1 for SELECT * FROM ( select 
	    tbl_persona.doc_persona,
	    trim(REPLACE(tbl_persona.nombre_razon,'"','')) as cliente,  
	    sum(tbl_facturacion.valor_venta) as valor_venta,
	    sum(tbl_facturacion.imp_igv) as imp_igv,
	    sum(tbl_facturacion.imp_total) as imp_total
	   from  ventas.tbl_facturacion
	   JOIN common.tbl_comprobante ON tbl_facturacion.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_facturacion.id_direccion = tbl_direccion.id_direccion  AND tbl_facturacion.id_cliente = tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_facturacion.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_facturacion.id_sucursal)
	  where tbl_facturacion.fecha_venta>=cast(fec_desde as date) and tbl_facturacion.fecha_venta<=cast(fec_hasta as date)  and tbl_facturacion.id_comprobante in(2,3)   
	  and   tbl_facturacion.id_estado=1 and suc.id_empresa=_id_empresa
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	   
	) X  ORDER BY TRIM(X.cliente) asc;
end if;

if op=4 then -- ventas entre fechas y por cliente
	 open $1 for select 
	    tbl_persona.doc_persona,
	   trim(REPLACE(tbl_persona.nombre_razon,'"','')) as cliente,    
	    sum(tbl_facturacion.valor_venta) as valor_venta,
	    sum(tbl_facturacion.imp_igv) as imp_igv,
	    sum(tbl_facturacion.imp_total) as imp_total
	   from  ventas.tbl_facturacion
	   JOIN common.tbl_comprobante ON tbl_facturacion.id_comprobante = tbl_comprobante.id_comprobante
	   JOIN ventas.tbl_direccion ON tbl_facturacion.id_direccion = tbl_direccion.id_direccion  AND tbl_facturacion.id_cliente = tbl_direccion.id_persona
	   JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	   inner join common.tbl_estado on (tbl_estado.id_estado=tbl_facturacion.id_estado)
	   INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=tbl_facturacion.id_sucursal)
	   where tbl_facturacion.id_cliente=_id_cliente and  
	   tbl_facturacion.fecha_venta>=cast(fec_desde as date) and tbl_facturacion.fecha_venta<=cast(fec_hasta as date) 
	   and   tbl_facturacion.id_estado=1 and suc.id_empresa=_id_empresa
	   group by tbl_persona.doc_persona,tbl_persona.nombre_razon
	   
	  ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;
--
if op=5 then -- todo los clienes de forma detallada que no incluyenn los productos
	open $1 for select *from ventas.v_listar_cabecera_facturacion where id_empresa=_id_empresa order by cliente;
end if;

if op=6 then -- por  cliene de forma detallada que no incluyenn los productos
	open $1 for select *from ventas.v_listar_cabecera_facturacion 
	where  id_cliente=_id_cliente and id_empresa=_id_empresa order by cliente;
end if;


if op=7 then -- todos los clientes entre fechas 
	open $1 for select *from ventas.v_listar_cabecera_facturacion 
	where  fecha_venta>=cast(fec_desde as date) and fecha_venta<=cast(fec_hasta as date)
	order by cliente;
end if;

if op=8 then -- por cliente clientes entre fechas 
	open $1 for select *from ventas.v_listar_cabecera_facturacion 
	where  id_cliente=_id_cliente and fecha_venta>=cast(fec_desde as date) and fecha_venta<=cast(fec_hasta as date) and id_empresa=_id_empresa
	order by cliente;
end if;
--

if op=9 then --todas las  ventas, todas los clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie_facturacion || '-'||f.numdoc_facturacion) as documento,
	f.fecha_venta,	
	f.id_cliente,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as cliente,  
	f.valor_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.importe as total_det,
        und.desc_corta as unidad
	from  ventas.tbl_facturacion f
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (f.id_facturacion=df.id_facturacion)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_direccion = tbl_direccion.id_direccion  AND f.id_cliente = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona 
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursal) where  f.id_estado=1 and suc.id_empresa=_id_empresa
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;

end if;
--SELECT *FROM ALMACEN.TBL_UNIDAD
if op=10 then --todas las  ventas, por  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie_facturacion || '-'||f.numdoc_facturacion) as documento,
	f.fecha_venta,	
	f.id_cliente,
	cli.doc_persona,
	trim(REPLACE(cli.nombre_razon,'"','')) as cliente,  
	f.valor_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.importe as total_det,
	und.desc_corta as unidad,
	p.codigo,
	und.desc_corta as unidad,
	vend.nombre_razon as vendedor,
	  dir.direccion || ' - ' || trim(ubi.distrito) || ' - ' || trim(prv.provincia) as direccion,
	tv.descripcion_larga as tipoventa,
	(f.id_facturacion::text || f.id_sucursal::text) as id_facturacion
	from  ventas.tbl_facturacion f
	inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=F.ID_VENDEDOR
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (f.id_facturacion=df.id_facturacion)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion dir ON dir.id_persona::text = f.id_cliente::text AND dir.id_direccion = f.id_direccion
	JOIN ventas.tbl_sector sec ON sec.id_sector = dir.id_sector
	JOIN ventas.tbl_zona z ON z.id_zona = sec.id_zona
	INNER JOIN COMMON.TBL_DISTRITO UBI ON UBI.ID_DISTRITO=Z.ID_DISTRITO
	INNER JOIN COMMON.TBL_PROVINCIA PRV ON prv.id_provincia=ubi.id_provincia
	JOIN planillas.tbl_persona cli ON cli.id_persona= dir.id_persona
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursal) where f.id_cliente=_id_cliente and f.id_estado=1 and suc.id_empresa=_id_empresa
	ORDER BY TRIM(cli.nombre_razon) asc;

end if;


if op=11 then --ventas por fecha , todos  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie_facturacion || '-'||f.numdoc_facturacion) as documento,
	f.fecha_venta,	
	f.id_cliente,
	tbl_persona.doc_persona,
	trim(REPLACE(tbl_persona.nombre_razon,'"','')) as cliente,    
	f.valor_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.importe as total_det,
	und.desc_corta as unidad
	from  ventas.tbl_facturacion f
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (f.id_facturacion=df.id_facturacion)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
	JOIN common.tbl_comprobante cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion ON f.id_direccion = tbl_direccion.id_direccion  AND f.id_cliente = tbl_direccion.id_persona
	JOIN planillas.tbl_persona ON tbl_persona.id_persona= tbl_direccion.id_persona
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursal) 
	where  f.fecha_venta>=cast(fec_desde as date) and f.fecha_venta<=cast(fec_hasta as date) and f.id_estado=1 and suc.id_empresa=_id_empresa
	ORDER BY TRIM(tbl_persona.nombre_razon) asc;
end if;


if op=12 then --ventas por fecha , por  clientes, resumido,incluiproductos
open $1 for select 
	(cc.descripcion_corta || '/' || f.serie_facturacion || '-'||f.numdoc_facturacion) as documento,
	f.fecha_venta,	
	f.id_cliente,
	cli.doc_persona,
	trim(REPLACE(cli.nombre_razon,'"','')) as cliente,   
	f.valor_venta,
	f.imp_igv,
	f.imp_total,
	P.id_producto as codigo,
	p.descripcion_larga as producto,
	df.cantidad,
	df.precio,
	df.importe as total_det,
	und.desc_corta as unidad,
	vend.nombre_razon as vendedor,
	  dir.direccion || ' - ' || trim(ubi.distrito) || ' - ' || trim(prv.provincia) as direccion,
	tv.descripcion_larga as tipoventa,
	(f.id_facturacion::text || f.id_sucursal::text) as id_facturacion
	from  ventas.tbl_facturacion f
	inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=F.ID_VENDEDOR
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (f.id_facturacion=df.id_facturacion)
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON (DP.id_producto=df.id_producto and dp.id_unidadventa=df.id_unidadventa)
	INNER JOIN ALMACEN.TBL_PRODUCTO P ON (P.ID_PRODUCTO=DP.ID_PRODUCTO)
	INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
	JOIN common.tbl_comprobante  cc ON f.id_comprobante = cc.id_comprobante
	inner join common.tbl_estado on (tbl_estado.id_estado=f.id_estado)
	JOIN ventas.tbl_direccion dir ON dir.id_persona::text = f.id_cliente::text AND dir.id_direccion = f.id_direccion
	JOIN ventas.tbl_sector sec ON sec.id_sector = dir.id_sector
	JOIN ventas.tbl_zona z ON z.id_zona = sec.id_zona
	INNER JOIN COMMON.TBL_DISTRITO UBI ON UBI.ID_DISTRITO=Z.ID_DISTRITO
	INNER JOIN COMMON.TBL_PROVINCIA PRV ON prv.id_provincia=ubi.id_provincia
	JOIN planillas.tbl_persona cli ON cli.id_persona= dir.id_persona
	INNER JOIN common.tbl_sucursal suc on (suc.id_sucursal=f.id_sucursal) 
	where  f.id_cliente=_id_cliente and f.fecha_venta::date>=cast(fec_desde as date) and f.fecha_venta::date<=cast(fec_hasta as date) and f.id_estado=1 and suc.id_empresa=_id_empresa
	ORDER BY TRIM(cli.nombre_razon) asc;
end if;

return $1;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.usp_adddetdespacho(
	_id_detdespacho bigint ,
	_id_despacho bigint,
	_id_sucursal bigint,
	_id_facturacion integer,
	_id_sucursalfac integer,
	_id_usuario char(5)
)
returns text[] as $$
declare
	res text[];
begin
if exists(select 1 from almacen.tbl_despacho where id_despacho=_id_despacho) then
	if exists(select * from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursalfac)then
		if not exists(select * from almacen.tbl_detdespacho where id_despacho=_id_despacho and id_facturacion=_id_facturacion and id_sucursal=_id_sucursalfac and id_estado=1) then
				INSERT INTO almacen.tbl_detdespacho(
					id_despacho,
					id_sucursal,
					id_facturacion,
					id_sucursalfac,
					fecha_reg,
					id_usuario
				)values(
					_id_despacho,
					_id_sucursal,
					_id_facturacion,
					_id_sucursalfac,
					now(),
					_id_usuario
				) returning array['0',id_Detdespacho::text,'Documento asignado correctamente'] into res;
			if not found then
				res:=array['502','Inconsistencia inesperada volver intentar'];
			end if;
		else
			res:=array['502','Ya existe el documento en el despacho seleccionado'];
		end if;
	else	
		res:=array['504','Verifique que el documento seleccionado este ingresado correctamente'];
	end if;
else
	res:=array['503','El despacho no existe'];
end if;
return res;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION almacen.usp_quitarDetalleDespacho(
	_id_detdespacho bigint 
)
returns text[] as $$
declare
	res text[];
begin
if exists(select 1 from almacen.tbl_detdespacho where id_detdespacho=_id_detdespacho) then
	update almacen.tbl_detdespacho set id_estado=7 where id_detdespacho=_id_detdespacho;
	res=array['0',_id_detdespacho::text,'Documento asignado correctamente']  ;
	if not found then
		res:=array['502','Inconsistencia inesperada volver intentar'];
	end if;	 
else
	res:=array['502','El despacho no existe'];
end if;
return res;
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION creditos.spi_ventacredito(
    op integer,
    _id_credito integer,
    _id_sucursal_credito integer,
    _id_estado integer,
    _id_sucursal integer,
    _id_facturacion integer,
    _id_usuario character)
  RETURNS text[] AS
$BODY$
declare
	res text[];
begin
if op=1 then
	if exists(select *from ventas.tbl_facturacion where id_sucursal=_id_sucursal and id_facturacion=_id_facturacion)then
		if exists(select *from creditos.tbl_credito where id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
			insert into creditos.tbl_ventacredito(
				id_credito,
				id_sucursal_credito ,
				id_estado ,
				id_sucursal  ,
				id_facturacion  ,
				id_usuario
			)
			values(
				_id_credito,
				_id_sucursal_credito ,
				_id_estado ,
				_id_sucursal  ,
				_id_facturacion  ,
				_id_usuario
			)returning array['0',tbl_ventacredito.id_credito::text,tbl_ventacredito.id_sucursal_credito::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al vincular el credito con el documento de venta'];
			end if;
		else
			res:=array['503','Verefique que los datos del credito esten ingresados correctamente'];
		end if;
	else
		res:=array['503','Verefique que los datos del documento de venta esten ingresados correctamente'];
	end if;
end if;	
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100; 



 CREATE OR REPLACE FUNCTION almacen.usp_despacho( 
	_op integer,	
	_id_despacho bigint  ,
	_fecha_despacho text,
	_id_vendedor varchar(15),
	_id_usuario char(5),
	_id_sucursal integer	
)returns text[] as $$
declare
	res text[];
begin
if _op = 1 then
	if not exists(select * from almacen.tbl_despacho where id_despacho=_id_despacho) then
		INSERT INTO ALMACEN.TBL_DESPACHO (
			fecha_despacho,
			id_vendedor,
			id_usuario,
			id_sucursal,
			fecha_reg,
			id_estado
		)VALUES(
			_fecha_despacho::timestamp,
			_id_vendedor,
			_id_usuario,
			_id_sucursal,
			NOW(),
			1
		) RETURNING array['0',TBL_DESPACHO.id_despacho::text] into res;
		if not found then
			res:=array['502','Inconsistencia inesperada al generar el despacho'];
		end if;
	else
		res:=array['503','El Nro de despacho ya existe'];
	end if;
end if;
if _op=2 then
	res:=array['0',_id_despacho::text];
end if;
return res;
end;$$
language 'plpgsql';
 

CREATE OR REPLACE FUNCTION compras.gen_correl_compra(
    _anio integer,
    _id_mes integer,
    _nota_credito boolean
)
  RETURNS text[] AS
$BODY$
DECLARE 
	res text[];
	correl integer;
BEGIN
	if _nota_credito is true then
		select max(id_compra) into correl from compras.tbl_compra where anio = _anio AND id_mes = _id_mes and (nota_credito=_nota_credito or nota__debito=_nota_credito );
	else
		select max(id_compra) into correl from compras.tbl_compra where anio = _anio AND id_mes = _id_mes and nota_credito=_nota_credito;
	end if;
	if correl is null then
		correl = 1;
	else
		correl = correl + 1;
	end if;
	res := array['0', correl::TEXT];
	return res; 
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.fn_attributes(
	op integer,
	_id bigint ,
	_code character varying(30),
	_name character varying(100)  ,
	_shortname character varying(50)
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
if op=1 then
	if not exists(select 1 from almacen.attributes where upper(name)=(_name)) then
		select max(id) into _id from almacen.attributes;
		if _id is null then
			_id:=1;
		else
			_id:=_id+1;
		end if;
		insert into almacen.attributes(
			id,
			code,
			name,
			shortname
		)values(
			_id,
			_code,
			_name,
			_shortname) returning array['0','Registro procesado con exito',id::text] into res;
		if not found then
			res:=array['501','Registro no procesado'];
		end if;
	else
		res:=array['502','Registro ya existe'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.attributes where id=_id) then
		update almacen.attributes set name=_name,shortname=_shortname where id=_id;
		res:=array['0','Registro actualizado',_id::text];
	else
		res:=array['502','Verifique que el registro exista'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION almacen.fn_attribute_values(
	op integer,
	_id bigint ,
	_code character varying(50),
	_name character varying(100) ,
	_shortname character varying(50),
	_custom boolean  ,
	_attribute_id bigint
)
returns text[] as $$
declare
	res text[];
begin
if op=1 then
	if not exists(select 1 from almacen.attribute_values where name=_name and attribute_id=_attribute_id ) then
		if exists(select 1 from almacen.attributes where id=_attribute_id ) then
			select max(id) into _id from almacen.attribute_values;
			if  _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			insert into almacen.attribute_values(
					id  ,
					code,
					name,
					shortname,
					custom,
					attribute_id 
				)values(
					_id  ,
					_code,
					_name,
					_shortname,
					_custom,
					_attribute_id 
				)returning array['0','Registro procesado con exito',id::text] into res;
			if not found then
				res:=array['501','Registro no procesado'];
			end if;
		else
			res:=array['502','Verifique que existe el atributo'];
		end if;
	else
		res:=array['503','Registro ya existe'];	
	end if;
end if;
if op=2 then
	if exists (select 1 from almacen.attribute_values where id=_id ) then
		update almacen.attribute_values set
					code=_code,
					name=_name,
					shortname=_shortname,
					custom=_custom,
					attribute_id =_attribute_id 
		where id=_id;
	else
		res:=array['502','Verifique que el registro exista'];
	end if;
end if;
RETURN RES;
end;$$
language 'plpgsql';

select id_vendedor,count(1) from ventas.tbl_facturacion where id_comprobante=2
group by id_vendedor

select *from ventas.fn_list_estadistica_desenpenio_vendedor(1)

create or replace function ventas.fn_list_estadistica_desenpenio_vendedor(
op integer,
_fec_desde text,
_fec_hasta text
)
returns table(
	id_sucursal integer,
	id_vendedor varchar(15),
	sucursal text,
	vendedor text,
	facturas numeric(14,4),
	boletas numeric(14,4),
	nota_credito numeric(14,4),
	nota_debito numeric(14,4),
	otros numeric(14,4),
	total_documentos numeric(14,4),
	num_clientes integer,
	valor_venta numeric(20,4),
        imp_igv numeric(20,4),
	imp_total  numeric(20,4),
	porcent numeric(20,2)
) as $$
declare
	dat record;
	porcent_temp numeric(20,2);
	total_ventas numeric(20,4);
	rec_tem record;
	
begin
porcent_temp:=0;
total_ventas:=0;
  CREATE TEMPORARY TABLE  tmp_estadisticas_vendedores_val(
	id_sucursal integer ,
	id_vendedor varchar(15),
	sucursal text,
	vendedor text,
	facturas numeric(14,4),
	boletas numeric(14,4),
	nota_credito numeric(14,4),
	nota_debito numeric(14,4),
	otros numeric(14,4),
	total_documentos numeric(14,4),
	num_clientes integer,
	valor_venta numeric(20,4),
        imp_igv numeric(20,4),
	imp_total  numeric(20,4) ,
	porcent numeric(20,2)
  )ON COMMIT DROP;
if OP=1 then
	for dat in select id_comprobante,f.id_vendedor,suc.id_sucursal,suc.nombre as sucursal,vend.nombre_razon as vendedor,SUM(1) cantidad,z.num_clientes,x.imp_total  from ventas.tbl_facturacion f
		inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
		inner join common.tbl_sucursal suc on suc.id_sucursal=f.id_sucursal
                inner join (select fc.id_vendedor,fc.id_sucursal, count(1) as num_clientes from ventas.tbl_facturacion fc 
				inner join planillas.tbl_persona cli on cli.id_persona=fc.id_cliente
				group by fc.id_vendedor,fc.id_sucursal
			) z on z.id_vendedor=f.id_vendedor and z.id_sucursal=f.id_sucursal
		inner join (select fc.id_vendedor,fc.id_sucursal, sum(fc.imp_total) as imp_total from ventas.tbl_facturacion fc 
				inner join planillas.tbl_persona cli on cli.id_persona=fc.id_cliente
				group by fc.id_vendedor,fc.id_sucursal
			) x on x.id_vendedor=f.id_vendedor and x.id_sucursal=f.id_sucursal
		group by id_comprobante,f.id_vendedor,suc.id_sucursal,suc.nombre,vend.nombre_razon,z.num_clientes,x.imp_total loop
		if not  exists(select 1from  tmp_estadisticas_vendedores_val tmp where tmp.id_vendedor=dat.id_vendedor and tmp.id_sucursal=dat.id_sucursal) then
			insert into tmp_estadisticas_vendedores_val(
				id_sucursal ,
				id_vendedor,
				sucursal ,
				vendedor ,
				facturas ,
				boletas ,
				nota_credito ,
				nota_debito ,
				otros ,
				total_documentos ,
				num_clientes ,
				valor_venta ,
				imp_igv ,
				imp_total ,
				porcent
			  )values(
				dat.id_sucursal ,
				dat.id_vendedor,
				dat.sucursal ,
				dat.vendedor ,
				case when dat.id_comprobante=3 then dat.cantidad else 0 end,--facturas ,
				case when dat.id_comprobante=2 then dat.cantidad else 0 end ,--boletas ,
				case when dat.id_comprobante=19 then dat.cantidad else 0 end,--nota_credito ,
				0,--nota_debito ,
				case when dat.id_comprobante=32 then dat.cantidad else 0 end,--otros ,
				0,--total_documentos ,
				dat.num_clientes,--num_clientes ,
				0.00,--valor_venta ,
				0.00,--imp_igv ,
				dat.imp_total,--imp_total 
				0.00	
			  );
			--total_ventas:=total_ventas+dat.imp_total ;
		else
		update	tmp_estadisticas_vendedores_val tmp set
				facturas =case when dat.id_comprobante=3 then dat.cantidad else tmp.facturas end,
				boletas=case when dat.id_comprobante=2 then dat.cantidad else tmp.boletas end ,
				nota_credito =case when dat.id_comprobante=19 then dat.cantidad else tmp.nota_credito end ,
				nota_debito =0,
				otros=case when dat.id_comprobante=32 then dat.cantidad else tmp.otros end ,
				total_documentos =0,
				num_clientes =dat.num_clientes,
				valor_venta =0,
				imp_igv =0,
				imp_total=dat.imp_total 
		where tmp.id_vendedor=dat.id_vendedor and tmp.id_sucursal=dat.id_sucursal;
			--total_ventas:=total_ventas+dat.imp_total ;
		end if;
		
		UPDATE tmp_estadisticas_vendedores_val tmp SET total_documentos=tmp.facturas+tmp.boletas+tmp.nota_credito+tmp.otros WHERE  tmp.id_vendedor=dat.id_vendedor and tmp.id_sucursal=dat.id_sucursal;
	end loop;
	select sum(tmp.imp_total) into total_ventas from tmp_estadisticas_vendedores_val tmp ;
	
	for rec_tem in select *from tmp_estadisticas_vendedores_val loop
		porcent_temp:=rec_tem.imp_total/total_ventas;
		RAISE NOTICE 'rec_tem.imp_total(%)',  rec_tem.imp_total::text;
		RAISE NOTICE 'total_ventas.imp_total(%)',  total_ventas::text;

		UPDATE tmp_estadisticas_vendedores_val tmp SET porcent=porcent_temp WHERE  tmp.id_vendedor=rec_tem.id_vendedor and tmp.id_sucursal=rec_tem.id_sucursal;

	end loop;
end if;
if OP=2 then
	for dat in select id_comprobante,f.id_vendedor,suc.id_sucursal,suc.nombre as sucursal,vend.nombre_razon as vendedor,z.num_clientes,SUM(f.imp_total) cantidad,x.imp_total  from ventas.tbl_facturacion f
		inner join planillas.tbl_persona vend on vend.id_persona=f.id_vendedor
		inner join common.tbl_sucursal suc on suc.id_sucursal=f.id_sucursal
                inner join (select fc.id_vendedor,fc.id_sucursal, count(1) as num_clientes from ventas.tbl_facturacion fc 
				inner join planillas.tbl_persona cli on cli.id_persona=fc.id_cliente
				group by fc.id_vendedor,fc.id_sucursal
			) z on z.id_vendedor=f.id_vendedor and z.id_sucursal=f.id_sucursal
		inner join (select fc.id_vendedor,fc.id_sucursal, sum(fc.imp_total) as imp_total from ventas.tbl_facturacion fc 
				inner join planillas.tbl_persona cli on cli.id_persona=fc.id_cliente
				group by fc.id_vendedor,fc.id_sucursal
			) x on x.id_vendedor=f.id_vendedor and x.id_sucursal=f.id_sucursal
		group by id_comprobante,f.id_vendedor,suc.id_sucursal,suc.nombre,vend.nombre_razon,z.num_clientes,x.imp_total loop
		if not  exists(select 1from  tmp_estadisticas_vendedores_val tmp where tmp.id_vendedor=dat.id_vendedor and tmp.id_sucursal=dat.id_sucursal) then
			insert into tmp_estadisticas_vendedores_val(
				id_sucursal ,
				id_vendedor,
				sucursal ,
				vendedor ,
				facturas ,
				boletas ,
				nota_credito ,
				nota_debito ,
				otros ,
				total_documentos ,
				num_clientes ,
				valor_venta ,
				imp_igv ,
				imp_total  
			  )values(
				dat.id_sucursal ,
				dat.id_vendedor,
				dat.sucursal ,
				dat.vendedor ,
				case when dat.id_comprobante=3 then dat.cantidad else 0 end,--facturas ,
				case when dat.id_comprobante=2 then dat.cantidad else 0 end ,--boletas ,
				case when dat.id_comprobante=19 then dat.cantidad else 0 end,--nota_credito ,
				0,--nota_debito ,
				case when dat.id_comprobante=32 then dat.cantidad else 0 end,--otros ,
				0,--total_documentos ,
				dat.num_clientes,--num_clientes ,
				0.00,--valor_venta ,
				0.00,--imp_igv ,
				dat.imp_total--imp_total 
			  );
		else
			update	tmp_estadisticas_vendedores_val tmp set
					facturas =case when dat.id_comprobante=3 then dat.cantidad else tmp.facturas end,
					boletas=case when dat.id_comprobante=2 then dat.cantidad else tmp.boletas end ,
					nota_credito =case when dat.id_comprobante=19 then dat.cantidad else tmp.nota_credito end ,
					nota_debito =0,
					otros=case when dat.id_comprobante=32 then dat.cantidad else tmp.otros end ,
					total_documentos =0,
					num_clientes =dat.num_clientes,
					valor_venta =0,
					imp_igv =0,
					imp_total=dat.imp_total 
			where tmp.id_vendedor=dat.id_vendedor and tmp.id_sucursal=dat.id_sucursal;
		end if;
	end loop;
end if;
return query select *from tmp_estadisticas_vendedores_val;
end;$$
language 'plpgsql';

select *from ventas.tbl_facturacion limit 10
select *from common.tbl_comprobante order by 1
select *from planillas.tbl_persona
select *from common.tbl_sucursal
select *from creditos.tbl_detpagocuota
alter table creditos.tbl_detpagocuota add column imp_pago_cuota numeric(20,4) default 0;

CREATE OR REPLACE FUNCTION caja.spi_detpagocuota(
    op integer,
    _id_cuotas integer,
    _id_movimcaja integer,
    _id_credito integer,
    _id_sucursal_credito integer,
    _fec_pago text,
    _id_estado integer,
    _imp_pago numeric,
    _id_sucursal integer,
    _id_usuario character,
    _glosa text,
    _operaciones text,
    _imp_mora numeric(20,4),
    _total_mora numeric(20,4),
	_imp_pago_cuota numeric(20,4)
)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if op=1 then
	if exists(select *from creditos.tbl_cuota where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito)then
		if exists(select *from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
			update  creditos.tbl_cuota set imp_mora=COALESCE(imp_mora,0)+_imp_mora where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito;

			insert into creditos.tbl_detpagocuota(
				  id_cuotas  ,
				  id_movimcaja,
				  id_credito ,
				  id_sucursal_credito,
				  fec_pago ,
				  id_estado,
				  imp_pago ,
				  id_sucursal ,
				  id_usuario ,
				  glosa,
				  operaciones,
				  imp_mora,
				  total_mora,
				  imp_pago_cuota
 
			)values(
				  _id_cuotas  ,
				  _id_movimcaja,
				  _id_credito ,
				  _id_sucursal_credito,
				  to_timestamp(_fec_pago,'YYYY-MM-DD HH24:MI:SS.MS') ,
				  _id_estado,
				  _imp_pago ,
				  _id_sucursal ,
				  _id_usuario ,
				  _glosa,
				  _operaciones ,
				  _imp_mora,
				  _total_mora,
				  _imp_pago_cuota
			)returning array['0','Proceso efectuado con exito'] into res;
			if not found then
				res:=array['504','Inconsitencia inesperada al registrar las cancelaciones de las cuotas'];
			end if;
		else
			res:=array['503','No existe el movimiento de caja'];
		end if;
	else
		res:=array['504','Verefique que exista la cuota'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from ventas.tbl_guiaremisionventa

select *from creditos.tbl_cuota where id_cuotas=29 and  id_credito=28 and id_sucursal_credito=1
select *from creditos.tbl_cuota where imp_mora>0
select *from creditos.tbl_detpagocuota

select * from contabilidad.list__ple__librodiario(4,10)

create or replace function contabilidad.list__ple__librodiario(
	__id_proceso integer,
	__id_mes integer	
)
returns table(
	data text
) as $$
declare
begin
	return query 
SELECT 
	COALESCE(C1,'') || 
	COALESCE(C2,'') || 
	COALESCE(C3,'') ||
	COALESCE(C4,'') || 
	COALESCE(C5,'') ||
	COALESCE(C6,'') || 
	COALESCE(C7,'') || 
	COALESCE(C8,'') || 
	COALESCE(C9,'') || 
	COALESCE(C10,'') || 
	--COALESCE(case when length(C10)=0 then '00' else C10 end,'00') || 
	COALESCE(C11,'') ||
	COALESCE(C12,'') || 
	COALESCE(C13,'') || 
	COALESCE(C14,'') || 
	COALESCE(C15,'') || 
	COALESCE(C16,'') || 
	COALESCE(C17,'') ||
	COALESCE(C18,'') || 
	COALESCE(C19,'')||
	COALESCE(C20,'')||
	COALESCE(C21,'') AS data
FROM contabilidad.tbl_plancuenta pct
inner join (
	select
	(pct.descripcion || "right"('00'::text || asi.mes_asi::character varying(2)::text, 2)) || '00|'::text AS c1,
	'22|'::text AS c2,
	 ('M'::text || row_number() OVER (PARTITION BY asi.mes_asi ORDER BY asi.mes_asi)::character varying(10)::text) || '|'::text AS c3,
	cta.nro_cuenta || '|' as c4,
	'|' as c5,
	'|' as c6,
	'PEN|' as c7,
	COALESCE(tin.codigo_sunat,'') || '|' c8,
	COALESCE(p.doc_persona,'') || '|' c9,
	CASE WHEN LENGTH(COALESCE(TRIM(cp.codigosunat),'00'))=0 THEN '00' else 
		CASE WHEN DAS.SERIE='0000' THEN '00' ELSE
			COALESCE(TRIM(cp.codigosunat),'00') 
		END
	end  ||'|' c10,
	das.serie || '|' c11,
	das.numero || '|' c12,
	'|' c13,
	'|' c14,
	to_char(fechadoc_das,'dd/MM/yyyy') || '|' c15,
	asi.glosa_asi || '|' c16,
	'|' c17,
	das.debe_Das::text || '|' as c18,
	das.haber_Das::text || '|' c19,
	'|' c20,
	'1|' c21,
	'|' C22,
	das.id_plancuenta
	from contabilidad.tbl__asiento__contable asi
	inner join contabilidad.tbl__detalle__asiento__contable das on asi.id_asiento=das.id_asiento
	inner join contabilidad.tbl_procesocontable pct on pct.id_proceso=asi.id_proceso
	inner join contabilidad.tbl_plancuenta cta on cta.id_plancuenta=das.id_plancuenta
	left join planillas.tbl_persona p on p.id_persona=das.id__persona
	left join planillas.tbl_tipdocidentidad tin on tin.id_tipdocidentidad=p.id_tipdocidentidad
	left join common.tbl_comprobante cp on cp.id_comprobante=das.id_comprobante
	where asi.mes_asi=__id_mes and asi.id_proceso=__id_proceso and asi.id_estado=1 and das.id_estado=1
)x on x.id_plancuenta=pct.id_plancuenta;
end;$$
language 'plpgsql';


select contabilidad.list__ple__libromayor(4,10)

create or replace function contabilidad.list__ple__libromayor(
	__id_proceso integer,
	__id_mes integer	
)
returns table(
	data text
) as $$
declare
begin
	return query 
SELECT 
	COALESCE(C1,'') || 
	COALESCE(C2,'') || 
	COALESCE(C3,'') ||
	COALESCE(C4,'') || 
	COALESCE(C5,'') ||
	COALESCE(C6,'') || 
	COALESCE(C7,'') || 
	COALESCE(C8,'') || 
	COALESCE(C9,'') || 
	COALESCE(C10,'') || 
	--COALESCE(case when length(C10)=0 then '00' else C10 end,'00') || 
	COALESCE(C11,'') ||
	COALESCE(C12,'') || 
	COALESCE(C13,'') || 
	COALESCE(C14,'') || 
	COALESCE(C15,'') || 
	COALESCE(C16,'') || 
	COALESCE(C17,'') ||
	COALESCE(C18,'') || 
	COALESCE(C19,'')||
	COALESCE(C20,'')||
	COALESCE(C21,'') AS data
FROM contabilidad.tbl_plancuenta pct
inner join (
	select
	(pct.descripcion || "right"('00'::text || asi.mes_asi::character varying(2)::text, 2)) || '00|'::text AS c1,
	'22|'::text AS c2,
	 ('M'::text || row_number() OVER (PARTITION BY asi.mes_asi ORDER BY asi.mes_asi)::character varying(10)::text) || '|'::text AS c3,
	cta.nro_cuenta || '|' as c4,
	'|' as c5,
	'|' as c6,
	'PEN|' as c7,
	COALESCE(tin.codigo_sunat,'') || '|' c8,
	COALESCE(p.doc_persona,'') || '|' c9,
	CASE WHEN LENGTH(COALESCE(TRIM(cp.codigosunat),'00'))=0 THEN '00' else 
		CASE WHEN DAS.SERIE='0000' THEN '00' ELSE
			COALESCE(TRIM(cp.codigosunat),'00') 
		END
	end  ||'|' c10,
	das.serie || '|' c11,
	das.numero || '|' c12,
	'|' c13,
	'|' c14,
	to_char(fechadoc_das,'dd/MM/yyyy') || '|' c15,
	asi.glosa_asi || '|' c16,
	'|' c17,
	SUM(das.debe_Das)::text || '|' as c18,
	SUM(das.haber_Das)::text || '|' c19,
	'|' c20,
	'1|' c21,
	'|' C22,
	das.id_plancuenta,
	asi.numero_asi
	from contabilidad.tbl__asiento__contable asi
	inner join contabilidad.tbl__detalle__asiento__contable das on asi.id_asiento=das.id_asiento
	inner join contabilidad.tbl_procesocontable pct on pct.id_proceso=asi.id_proceso
	inner join contabilidad.tbl_plancuenta cta on cta.id_plancuenta=das.id_plancuenta
	left join planillas.tbl_persona p on p.id_persona=das.id__persona
	left join planillas.tbl_tipdocidentidad tin on tin.id_tipdocidentidad=p.id_tipdocidentidad
	left join common.tbl_comprobante cp on cp.id_comprobante=das.id_comprobante
	where asi.mes_asi=__id_mes and asi.id_proceso=__id_proceso and asi.id_estado=1 and das.id_estado=1
	GROUP BY pct.descripcion,asi.mes_asi,
	cta.nro_cuenta,tin.codigo_sunat,p.doc_persona,
	cp.codigosunat,DAS.SERIE,das.numero,to_char(fechadoc_das,'dd/MM/yyyy'),asi.glosa_asi,das.id_plancuenta,
	asi.numero_asi
)x on x.id_plancuenta=pct.id_plancuenta;
end;$$
language 'plpgsql';


select *from contabilidad.list__ple__plancontable(4,10);

create or replace function contabilidad.list__ple__plancontable(
	__id_proceso integer,
	__id_mes integer	
)
returns table(
	data text
) as $$
declare
begin
	return query 
SELECT  C1 ||
	C2 ||
	C3 ||
	C4 ||
	C5 ||
	C6 ||
	C7 ||
	C8 ||
	C9

FROM  contabilidad.tbl_plancuenta pct
INNER JOIN(
	select distinct
	(pct.descripcion || "right"('00'::text || asi.mes_asi::character varying(2)::text, 2)) || '01|'::text AS c1,
	nro_cuenta || '|' C2,
	cta.nombre_cuenta  || '|' C3,
	'01|' C4,
	'|' C5,
	'|' C6,
	'|' C7,
	'1|' C8,
	'|' C9,
	cta.id_plancuenta
from contabilidad.tbl__asiento__contable asi
	inner join contabilidad.tbl__detalle__asiento__contable das on asi.id_asiento=das.id_asiento
	inner join contabilidad.tbl_procesocontable pct on pct.id_proceso=asi.id_proceso
	inner join contabilidad.tbl_plancuenta cta on cta.id_plancuenta=das.id_plancuenta
	where asi.mes_asi=__id_mes and asi.id_proceso=__id_proceso and asi.id_estado=1 and das.id_estado=1
) X on x.id_plancuenta=pct.id_plancuenta;
end;$$
language 'plpgsql';


select *from contabilidad.tbl_plancuenta

create or replace function ventas.list_facvales_ventas(
    _mes integer,
    _id_cliente text,
    _id_familia text
) returns table(
	id_producto varchar(20),
	id_almacen integer,
	producto varchar(200),
	unidad varchar(20),
	cantidad numeric,
	lista integer,
	precio numeric(20,4),
	total numeric,
	id_unidadventa integer,
	id_listaprecio integer,
	ctrl_stock boolean,
	val_unidad integer,
	val_min integer,
	id_estado integer,
	id_direccion bigint,
	id_cliente varchar(15),
	familia_id char(5)
	
) as $$
declare
begin
	return query SELECT 
    p.id_producto,
    exi.id_almacen,
    p.descripcion_larga AS producto,
    u.desc_corta as unidad,
    sum(d.cantidad) as cantidad,
    d.lista,
    d.precio,
    sum(d.total) as total,
    dp.id_unidadventa,
    d.id_listaprecio,
    p.servicio as ctrl_stock,
    1 as valunidad,
    1 as valmin,
    e.id_estado,
    v.id_direccion  ,
    v.id_cliente ,
    p.id_familia
   FROM ventas.tbl_valesconsumo v
   inner join  common.tbl_comprobante comp on (comp.id_comprobante=v.id_comprobante)
   inner join  ventas.tbl_direccion dir on (dir.id_direccion=v.id_direccion and dir.id_persona=v.id_cliente)
   inner join  ventas.tbl_sector sec  on (sec.id_sector=dir.id_sector)
   inner join  ventas.tbl_zona zon on (zon.id_zona=sec.id_zona)
   inner join  common.tbl_distrito dis on (dis.id_distrito=zon.id_distrito)
   inner join  common.tbl_provincia prov on (prov.id_provincia=dis.id_provincia)
   inner join  common.tbl_dpto dpto on (dpto.id_dpto=prov.id_dpto)
   INNER JOIN PLANILLAS.TBL_PERSONA PER ON (PER.ID_PERSONA=DIR.ID_PERSONA)
   inner join ventas.tbl_detvale d on(v.id_vale=d.id_vale and  v.id_sucrusal_vale=d.id_sucrusal_vale) 
   JOIN almacen.tbl_detproducto dp ON dp.id_producto::text = d.id_producto::text AND dp.id_unidadventa = d.id_unidadventa
   JOIN almacen.tbl_producto p ON p.id_producto::text = dp.id_producto::text
   INNER JOIN almacen.tbl_existencia exi ON (dp.id_producto::text = exi.id_producto::text AND dp.id_unidadventa = exi.id_unidadventa)
   JOIN almacen.tbl_unidad  U ON (U.id_unidadventa=D.id_unidadventa)
   JOIN common.tbl_estado e ON d.id_estado = e.id_estado 
   where v.id_cliente=_id_cliente and date_part('month'::text, fec_emision )=_mes and p.id_familia in (id_familia) and v.id_estado=1
   group by p.id_producto,
    p.descripcion_larga ,
    u.desc_corta ,
    d.precio,
    d.lista,
    d.imp_dsct,
    dp.id_unidadventa,
    d.id_listaprecio,
    e.id_estado,
    exi.id_almacen   ,
    v.id_direccion  ,
    v.id_cliente,p.id_familia;
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION ventas.cur_facvales_ventas(
    refcursor,
    mes integer,
    _id_cliente text,
    _id_familia text,
    text)
  RETURNS refcursor AS
$BODY$ 
declare
 cmd text;
begin
cmd:='SELECT 
    p.id_producto,
    exi.id_almacen,
    p.descripcion_larga AS producto,
    u.desc_corta as unidad,
    sum(d.cantidad) as cantidad,
    d.lista,
    d.precio,
    sum(d.total) as total,
    dp.id_unidadventa,
    d.id_listaprecio,
    p.servicio as ctrl_stock,
    1 as valunidad,
    1 as valmin,
    e.id_estado,
    v.id_direccion  ,
    v.id_cliente 
   FROM ventas.tbl_valesconsumo v
   inner join  common.tbl_comprobante comp on (comp.id_comprobante=v.id_comprobante)
   inner join  ventas.tbl_direccion dir on (dir.id_direccion=v.id_direccion and dir.id_persona=v.id_cliente)
   inner join  ventas.tbl_sector sec  on (sec.id_sector=dir.id_sector)
   inner join  ventas.tbl_zona zon on (zon.id_zona=sec.id_zona)
   inner join  common.tbl_distrito dis on (dis.id_distrito=zon.id_distrito)
   inner join  common.tbl_provincia prov on (prov.id_provincia=dis.id_provincia)
   inner join  common.tbl_dpto dpto on (dpto.id_dpto=prov.id_dpto)
   INNER JOIN PLANILLAS.TBL_PERSONA PER ON (PER.ID_PERSONA=DIR.ID_PERSONA)
   inner join ventas.tbl_detvale d on(v.id_vale=d.id_vale and  v.id_sucrusal_vale=d.id_sucrusal_vale) 
   JOIN almacen.tbl_detproducto dp ON dp.id_producto::text = d.id_producto::text AND dp.id_unidadventa = d.id_unidadventa
   JOIN almacen.tbl_producto p ON p.id_producto::text = dp.id_producto::text
   INNER JOIN almacen.tbl_existencia exi ON (dp.id_producto::text = exi.id_producto::text AND dp.id_unidadventa = exi.id_unidadventa)
   JOIN almacen.tbl_unidad  U ON (U.id_unidadventa=D.id_unidadventa)
   JOIN common.tbl_estado e ON d.id_estado = e.id_estado 
   where v.id_cliente='''||_id_cliente||''' and date_part(''month''::text, fec_emision )='||mes||' and p.id_familia::integer in ('||_id_familia||') and v.id_estado=1
   group by p.id_producto,
    p.descripcion_larga ,
    u.desc_corta ,
    d.precio,
    d.lista,
    d.imp_dsct,
    dp.id_unidadventa,
    d.id_listaprecio,
    e.id_estado,
    exi.id_almacen   ,
    v.id_direccion  ,
    v.id_cliente ' ;
 open $1 for execute cmd;

  return $1;
  end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



create or replace function contabilidad.fn_get_asiento_contable(_id_asiento bigint)
returns table(	
	asiento text
) as $$
declare
begin
return query select array_to_json(array_agg(row_to_json(asi)))::TEXT AS data
      from (
	select 
		id_asiento,
		aux.id_auxiliar,
		aux.descripcion as auxiliar,
		sub.name as subdiario,
		subdiario_id,
		fecha_asi,
		pc.id_proceso,
		a.id_estado,
		glosa_Asi,
		numero_asi,
		mes_asi,
		debe_asi,
		haber_asi,
		a.id_empresa ,
		nro_operacion,
		(
		      select array_to_json(array_agg(row_to_json(detalle)))::text as detalle
		      from (
			select 
				id_detalleasiento, 
				fechadoc_das, 
				serie, 
				numero, 
				debe_das, 
				haber_das, 
				per.doc__persona, 
			        per.nombre_razon responsable, 
				pcta.nro_cuenta,
				pcta.nombre_cuenta,
				das.id_plancuenta, 
				das.id_centrocostos, 
				id_comprobante, 
			        id_asiento, 
				concepto_das, 
				debehaber, 
				tipo_das, 
				das.id_estado, 
				id_movasientos, 
				id_tablamov, 
				id_tipocambio, 
				id_moneda, 
				id_producto, 
				id_sucursal, 				
				id__persona, 
				id__caja, 
				id_mes, 
				anio, 
				fecha_registro, 
				fecha_contable, 
				id_usuario, 
				host, 
				codigo__cuo__dia, 
				correlativo__dia, 
				codigo_movcab, 
				modificable, 
				tipo_cambio,
				nro_operacion,
				glosa
			from contabilidad.tbl__detalle__asiento__contable das
			inner join contabilidad.tbl_plancuenta pcta on pcta.id_plancuenta=das.id_plancuenta
			inner join planillas.tbl_persona per on per.id_persona=das.id__persona
			inner join common.tbl_concepto cto on cto.id::text=das.id_producto
			where a.id_asiento=das.id_asiento
		     ) detalle
		)
	from contabilidad.tbl__asiento__contable a
	inner join contabilidad.tbl_subdiario sub on sub.id=a.subdiario_id
	inner join contabilidad.tbl_auxiliar aux on aux.id_auxiliar=sub.auxiliar_id
	inner join contabilidad.tbl_procesocontable pc on pc.id_proceso=a.id_proceso
	where a.id_asiento=_id_asiento
     ) asi;
end;$$
language 'plpgsql';



select 
				id_detalleasiento, 
				fechadoc_das, 
				serie, 
				numero, 
				debe_das, 
				haber_das, 
				doc__persona, 
			        responsable, 
				pcta.nro_cuenta,
				pcta.nombre_cuenta,
				das.id_plancuenta, 
				das.id_centrocostos, 
				id_comprobante, 
			        id_asiento, 
				concepto_das, 
				debehaber, 
				tipo_das, 
				das.id_estado, 
				id_movasientos, 
				id_tablamov, 
				id_tipocambio, 
				id_moneda, 
				id_producto, 
				id_sucursal, 				
				id__persona, 
				id__caja, 
				id_mes, 
				anio, 
				fecha_registro, 
				fecha_contable, 
				id_usuario, 
				host, 
				codigo__cuo__dia, 
				correlativo__dia, 
				codigo_movcab, 
				modificable, 
				tipo_cambio,
				nro_operacion,
				glosa
			from contabilidad.tbl__detalle__asiento__contable das
			inner join contabilidad.tbl_plancuenta pcta on pcta.id_plancuenta=das.id_plancuenta
			inner join planillas.tbl_persona per on per.id_persona=das.id__persona
			left join common.tbl_concepto cto on cto.id::text=das.id_producto
			where id_asiento=49


select *from common.tbl_concepto where id::text='3371'
select *from contabilidad.tbl__detalle__asiento__contable where id_asiento=49
select *from contabilidad.tbl__asiento__contable a

select * from ALMACEN.FN_STOCK('1875',12,1,'2')

select * from ALMACEN.FN_STOCK('10',54,1,1.00)
select *from almacen.tbl_existencia


CREATE OR REPLACE FUNCTION ALMACEN.FN_STOCK(
	_id_producto varchar(20),
	_id_unidad integer,
	_id_almacen integer,
	_cantidad numeric(20,4)
) returns table(product_id varchar(20),unit_id integer,val_unit integer, stock numeric(20,4),cantidad numeric(20,4)) as  $$
declare 
	_stock numeric(20,4);
	_val_unidad integer;
	_id_unidad_inventario integer;
	_val_unidad_inventario integer;
	_val_unidad_venta integer;
	_descuento numeric(20,4);
	_stock_saldo numeric(20,4);	
	_stock_reserva numeric(20,4);
begin
_descuento:=0;
stock:=0;
_val_unidad:=0;
_val_unidad_venta:=0;
_stock_saldo:=0;
	select dp.id_unidadventa,dp.val_unidad,stock_reserva into _id_unidad_inventario,_val_unidad_inventario,_stock_reserva from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto
	inner join almacen.tbl_existencia ex on ex.id_producto=dp.id_producto and ex.id_unidadventa=dp.id_unidadventa
	where ex.id_producto=_id_producto and ex.id_almacen=_id_almacen and dp.unidad_inventario=true;

	select dp.val_unidad into _val_unidad_venta from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto	 
	where dp.id_producto=_id_producto and dp.id_unidadventa=_id_unidad and dp.id_estado=1 ;

	--RAISE NOTICE '_val_unidad_venta %', _val_unidad_venta;
	--RAISE NOTICE '_id_unidad_inventario %', _id_unidad_inventario;
	--RAISE NOTICE '_val_unidad_inventario %', _val_unidad_inventario;
	select stock_fisico into _stock from almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen and id_unidadventa=_id_unidad_inventario;
	--RAISE NOTICE 'stock-01  %', _stock ;
	_descuento:=(_cantidad*_val_unidad_venta)/case when _val_unidad_inventario>0 then _val_unidad_inventario else 1 end;
	_stock_saldo :=_stock-_descuento;
	IF (SELECT COUNT(*) FROM almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen )>1 THEN
		--RAISE NOTICE 'stock-02  %', _stock_saldo ;
		return query select COALESCE(_id_producto,'1'), COALESCE(_id_unidad_inventario,1), COALESCE(_val_unidad_inventario,1),COALESCE(_stock_saldo,0),COALESCE(_descuento,0);	
	ELSE
	return query select  ex.id_producto,ex.id_unidadventa,dp.val_unidad::integer, (ex.stock_fisico-_cantidad)::numeric(20,4) ,_cantidad::numeric(20,4) 
		from almacen.tbl_existencia ex 
		inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
		where dp.id_producto=_id_producto and ex.id_almacen=_id_almacen and ex.id_unidadventa=_id_unidad_inventario and dp.unidad_inventario=true;
	END IF;

end;$$
language 'plpgsql';

"CRA005"
select trim(codigo),*from almacen.tbl_producto where id_producto='761'

select *from almacen.tbl_existencia where --stock_reserva>0 and 
id_producto='761'


delete from ventas.tbl_puntos

update almacen.tbl_existencia set stock_reserva=0 where   id_producto='761'

select * from almacen.v__producto__search   WHERE id_sucursal=1 and  id_estado=1 and nombreCompleto||nombreCorto||id_producto||marca|| codigo  ILIKE '%CRA005%' and id_empresa=1


select * from ALMACEN.FN_STOCK_PEDIDOS('1258',1,1,'1')

CREATE OR REPLACE FUNCTION ALMACEN.FN_STOCK_PEDIDOS(
	_id_producto varchar(20),
	_id_unidad integer,
	_id_almacen integer,
	_cantidad numeric(20,4)
) returns table(product_id varchar(20),unit_id integer,val_unit integer, stock numeric(20,4),cantidad numeric(20,4)) as  $$
declare 
	_stock numeric(20,4);
	_val_unidad integer;
	_id_unidad_inventario integer;
	_val_unidad_inventario integer;
	_val_unidad_venta integer;
	_descuento numeric(20,4);
	_stock_saldo numeric(20,4);	
	_stock_reserva numeric(20,4); 
begin
_descuento:=0;
stock:=0;
_val_unidad:=0;
_val_unidad_venta:=0;
_stock_saldo:=0;
	select dp.id_unidadventa,dp.val_unidad,stock_reserva into _id_unidad_inventario,_val_unidad_inventario,_stock_reserva from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto
	inner join almacen.tbl_existencia ex on ex.id_producto=dp.id_producto and ex.id_unidadventa=dp.id_unidadventa
	where ex.id_producto=_id_producto and ex.id_almacen=_id_almacen and dp.unidad_inventario=true;

	select dp.val_unidad into _val_unidad_venta from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto	 
	where dp.id_producto=_id_producto and dp.id_unidadventa=_id_unidad and dp.id_estado=1 ;

	RAISE NOTICE '_val_unidad_venta %', _val_unidad_venta;
	RAISE NOTICE '_id_unidad_inventario %', _id_unidad_inventario;
	RAISE NOTICE '_val_unidad_inventario %', _val_unidad_inventario;
	select stock_fisico into _stock from almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen and id_unidadventa=_id_unidad_inventario;
	RAISE NOTICE 'stock-01  %', _stock ;
	_descuento:=(_cantidad*_val_unidad_venta)/case when _val_unidad_inventario>0 then _val_unidad_inventario else 1 end;
	_stock_saldo :=_stock-_descuento;
	IF (SELECT COUNT(*) FROM almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen )>1 THEN
		RAISE NOTICE 'stock-02  %', _stock_saldo ;
		return query select COALESCE(_id_producto,'1'), COALESCE(_id_unidad_inventario,1), COALESCE(_val_unidad_inventario,1),COALESCE(_stock_saldo,0)-COALESCE(_stock_reserva,0),COALESCE(_descuento,0);	
	ELSE
	return query select  ex.id_producto,ex.id_unidadventa,dp.val_unidad::integer, (ex.stock_fisico-_cantidad-COALESCE(_stock_reserva,0))::numeric(20,4) ,_cantidad::numeric(20,4) 
		from almacen.tbl_existencia ex 
		inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
		where dp.id_producto=_id_producto and ex.id_almacen=_id_almacen and ex.id_unidadventa=_id_unidad_inventario and dp.unidad_inventario=true;
	END IF;

end;$$
language 'plpgsql';

select *from almacen.tbl_existencia where id_producto='1258'

select *from almacen.tbl_existencia where stock_reserva>0

update almacen.tbl_existencia set stock_reserva=0 where stock_reserva>0



CREATE OR REPLACE FUNCTION creditos.list_saldos_cliente(
    IN __id__cliente character varying,
    IN __id__empresa integer)
  RETURNS TABLE(
	__documento text, 
	__fecha timestamp without time zone, 
	__cliente text, 
	__importe numeric,
	__id_credito integer,
	id__sucursal integer,
	_cuotas text,
	detalle text,
	__id_Facturacion integer
) AS
$BODY$
declare
begin
return query 
select (tbl_comprobante.descripcion_corta || '/' || fac.serie_facturacion || '-' || fac.numdoc_facturacion)::text as documento,
fac.fecha_Venta as fec_credito,
cli.nombre_razon::text as cliente,
sum(COALESCE((select sum(c.imp_cuota) 
	from  creditos.tbl_cuota c 
	where  vc.id_credito=c.id_credito and  vc.id_sucursal_credito=c.id_sucursal_credito),0)-
COALESCE((select sum(mov.imp_movimiento)	
	from  creditos.tbl_cuota c 
	inner join creditos.tbl_detpagocuota cmov on (c.id_cuotas=cmov.id_cuotas and  c.id_credito=cmov.id_credito and  c.id_sucursal_credito=cmov.id_sucursal_credito)
	inner join caja.tbl_movcaja mov on (mov.id_movimcaja=cmov.id_movimcaja and  mov.id_sucursal=cmov.id_sucursal)
	where   vc.id_credito=c.id_credito and  vc.id_sucursal_credito=c.id_sucursal_credito),0))::numeric(20,4) as saldo,
	vc.id_credito,
	vc.id_sucursal_credito,
	(
		      select array_to_json(array_agg(row_to_json(d)))
		      from (
			select id_cuotas as cuota_id,nro_cuota,fecha_vencimiento as fecha,imp_capital,imp_interes,imp_cuota,ncr,dscto,mora,monto_cancelado,saldo_debito 
			from creditos.v_cuotas_x_cobrar   
			where id_credito=vc.id_credito and  id_sucursal_credito=vc.id_sucursal_credito
		     ) d
	)::text as cuotas,
	(
		      select array_to_json(array_agg(row_to_json(det)))
		      from (
			select 
			  producto,
			  trim(COALESCE(almacen.fn_getseriesventas(df.id_facturacion::bigint, df.id_sucursal, df.id_producto, df.id_unidadventa), '-'::text)) as serie
				    
			from ventas.v_editfacturacion  df
			where df.id_facturacion=fac.id_facturacion and  df.id_sucursal=fac.id_sucursal
		     ) det
	)::text as detalle,
	fac.id_facturacion
	from ventas.tbl_facturacion fac
	inner join common.tbl_sucursal s on(s.id_sucursal=fac.id_sucursal)
	inner join planillas.tbl_persona cli on (cli.id_persona=fac.id_cliente)
	INNER JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
	inner join creditos.tbl_ventacredito  vc on (fac.id_sucursal=vc.id_sucursal and  vc.id_facturacion=fac.id_facturacion and fac.id_tipoventa=2 and fac.id_Estado=1 and vc.id_estado=1)
	where fac.id_cliente=__id__cliente and s.id_empresa=__id__empresa	
	group by (tbl_comprobante.descripcion_corta || '/' || fac.serie_facturacion || '-' || fac.numdoc_facturacion), fac.fecha_Venta,cli.nombre_razon,vc.id_credito,
	vc.id_sucursal_credito,fac.id_facturacion,fac.id_sucursal;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

select *from contabilidad.tbl_axuliardocumento

CREATE OR REPLACE FUNCTION contabilidad.isp_auxiliardocumento(
    op integer,
    _id_auxiliardocumento integer,
    _id_empresa integer,
    _id_comprobante integer,
    _subdiario_id bigint,
    _id_cuentadebe bigint,
    _id_cuentahaber bigint,
    _id_motivo char(2),
    _id_estado integer,
    _observacion text)
  RETURNS text[] AS
$BODY$
declare
	_id integer;
	res text[];
begin
if op=1 then
	if exists(select *from contabilidad.tbl_subdiario where id=_subdiario_id)then
		if exists(select *from common.tbl_comprobante where id_comprobante=_id_comprobante)then
			if not exists(select *from contabilidad.tbl_axuliardocumento where id_empresa=_id_empresa and id_comprobante=_id_comprobante and subdiario_id=_subdiario_id) then
				select max(id_auxiliardocumento) into _id from contabilidad.tbl_axuliardocumento;
				if _id is null then
					_id:=1;
				else
					_id:=_id+1;
				end if;
				INSERT INTO contabilidad.tbl_axuliardocumento(
					id_auxiliardocumento, 
					id_empresa, 
					id_comprobante, 
					subdiario_id, 
					id_estado, 
					observacion,
					id_cuentadebe ,
					id_cuentahaber,
					id_motivo
				)
				VALUES (
					_id, 
					_id_empresa, 
					_id_comprobante, 
					_subdiario_id, 
					_id_estado, 
					_observacion,
					_id_cuentadebe ,
					_id_cuentahaber,
					_id_motivo
				)returning array['0','Proceso efectuado con exito'] into res;
				if not found then
					res:=array['504','Inconsitencia inesperada, verefique que los datos esten ingresados correctamente'];
				end if;
			else
				res:=array['0','Proceso registrado con exito'];
			end if;
		else
			res:=array['502','El Comprobante no existe'];
		end if;
	else
		res:=array['501','Verefique que exista el auxiliar'];
	end if;
end if;
if op=2 then
	if exists(select *from contabilidad.tbl_axuliardocumento where id_auxiliardocumento=_id_auxiliardocumento) then
		UPDATE contabilidad.tbl_axuliardocumento
		   SET  id_empresa=_id_empresa, 
			id_comprobante=_id_comprobante, 
			subdiario_id=_subdiario_id, 
		        id_estado=_id_estado, 
		        observacion=_observacion,
			id_cuentadebe=_id_cuentadebe ,
			id_cuentahaber=_id_cuentahaber,
			id_motivo=_id_motivo
		 WHERE id_auxiliardocumento=_id_auxiliardocumento;
		res:=array['0','registro Actualizado con exito'];
	else
		res:=array['502','El registro que esta actualizando no existe'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.fn_search_quote(IN _numbre_quote character varying)
  RETURNS TABLE(dat text) AS
$BODY$
declare
	cad text;
begin
return query 
select row_to_json(t)::text as data
from (
  select  
        cp.id_comprobante as comprobante_id,
	cp.serie,
	trim(cp.numero) as number, 
        to_char(cp.fecha,'dd/MM/yyyy') as fecha,
        cp.imp_bruto as amount,
        cp.imp_dscto as discount_amount,
        cp.imp_igv as tax_amount,
        cp.imp_total as total,
        cp.imp_neto as  net_amount,     
        cli.doc_persona as document_customer,
        cli.nombre_razon as name_customer,
        dir.direccion as address_customer,
        tv.descripcion_larga as type_order,
        vend.nombre_razon as name_seller,
        m.simbolo as name_currency,
        op.descripcion_larga as name_operation,
        cp.id_cliente as customer_id,
        cp.id_direccion as address_id,
        cp.id_sucursal as branch_id,
        cp.id_cotizapreventa as order_Id,
        tv.id_tipoventa as type_order_id,
        vend.id_persona as seller_id,
        m.id_moneda as currency_id,
        op.id_operacion as operation_id,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select  dp.item,
		trim(p.codigo) as code,
		pre.id_producto as product_id,
		pre.id_unidadventa as unit_id,
		und.desc_corta as  unit,
		fa.descripcion_larga as name_family,
		ma.descripcion_larga as name_brand,
		alm.descalmacen as name_warehouse,
		pre.val_unidad as value_unit,
		dp.cantidad as quantity,
		dp.precio as price,
		dp.imp_dscto as dscto,
		dp.imp_igv as taxAmount	,
		p.descripcion_larga as product,
		dp.id_almacen as warehouse_id,
		fa.id_familia as family_id,
		ma.id_marca as brand_id,
		dp.observaciones as observation,		
		dp.cantidad as quantity_previous,
		dp.lp as list_price,
		(
		      select array_to_json(array_agg(row_to_json(d)))
		      from (
			select pre.id_producto as product_id,
				pre.id_unidadventa as unit_id,
				pre.precio1 as price1,
				pre.precio2 as price2,
				pre.precio3 as price3,
				pre.precio4 as price4,
				pre.precio5 as price5 ,
				dp.unidad_inventario as unit_inventory,
				und.desc_corta as  unit,
				pre.val_unidad as value_unit
			from almacen.tbl_precio pre
			 inner join almacen.tbl_detproducto dp on pre.id_producto=dp.id_producto and dp.id_unidadventa=pre.id_unidadventa
			 inner join almacen.tbl_unidad und on und.id_unidadventa=pre.id_unidadventa
			where pre.id_producto=p.id_producto
			order by und.id_unidadventa asc
		      ) d
		    ) as unidades
        from ventas.tbl_detpreventacotiza dp 
		JOIN almacen.tbl_precio pre ON pre.id_producto::text = dp.id_producto::text AND pre.id_unidadventa = dp.id_unidadventa AND pre.id_listaprecio = dp.id_listaprecio AND dp.id_estado = 1
		JOIN almacen.tbl_detproducto dprod ON dprod.id_producto::text = pre.id_producto::text AND dprod.id_unidadventa = pre.id_unidadventa
		JOIN almacen.tbl_producto p ON p.id_producto::text = dprod.id_producto::text
		JOIN almacen.tbl_unidad und ON und.id_unidadventa = dp.id_unimedventa
		JOIN almacen.tbl_familia fa on fa.id_familia=p.id_familia
		JOIN almacen.tbl_marca ma on ma.id_marca=p.id_marca
		JOIN almacen.tbl_almacen alm on alm.id_almacen=dp.id_almacen
        where dp.id_cotizapreventa=cp.id_cotizapreventa
        order by dp.item asc
      ) d
    ) as details
    
  from  ventas.tbl_cotizacionpreventa cp
  inner join common.tbl_comprobante cpp on cpp.id_comprobante=cp.id_comprobante
  inner join ventas.tbl_direccion dir on dir.id_direccion=cp.id_direccion and dir.id_persona=cp.id_cliente
  inner join planillas.tbl_persona cli on cli.id_persona=dir.id_persona
  inner join common.tbl_tipoventa tv on tv.id_tipoventa=cp.id_tipoventa
  inner join planillas.tbl_persona vend on vend.id_persona=cp.id_vendedor
  inner join common.tbl_moneda m on m.id_moneda=cp.id_moneda
  inner join common.tbl_operacion op on op.id_operacion=cp.id_operacion
  where  id_cotizapreventa::text=_numbre_quote
		 
) t;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION ventas.fn_search_quote(character varying)
  OWNER TO postgres;


CREATE OR REPLACE FUNCTION seguridad.authorizeuser(
    _camp1 character varying,
    _camp2 character varying)
  RETURNS text AS
$BODY$
DECLARE
cadena text;
codigo character(10);
_id_persona text;
_user_data text;
BEGIN   
    codigo=NULL;
    
    SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2);

if exists(select 1   FROM seguridad.tbl_usuario where camp2=lower(_camp2)) then
	if exists(select 1 from   seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1) then
		--to_json(); 
		_user_data:=(
			
select row_to_json(t)
from (
  select 
	trim(id_usuario) as id, 
	camp2 as user,
	uss.id_persona as person_id,
	COALESCE(uper.apell_paterno,'') || ' ' || COALESCE(uper.apell_materno,'') || ' ' || COALESCE(uper.nombres,'') as colaborador,
	uss.lista_precio as list_price,
	uss.serie_pedido as serie_order,
	uss.modifica_precio as modify_price,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select alm.id_almacen, alm.descalmacen as almacen
        from seguridad.tbl_usuarioalmacen ussal
        inner join almacen.tbl_almacen alm on alm.id_almacen=ussal.id_almacen
        where uss.id_usuario=ussal.id_usuario
        order by alm.id_almacen asc
      ) d
    ) as almacen,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select alm.id_almacen, alm.descalmacen as almacen
        from seguridad.tbl_usuarioalmacen ussal
        inner join almacen.tbl_almacen alm on alm.id_almacen=ussal.id_almacen
        where uss.id_usuario=ussal.id_usuario and ussal.predeterminado=true
        order by alm.id_almacen asc
      ) d
    ) as almacendefault,
    (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        select distinct suc.id_sucursal, suc.nombre as sucursal
        from seguridad.tbl_usuariosucursal ussuc
        inner join common.tbl_sucursal suc on suc.id_sucursal=ussuc.id_sucursal
        where uss.id_usuario=ussuc.id_usuario
        order by suc.id_sucursal asc
      ) d
    ) as sucursal,
     (
	 select array_to_json(array_agg(row_to_json(d)))
      from (
        
       select id_persona as person_id,COALESCE(vend.apell_paterno,'') || ' ' || COALESCE(vend.apell_materno,'') || ' ' || COALESCE(vend.nombres,'') as vendedor 
       from planillas.tbl_persona vend 
       where empleado is true
      
       
      ) d
    ) as vendedores,
    (
	select to_json(t) from (select 18.00 as igv,700.00 as tope,1 as frontera,0 as tcam,0 as tcme) t
    ) as configuracion,
    (
	select to_json(t) from 
		(
			select suc.id_sucursal as codtie,suc.nombre as nomtie,ussuc.id_usuario  from seguridad.tbl_usuariosucursal ussuc
			inner join common.tbl_sucursal suc on suc.id_sucursal= ussuc.id_sucursal
			where ussuc.id_usuario=uss.id_usuario and ussuc.predeterminado=true
		) t
    ) as tienda
  from seguridad.tbl_usuario uss
  inner join planillas.tbl_persona as uper on uper.id_persona=uss.id_persona
  where id_usuario = '1'
) t
		);

		/*(select row_to_json(t)
		from (
		 select id_usuario,camp2 as user,camp1 as password,id_persona as persona_id from   seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1
		) t)::text;*/
		
		cadena:=to_json(message('success', replace(_user_data,'\\',''),'0',''))::text;  	
	else
		cadena:=to_json(message('error','Contraseña Incorrecta','502',''))::text;  
	end if;
else
	cadena:=to_json(message('error','Usuario Incorrecto','501',''))::text;  
end if;

RETURN cadena;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.fn_search_products(IN _product character varying)
  RETURNS TABLE(dat text) AS
$BODY$
declare
	cad text;
begin
	return query 
select row_to_json(t)::text as data
from (
  select  
	trim(f.id_familia) as codF,
	p.id_producto as codi,
	p.codigo as codigo,
	p.descripcion_larga as titulo,
	m.descripcion_larga as marca,
	pre.precio1 as precio,
	'S' as moneda,
	'S' as aplicaIGV,
	'S' as mueveStock,
	pre.unidadMedida,
	pre.unidadComercial,
	pre.unidadConversion,
	false multiplo,
	false escala,
	false pack,
	pre.id_unidadventa as unit_id,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select alm.id_almacen, alm.descalmacen as almacen,ex.stock_fisico as stock
        from almacen.tbl_existencia ex
        inner join almacen.tbl_almacen alm on alm.id_almacen=ex.id_almacen
         inner join almacen.tbl_detproducto dp on ex.id_producto=dp.id_producto and dp.id_unidadventa=ex.id_unidadventa and dp.unidad_inventario=true
        where ex.id_producto=p.id_producto
        order by alm.id_almacen asc
      ) d
    ) as stockPorAlmacenes,
    (
      select array_to_json(array_agg(row_to_json(d)))
      from (
        select pre.id_producto as product_id,
		pre.id_unidadventa as unit_id,
		pre.precio1 as price1,
		pre.precio2 as price2,
		pre.precio3 as price3,
		pre.precio4 as price4,
		pre.precio5 as price5 ,
		dp.unidad_inventario as unit_inventory,
		und.desc_corta as  unit,
		pre.val_unidad as value_unit
        from almacen.tbl_precio pre
         inner join almacen.tbl_detproducto dp on pre.id_producto=dp.id_producto and dp.id_unidadventa=pre.id_unidadventa
         inner join almacen.tbl_unidad und on und.id_unidadventa=pre.id_unidadventa
        where pre.id_producto=p.id_producto
        order by und.id_unidadventa asc
      ) d
    ) as unidades
    
  from almacen.tbl_producto p
  inner join almacen.tbl_familiamarca fm on fm.id_familia=p.id_familia and fm.id_marca=p.id_marca
  inner join almacen.tbl_marca m on m.id_marca=fm.id_marca
  inner join almacen.tbl_familia f on f.id_familia=fm.id_familia
  inner join (select 
		pre.id_producto,
		pre.id_unidadventa,
		pre.precio1,
		pre.precio2,
		pre.precio3,
		pre.precio4,
		pre.precio5 ,
		true as muevestock,
		und.desc_corta as  unidadMedida,
		und.desc_corta as  unidadComercial,
		pre.val_unidad as  unidadConversion,
		pre.val_unidad as multiplo
		from almacen.tbl_detproducto dp 
		inner join almacen.tbl_precio pre on dp.id_producto=pre.id_producto and dp.id_unidadventa=pre.id_unidadventa
		inner join almacen.tbl_unidad und on und.id_unidadventa=pre.id_unidadventa
		where unidad_inventario=true
	)pre on pre.id_producto=p.id_producto  
	where  trim(p.codigo)||trim(p.descripcion_larga)  ilike '%'|| _product ||'%'
		 
) t;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;



CREATE OR REPLACE FUNCTION caja.fn_liquidar_turno_colaborador(
	_liquidacion_id bigint,
	_imp_deposito numeric(20,4),
	_imp_tarjeta numeric(20,4),
	_imp_notaabono numeric(20,4),
	_imp_efectivo numeric(20,4),
	_imp_egreso numeric(20,4),
	_imp_saldo_final numeric(20,4),
	_imp_recibido numeric(20,4),
	_imp_diferencia numeric(20,4)
)
returns text[] as $$
declare
	__res text[];
begin
if exists(select 1 from PLANILLAS.tbl_turnocolaborador where liquidacion_id=_liquidacion_id) then
	UPDATE PLANILLAS.tbl_turnocolaborador
		SET 		
			imp_deposito=_imp_deposito,
			imp_tarjeta=_imp_tarjeta,
			imp_notaabono=_imp_notaabono,
			imp_efectivo=_imp_efectivo,
			imp_egreso=_imp_egreso,
			imp_saldo_final=_imp_saldo_final,
			imp_recibido=_imp_recibido,
			imp_diferencia=_imp_diferencia,
			liquidado=true,
			id_estado=2
	 where liquidacion_id=_liquidacion_id;
	 __res:=array['0','Liquidacion cerrada'];
else
	__res:=array['504','Seleccione correctamente el registro'];
end if;
return __res;
end;$$
language plpgsql;



CREATE OR REPLACE FUNCTION almacen.isp_grabarseries(
    op integer,
    __op_movimiento integer,
    __id_usuario character,
    __id_serie bigint,
    __nro_serie character varying,
    __nro_chasis character varying,
    __anio_faricacion integer,
    __anio_modelo integer,
    __id_almacen integer,
    __id_estado integer,
    __id_producto character varying,
    __id_unidadventa integer,
    __observacion text,
    __id_sucursal integer,
    __id_movimiento bigint,
    __item integer)
  RETURNS text[] AS
$BODY$
declare
	__nro__serieOld text;
	__res text[];
begin
if op=1 then
	if not exists(select *from almacen.TBL_SERIEPRODUCTO where NRO_SERIE=__NRO_SERIE and id_estado=1)  then
		select max(id_serie) into __id_serie from almacen.TBL_SERIEPRODUCTO ;
		if __id_serie is null then
			__id_serie:=1;
		else
			__id_serie:=__id_serie+1;
		end if;
		INSERT INTO almacen.tbl_serieproducto(
			nro_serie, 
			nro_chasis, 
			anio_faricacion, 
			anio_modelo, 
			id_almacen, 
			id_estado, 
			fecha_registro, 
			id_usuario_r, 
			id_serie, 
			id_producto, 
			id_unidadventa
		)
		VALUES (
			__nro_serie, 
			__nro_chasis, 
			__anio_faricacion, 
			__anio_modelo, 
			__id_almacen, 
			__id_estado, 
			now(),
			__id_usuario, 
			__id_serie, 
			__id_producto, 
			__id_unidadventa
		)returning array['0','Serie registrada'] into __res;
		if not found then
			__res:=array['504','Inconsistencia Inesperada al registrar el Nro.Serie'];
		end if;
		if __res[1]='0' then
			if __op_movimiento=1 then
				__res:=(select * from COMPRAS.ISP_SERIECOMPRA(
					1 ,
					__id_usuario,
					__id_estado ,
					__id_sucursal,
					__id_movimiento,
					__id_almacen,
					__id_serie,
					__observacion,
					__item
				));
			end if;
			if __op_movimiento=2 then-- por nota de ingreso
				__res:=(select *from ALMACEN.ISP_SERIENOTAINGRESO(
					1,
					0 ,
					__id_movimiento,
					__id_almacen ,
					__id_serie  ,
					__id_sucursal,	
					__id_usuario,
					__id_estado ,	
					__item  ,
					__observacion ,
					true
					));
			end if;
		end if;
	else
		__res:=array['504','El nro.Serie ya se encuentra registrado' || '-' || __nro_serie];
	end if;
end if;
if op=2 then
	if exists(select *from almacen.TBL_SERIEPRODUCTO where id_serie=__id_serie) then
		__nro__serieOld:=(select nro_serie from almacen.TBL_SERIEPRODUCTO where id_serie=__id_serie);
		if __nro__serieOld=__nro_serie then
			UPDATE almacen.tbl_serieproducto
			   SET 
				nro_serie=__nro_serie, 
				nro_chasis=__nro_chasis, 
				anio_faricacion=__anio_faricacion,
				anio_modelo=__anio_modelo, 
				id_almacen=__id_almacen, 
				id_estado=__id_estado, 
				fecha_actualiza=now(), 
				id_usuario_a=__id_usuario,  
				id_producto=__id_producto, 
				id_unidadventa=__id_unidadventa
			 WHERE id_serie=__id_serie;
			__res:=array['0','Registro Actualizado'];
			if __op_movimiento=1 then-- por compra
				__res:=(select * from COMPRAS.ISP_SERIECOMPRA(
					1 ,
					__id_usuario,
					__id_estado ,
					__id_sucursal,
					__id_movimiento,
					__id_almacen,
					__id_serie,
					__observacion,
					__item
				));
			end if;
			if __op_movimiento=2 then-- por nota de ingreso
				__res:=(select *from ALMACEN.ISP_SERIENOTAINGRESO(
					        1,
						0 ,
						__id_movimiento,
						__id_almacen ,
						__id_serie  ,
						__id_sucursal,	
						__id_usuario,
						__id_estado ,	
						__item  ,
						__observacion ,
						true
					));
			end if;
			if __op_movimiento=3 then-- por nota de ingreso
				__res:=(select *from ALMACEN.isp_serieinventario(
					        1,
						0 ,
						__id_movimiento,
						__id_almacen ,
						__id_serie  ,
						__id_sucursal,	
						__id_usuario,
						__id_estado ,	
						__item  ,
						__observacion 
						
					));
			end if;
		else
			__res:=(select *from almacen.isp_grabarseries(
				1,
				__id_usuario  ,
				__id_serie,
				__NRO_SERIE  ,
				__NRO_CHASIS  ,
				__ANIO_FARICACION ,
				__ANIO_MODELO ,
				__id_almacen  ,
				__id_estado   ,
				__id_producto   ,
				__id_unidadventa,
				__observacion 	
			));
		end if;
	else
		__Res:=array['504','Verefique que los registros existan para realizar esta actualización'];
	end if;
end if;
return __Res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.isp_serieinventario(
    op integer,
    _id_serieinventario bigint,
    _id_detinventario bigint,
    _id_almacen integer,
    _id_serie bigint,
    _id_sucursal integer,
    _id_usuario character,
    _id_estado integer,
    _item integer,
    _observaciones text
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	__id bigint;
BEGIN
if op =1  then
	delete from almacen.tbl_seriemovalm where id_movimiento=_id_movimiento and id_serie=_id_serie;
	if exists(select 1 from ALMACEN.TBL_SERIEPRODUCTO where id_serie=_id_serie)then
		if exists(select 1 from almacen.tbl_detinventario where id_detinventario=_id_detinventario)then
			select max(id_serieinventario) into __id from  ALMACEN.tbl_serieinventario;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			INSERT INTO almacen.tbl_seriemovalm(
				fecha_inventario, 
				id_usuario_r, 
				id_estado, 
				id_detinventario, 
				id_almacen, 
				id_serie, 
				id_sucursal, 
				id_serieinventario, 
				item, 
				observaciones, 
				nota_ingreso, 
				nota_salida
			)
			VALUES (
				now(), 
				_id_usuario, 
				_id_estado, 
				_id_detinventario, 
				_id_almacen, 
				_id_serie, 
				_id_sucursal, 
				__id, 
				_item, 
				_observaciones, 
				_nota_ingreso, 
				false
			)returning array['0',id_serieinventario::text] into res;
			if not found then
				res:=array['504','Inconsistencia Inesperada al asociar el Nro.Serie con la toma de inventario'];
			end if;
		else
			res:=array['503','Verefique que exista el movimiento de almacen'];
		end if;
	else
		res:=array['50','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.isp_actilizadetinventario(
    op integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _item integer,
    _cantidad_fisica numeric,
    _costo numeric,
    _importe numeric,
    _cantefectastock boolean,
    _id_estado integer,
    _id_usuario character,
    _cantidad_sistema numeric,
    _id_inventario integer,
    _serie character,
    _numero character,
    _id_almacen integer,
    _id_comprobante integer,
    _inv_incial boolean)
  RETURNS text[] AS
$BODY$
DECLARE
	Res text[];
	dat record;
	cad text;
	_correl integer;
	_fecha_invent timestamp;
BEGIN


if op=1 then
	if exists(select *from almacen.tbl_cabinventario 
		where id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante) then		
		if exists(select *from almacen.tbl_producto where id_producto=_id_producto) then
				select max(item) into _correl from almacen.tbl_detinventario 
				where id_producto=_id_producto and  id_unidadventa=_id_unidadventa and  
				id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante;
			if _correl is null then
				_correl=1;
			else
				_correl=_correl+1;
			end if;
			/*if exists(select *from almacen.tbl_detinventario where id_producto=_id_producto 
			and id_almacen=_id_almacen and id_inventario=_id_inventario and inv_inicial=true) then
				res:=array['503','Ya existe un registro como inventario incial '];
				--exit;			
				return res;
			end if	;	*/	
			 select fecha into _fecha_invent from almacen.tbl_cabinventario cv where  id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante; 
			 
			INSERT INTO almacen.tbl_detinventario(
				    id_producto, 
				    id_unidadventa, 
				    item, 
				    cantidad_fisica, 
				    costo, 
				    importe, 
				    cantefectastock, 
				    fecha, 
				    id_estado, 
				    id_usuario, 
				    cantidad_sistema, 
				    id_inventario, 
				    serie, 
				    numero, 
				    id_almacen, 
				    id_comprobante,
				    inv_inicial
				)
			VALUES (
				    _id_producto, 
				    _id_unidadventa, 
				    _correl, 
				    _cantidad_fisica, 
				    _costo, 
				    _importe, 
				    _cantefectastock, 
				    _fecha_invent, 
				    _id_estado, 
				    _id_usuario, 
				    _cantidad_sistema, 
				    _id_inventario, 
				    _serie, 
				    _numero, 
				    _id_almacen, 
				    _id_comprobante,
				    _inv_incial
				)returning array['0',
						id_producto, 
						id_unidadventa::text, 
						item::text, 
						id_inventario::text, 
						serie, 
						numero, 
						id_almacen::text, 
						id_comprobante::text,id_detinventario::text,'Proceso efectuado con exito'] into res;
			if not found then
				res:=array['503','Ocurri una inconsistencia al registrar el producto '];
				return res;
				--exit;
			end if;
			
		else
			res:=array['502','Verefique el producto es seleccionado correctamente'];
		end if;
	else
		res:=array['502','Verefique que el documento de inventario este seleccionado correactamente'];
	end if;	
end if;
if op=2 then
	IF EXISTS (SELECT *FROM ALMACEN.TBL_DETINVENTARIO WHERE id_producto=_id_producto AND  id_unidadventa=_id_unidadventa AND --item=_item AND  
								id_inventario=_id_inventario AND  serie=_serie AND numero=_numero  AND 
								id_almacen=_id_almacen  AND id_comprobante=_id_comprobante) THEN
		select fecha into _fecha_invent from almacen.tbl_cabinventario cv where  id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante; 
			 
		UPDATE almacen.tbl_detinventario SET  
			cantidad_fisica=cantidad_fisica+_cantidad_fisica, 
			costo=_costo, 
		       importe=_importe, 
		       cantefectastock=_cantefectastock, 
		       fecha=_fecha_invent, 
		       id_estado=_id_estado, 
		       id_usuario=_id_usuario, 
		       cantidad_sistema=_cantidad_sistema ,
		       inv_inicial=_inv_inicial
		WHERE  id_producto=_id_producto AND  id_unidadventa=_id_unidadventa AND --item=_item AND  
		       id_inventario=_id_inventario AND  serie=_serie AND numero=_numero  AND 
		       id_almacen=_id_almacen  AND id_comprobante=_id_comprobante 
		       RETURNING ARRAY['0',
					id_producto, 
					id_unidadventa::text, 
					item::text, 
					id_inventario::text, 
					serie, 
					numero, 
					id_almacen::text, 
					id_comprobante::text,
					id_detinvntario::text,
					'Proceso efectuado con exito'
					] into res;
		if not found then
			res:=array['504','No se ha realizado ninguna actualizacion'];
		end if;
	else
		res:=array['503','No existe el registro en el inventario programado'];
	END IF;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION contabilidad.list__busqueda__x__cuenta(
    IN __op integer,
    IN __id__proceso integer,
    IN __id__empresa integer,
    IN __id__auxiliar integer,
    IN __filtro text)
  RETURNS TABLE(_id_detalleasiento integer, _numeracion_cta character varying, _nombre_cta text, _auxiliar character varying, _mes character varying, _numero_asi integer, _centro_costos character varying, _responsable character varying, _concepto_das character varying, _producto character varying, _nro_documento text, _fecha text, _debe_das numeric, _haber_das numeric) AS
$BODY$
declare
begin
if __op=1 then -- por documento
	return query select 
		dm.id_detalleasiento,
		pc.numeracion_cta,
		pc.nombre_cuenta,
		ax.descripcion as auxiliar,
		m.descripcion as mes,
		cm.numero_asi,
		cco.descripcion_larga as centro_costos,
		dm.responsable,
		COALESCE(dm.concepto_das,'') as concepto_das,
		case when ax.id_auxiliar in(1,2,3) then COALESCE(p.descripcion_larga,'') else COALESCE(cpt.descripcion_larga,'') end as producto,
		(cp.descripcion_corta || '/' ||dm.serie ||'-'|| dm.numero) as nro_documento,
		to_char(dm.fechadoc_das,'dd/mm/yyyy') as fecha,
		dm.debe_das,
		dm.haber_das
	from contabilidad.tbl__asiento__contable cm
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)
		inner join contabilidad.tbl_subdiario sub on sub.id=cm.subdiario_id
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
		inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dm.id_plancuenta)
		inner join contabilidad.tbl_centrocosto cco on (cco.id_centrocostos=dm.id_centrocostos)
		inner join common.tbl_comprobante cp on (cp.id_comprobante=dm.id_comprobante)
		inner join common.tbl_mes m on (m.id_mes=date_part('month',fechadoc_das))
		left join almacen.tbl_producto p on (p.id_producto=dm.id_producto)
		left join common.tbl_concepto cpt on  cpt.id_concepto=dm.id_producto
		where 	
			cm.id_empresa=__id__empresa 
			and cm.id_proceso=__id__proceso
			and ax.id_auxiliar =__id__auxiliar
			and (cp.descripcion_corta || '/' ||dm.serie ||'-'|| dm.numero) ilike '%'|| __filtro ||'%';
end if;
if __op=2 then --por responsable
	return query select 
		dm.id_detalleasiento,
		pc.numeracion_cta,
		pc.nombre_cuenta,
		ax.descripcion as auxiliar,
		m.descripcion as mes,
		cm.numero_asi,
		cco.descripcion_larga as centro_costos,
		dm.responsable,
		COALESCE(dm.concepto_das,'') as concepto_das,
		case when ax.id_auxiliar in(1,2,3) then COALESCE(p.descripcion_larga,'') else COALESCE(cpt.descripcion_larga,'') end as producto,
		(cp.descripcion_corta || '/' ||dm.serie ||'-'|| dm.numero) as nro_documento,
		to_char(dm.fechadoc_das,'dd/mm/yyyy') as fecha,
		dm.debe_das,
		dm.haber_das
	from contabilidad.tbl__asiento__contable cm
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)
		inner join contabilidad.tbl_subdiario sub on sub.id=cm.subdiario_id
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
		inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dm.id_plancuenta)
		inner join contabilidad.tbl_centrocosto cco on (cco.id_centrocostos=dm.id_centrocostos)
		inner join common.tbl_comprobante cp on (cp.id_comprobante=dm.id_comprobante)
		inner join common.tbl_mes m on (m.id_mes=date_part('month',fechadoc_das))
		left join almacen.tbl_producto p on (p.id_producto=dm.id_producto)
		left join common.tbl_concepto cpt on  cpt.id_concepto=dm.id_producto
		where 	
			cm.id_empresa=__id__empresa
			and cm.id_proceso=__id__proceso
			and ax.id_auxiliar =__id__auxiliar
			and dm.responsable ilike '%'|| __filtro ||'%';
end if;	
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

CREATE OR REPLACE FUNCTION contabilidad.list_asientocontable(
    IN __id_proceso integer,
    IN __id_auxiliar integer,
    IN __id_comprobante integer,
    IN __serie text,
    IN __numero text)
  RETURNS TABLE(_id_asiento integer, _tipo character, _serie text, _numero character varying, _fecha_registro text, _fecha_docdas text, _dni_ruc character varying, _responsable character varying, _debe numeric, _haber numeric, _id_estado integer) AS
$BODY$
declare
begin

return query select 
ac.id_asiento,
tc.descripcion_corta as tipo,
 (dc.serie || '-' || ac.numero_asi::text)::text as serie,
 dc.numero,
to_char(dc.fecha_contable,'dd/mm/yyyy') as fecha_registro ,
to_char(dc.fechadoc_das,'dd/mm/yyyy') as fecha_docdas ,
p.doc_persona dni_ruc,
p.nombre_razon as responsable,
sum(dc.debe_das) as debe,
sum(dc.haber_das) as haber,
dc.id_estado
from contabilidad.tbl__asiento__contable ac
inner join contabilidad.tbl_subdiario sub on sub.id=ac.subdiario_id
inner join contabilidad.tbl_auxiliar aux on aux.id_auxiliar=sub.auxiliar_id
inner join contabilidad.tbl__detalle__asiento__contable dc on ac.id_asiento=dc.id_asiento
inner join planillas.tbl_persona p on p.id_persona=dc.id__persona
inner join common.tbl_comprobante tc on tc.id_comprobante=dc.id_comprobante
where aux.id_auxiliar=__id_auxiliar and ac.id_proceso=__id_proceso-- and dc.id_comprobante=__id_comprobante and  and dc.serie=__serie and dc.numero=__numero
group by tc.descripcion_corta ,dc.serie,dc.numero ,
to_char(dc.fecha_contable,'dd/mm/yyyy')  ,to_char(dc.fechadoc_das,'dd/mm/yyyy'),p.doc_persona,
p.nombre_razon ,ac.id_asiento,dc.id_estado
order by ac.numero_asi asc;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE FUNCTION contabilidad.list_consultarasientos(
    IN op integer,
    IN __id_auxiliar integer,
    IN __id_proceso integer)
  RETURNS TABLE(
	id_asiento integer, 
	auxiliar character varying, 
	proceso character varying, 
	mes character varying, 
	nrovaucher integer, 
	fecha_asi timestamp without time zone, 
	glosa_asi character varying, 
	debe numeric, 
	haber numeric, 
	usuario_reg character varying, 
	fecha_reg text, 
	fecha_anula text, 
	usuario_anula character varying, 
	id_estado integer,
	subdiario varchar(100)
) AS
$BODY$
declare
begin
return query select 
	ac.id_asiento,
	aux.descripcion as auxiliar,
	pc.descripcion as proceso,
	m.descripcion as mes,
	ac.numero_asi as nroVaucher,
	ac.fecha_Asi,
	ac.glosa_asi,
	COALESCE(ac.debe_asi,0) as debe,
	COALESCE(ac.haber_asi,0) as haber,
	COALESCE(ac.usuarioreg_asi,'') as usuario_reg,
	COALESCE(to_char(ac.fechareg_asi::date,'dd/mm/yyyy')::text,'') as fechareg_asi ,
	COALESCE(to_char(ac.fechaanulacion_asi::date,'dd/mm/yyyy')::text,'') fechaanulacion,
	--to_char(ac.fechaanulacion_asi,'dd/mm/yyyy') as fechaanulacion,
	COALESCE(ac.usuarioanulacion_asi,'') as usuario_anula,
	ac.id_estado,
	sub.name as subdiario
from  contabilidad.tbl__asiento__contable ac
inner join contabilidad.tbl_subdiario sub on sub.id=ac.subdiario_id
inner join contabilidad.tbl_auxiliar aux on aux.id_auxiliar=sub.auxiliar_id
inner join contabilidad.tbl_procesocontable pc on pc.id_proceso=ac.id_proceso
inner join  common.tbl_mes m on m.id_mes=ac.mes_asi
where aux.id_auxiliar=__id_auxiliar and ac.id_proceso=__id_proceso 
order by ac.numero_asi asc;

end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


select * from contabilidad.list_consultarasientos_detallado(0,4,4)

update contabilidad.tbl__detalle__asiento__contable set debe_das=haber_das,haber_das=debe_das where id_asiento  in(
	select id_Asiento from contabilidad.tbl__asiento__contable  where numero_asi in(3,7,10,11,12,13,18,19,21,28,29,33,34,35,37,41,42,43,45,47,49,51,53,54,56,57,65,71,72,73,76,77,79,84,87,89,92,94,97,98,105,109,111,115,120,121,125,129,130)
) 


update contabilidad.tbl__detalle__asiento__contable set debe_das=haber_das,haber_das=debe_das where id_asiento  in(
	select id_Asiento from contabilidad.tbl__asiento__contable  where numero_asi in(3)
) 

CREATE OR REPLACE FUNCTION contabilidad.list_consultarasientos_detallado(
    IN op integer,
    IN __id_auxiliar integer,
    IN __id_proceso integer)
  RETURNS TABLE(
	nro_vaucher integer, 	
	proceso character varying, 
	mes character varying, 
	fecha_asi timestamp without time zone, 
	auxiliar character varying, 
	subdiario varchar(100),
	cuenta text,
	denomicacion_cuenta text,
	debe numeric, 
	haber numeric, 	
	glosa_asi character varying, 
	nro_operacion varchar(100),
	documento text,
	fecdoc text, 
	conepto varchar(100),	
	responsable varchar(100)	 
) AS
$BODY$
declare
begin
return query select 
	ac.numero_asi as nro_Vaucher,
	pc.descripcion as proceso,
	m.descripcion as mes,
	ac.fecha_Asi,	 
	aux.descripcion as auxiliar,
	sub.name as subdiario,
	cta.nro_cuenta,
	cta.nombre_cuenta,
	COALESCE(dac.debe_das,0) as debe,
	COALESCE(dac.haber_das,0) as haber,
	ac.glosa_asi,	
	ac.nro_operacion,
	(c.descripcion_corta || '/' || dac.serie || '-' || dac.numero) as Documento, 
	to_char(dac.fechadoc_das,'dd/MM/yyyy') as fechadoc_das,
	cto.descripcion_larga as concepto,	
	dac.responsable
from  contabilidad.tbl__asiento__contable ac
inner join contabilidad.tbl_subdiario sub on sub.id=ac.subdiario_id
inner join contabilidad.tbl_auxiliar aux on aux.id_auxiliar=sub.auxiliar_id
inner join contabilidad.tbl_procesocontable pc on pc.id_proceso=ac.id_proceso
inner join  common.tbl_mes m on m.id_mes=ac.mes_asi
inner join  contabilidad.tbl__detalle__asiento__contable dac on dac.id_asiento=ac.id_asiento
inner join contabilidad.tbl_plancuenta cta on cta.id_plancuenta=dac.id_plancuenta
inner join contabilidad.tbl_centrocosto cco on cco.id_centrocostos=dac.id_centrocostos
inner join planillas.tbl_persona per on per.id_persona=dac.id__persona
inner join common.tbl_concepto cto on cto.id::text=dac.id_producto
inner join common.tbl_comprobante c on c.id_comprobante=dac.id_comprobante

where aux.id_auxiliar=__id_auxiliar and ac.id_proceso=__id_proceso and dac.id_estado=1
order by ac.numero_asi asc,cta.nro_cuenta desc;

end;$BODY$
  LANGUAGE plpgsql ;
   

select *from contabilidad.tbl_auxiliar
select *from contabilidad.tbl_subdiario

select *from contabilidad.tbl__detalle__asiento__contable where id_asiento=65

CREATE OR REPLACE FUNCTION contabilidad.fn__detalle__asiento__contable(
    op integer,
    __id_detalleasiento bigint,
    __fechadoc_das text,
    __serie character,
    __numero character varying,
    __debe_das numeric,
    __haber_das numeric,
    __responsable character varying,
    __id_plancuenta bigint,
    __id_centrocostos integer,
    __id_comprobante integer,
    __id_asiento bigint,
    __concepto_das character varying,
    __debehaber numeric,
    __tipo_das character,
    __id_estado integer,
    __id_movasientos bigint,
    __id_proceso integer,
    __id_mes integer,
    __id_auxiliar integer,
    __id_sucursal integer,
    __id_tablamov integer,
    __id_empresa integer,
    __id_concepto character varying,
    __id_tipocambio integer,
    __id_moneda integer,
    __id_persona character varying,
    __doc_persona character varying,
    __debe_asi numeric,
    __haber_asi numeric,
    __fecha_contable text,
    __tipo_cambio numeric,
    __anio integer,
    __nro_operacion varchar(50),
    __glosa varchar(1500)
)
  RETURNS text[] AS
$BODY$
declare
	__id__asiento_C integer;
	__res text[];
	__numero_asi integer;
	
begin
if op=1 then	 
	if exists(select *from contabilidad.tbl_plancuenta where id_plancuenta=__id_plancuenta) then
		if exists(select *from common.tbl_comprobante where id_comprobante=__id_comprobante)then
			INSERT INTO contabilidad.tbl__detalle__asiento__contable(
				fechadoc_das, 
				serie, 
				numero, 
				debe_das, 
				haber_das, 
				responsable, 
				id_plancuenta, 
				id_centrocostos, 
				id_comprobante, 
				id_asiento, 
				concepto_das, 
				debehaber, 
				tipo_das, 
				id_estado, 
				id_movasientos, 
				id_tablamov,
				id_sucursal,
				id_producto,
				id_tipocambio,
				id_moneda,
				doc__persona,
				id__persona,
				fecha_contable,
				fecha_registro,
				anio,
				id_mes,
				tipo_cambio
				)
			VALUES (
				to_timestamp(__fechadoc_das,'YYYY-MM-DD HH24:MI:SS.MS'), 
				__serie, 
				__numero, 
				__debe_das, 
				__haber_das, 
				__responsable, 
				__id_plancuenta, 
				__id_centrocostos, 
				__id_comprobante, 
				__id_movasientos, 
				__concepto_das, 
				__debehaber, 
				__tipo_das, 
				__id_estado, 
				__id_movasientos, 
				__id_tablamov,
				__id_sucursal,
				__id_concepto,
				__id_tipocambio,
				__id_moneda,
				__doc_persona,
				__id_persona,
				__fecha_contable::date,
				now(),
				__anio,
				__id_mes,
				__tipo_cambio
			)returning array['0','Proceso efectuado con exito'] INTO __res;
			if not found then
				__res:=array['502','Inconsistencia inesperada al genrar el asiento'];
			end if;
		else
			__res:=array['503','Verefique que exista el comprobante de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el plan de cuentas'];
	end if;
end if;
if op=2 then
	if exists(select 1 from contabilidad.tbl__asiento__contable where id_asiento=__id_asiento) then
		if exists(select 1 from contabilidad.tbl__detalle__asiento__contable where id_detalleasiento=__id_detalleasiento) then
			update	contabilidad.tbl__detalle__asiento__contable 
				set
				fechadoc_das=__fechadoc_das::date, 
				serie=__serie, 
				numero=__numero, 
				debe_das=__debe_das, 
				haber_das=__haber_das, 
				responsable=__responsable, 
				id_plancuenta=__id_plancuenta, 
				id_centrocostos=__id_centrocostos, 
				id_comprobante=__id_comprobante, 
				concepto_das=__concepto_das, 
				debehaber=__debehaber, 
				tipo_das=__tipo_das, 
				id_estado=__id_estado,  
				id_tablamov=__id_tablamov,
				id_sucursal=__id_sucursal,
				id_producto=__id_concepto,
				id_tipocambio=__id_tipocambio,
				id_moneda=__id_moneda,
				doc__persona=__doc_persona,
				id__persona=__id_persona,
				fecha_contable=__fecha_contable::date,
				anio=__anio,
				id_mes=__id_mes,
				tipo_cambio=__tipo_cambio
			where id_detalleasiento=__id_detalleasiento;
			__res:=array['0','Detalle asiento contable actualizado'];
		else
			__res:=array['503','Verefique que existe el detalle de asiento contable'];
		end if;
	else
		__res:=array['503','Verefique que exista el asiento contable'];
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from CONTABILIDAD.fn__asiento__contable(2,67,'pago',1,5,1,13,1,1,150,1,'80.0','80.0','2019-01-20 10:12:03.973')

select *from contabilidad.tbl__detalle__asiento__contable where id_asiento=67

select * from contabilidad.fn_get_asiento_contable(67)

CREATE OR REPLACE FUNCTION contabilidad.fn__asiento__contable(
    op integer,
    __id_asiento bigint,
    __concepto_asi character varying,
    __id_estado integer,
    __id_proceso integer,
    __mes__asi integer,
    __id_subdiario integer,
    __id_sucursal integer,
    __id_empresa integer,
    __id_tipocambio integer,
    __id_moneda integer,
    __debe_asi numeric,
    __haber_asi numeric,
    __fecha_asi text,
    __nro_operacion varchar(100)
)
  RETURNS text[] AS
$BODY$
declare
	
	__res text[];
	__numero_asi integer;
begin
if op=1 then
	if  exists(select * from  contabilidad.tbl_subdiario  where id=__id_subdiario)then
		select max(COALESCE(numero_asi,0)) into __numero_asi from contabilidad.tbl__asiento__contable;
		if __numero_asi is null then
			__numero_asi:=1;
		else
			__numero_asi:=__numero_asi+1;
		end if;
		insert into contabilidad.tbl__asiento__contable(
			id_empresa,
			id_proceso,
			subdiario_id,
			fecha_asi,
			id_estado,
			mes_asi,
			glosa_asi,
			numero_asi,
			debe_asi,
			haber_asi,
			nro_operacion
		)values(
			__id_empresa,
			__id_proceso,
			__id_subdiario,
			__fecha_asi::timestamp,
			__id_estado,
			__mes__asi,
			__concepto_asi,
			__numero_asi,
			__debe_asi,
			__haber_asi,
			__nro_operacion
		)returning   array['0',id_asiento::text] into __res;
		if not found then
			__res:=array['504','Inconsistencia Inesperada'];
		end if;
	else
		__res:=array['501','Seleccione correctamente el sub-diario'];
	end if;
end if;
if op=2 then
	if exists(select 1 from contabilidad.tbl__asiento__contable where id_asiento=__id_asiento) then 
		update contabilidad.tbl__asiento__contable set
			id_proceso=__id_proceso,
			subdiario_id=__id_subdiario,
			fecha_asi=__fecha_asi::timestamp,
			mes_asi=__mes__asi,
			glosa_asi=__concepto_asi,
			debe_asi=__debe_asi,
			haber_asi=__haber_asi,
			nro_operacion=__nro_operacion
		where id_asiento=__id_asiento;
		__res:=array['0',__id_asiento::text,'Asiento actualizado'];
	else
		__res:=array['501','Verifique que exista el asiento contable'];
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select CONTABILIDAD.FN_CORREGIR_VOUCHER()  
CREATE OR REPLACE FUNCTION CONTABILIDAD.FN_CORREGIR_VOUCHER()
RETURNS TEXT AS $$
DECLARE
	dat record;
	numero integer;
BEGIN
	numero:=1;
	for dat in select * from contabilidad.tbl__asiento__contable  order by id_asiento asc loop
		update contabilidad.tbl__asiento__contable  set numero_asi=numero where id_asiento=dat.id_asiento;
		numero:=numero+1;
	end loop;
return '';
END;$$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION caja.spi_detmovcaja(
    op integer,
    _id_detmovpago integer,
    _id_banco integer,
    _id_movimcaja integer,
    _id_formapago character,
    _id_tarjeta integer,
    _id_tipocambio integer,
    _imp_pago numeric,
    _id_sucursal integer,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _nro_operacion text,
    _fec_pago text,
    _id_estado integer,
    _glosa text,
    _id_moneda integer,
    _id_cuenta integer,
    _imp_mora numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if exists(select *from CAJA.TBL_MOVCAJA where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
		select max(id_detmovpago) into correl from CAJA.TBL_DETMOVPAGO where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal;
		if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_DETMOVPAGO(
				id_detmovpago,
				id_banco,
				id_movimcaja ,
				id_formapago ,
				id_tarjeta   ,
				id_tipocambio,
				imp_pago     ,
				id_sucursal  ,
				imp_recibido ,
				imp_vuelto   ,
				nro_operacion ,
				fec_pago      ,
				id_estado     ,
				glosa         ,
				id_moneda,
				id_cuenta,
				imp_mora
		)values(
				correl,
				_id_banco,
				_id_movimcaja ,
				_id_formapago ,
				_id_tarjeta   ,
				_id_tipocambio,
				_imp_pago     ,
				_id_sucursal  ,
				_imp_recibido ,
				_imp_vuelto   ,
				_nro_operacion ,
				to_timestamp(_fec_pago,'YYYY-MM-DD HH24:MI:SS.MS')       ,
				_id_estado     ,
				_glosa         ,
				_id_moneda,
				_id_cuenta,
				_imp_mora
		)returning array[
				'0',
				TBL_DETMOVPAGO.id_movimcaja::text,
				TBL_DETMOVPAGO.id_sucursal::text,
				TBL_DETMOVPAGO.id_detmovpago::text
			] into res;
		if not found then
			res:=array['504','Verefique que los importes esten ingresados correctamente..!!'];
		end if;
	else
		res:=array['503','la cabecera del movimiento de pago no existe'];
	end if;
end if;
if op=2 then
	if exists(select *from CAJA.TBL_MOVCAJA where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
		select max(id_detmovpago) into correl from CAJA.TBL_DETMOVPAGO where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal;
		if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_DETMOVPAGO(
				id_detmovpago,
				id_banco,
				id_movimcaja ,
				id_formapago ,
				id_tarjeta   ,
				id_tipocambio,
				imp_pago     ,
				id_sucursal  ,
				imp_recibido ,
				imp_vuelto   ,
				nro_operacion ,
				fec_pago      ,
				id_estado     ,
				glosa         ,
				id_moneda     ,
				id_cuenta,
				imp_mora
		)values(
				correl,
				_id_banco,
				_id_movimcaja ,
				_id_formapago ,
				_id_tarjeta   ,
				_id_tipocambio,
				_imp_pago     ,
				_id_sucursal  ,
				_imp_recibido ,
				_imp_vuelto   ,
				_nro_operacion ,
				to_timestamp(_fec_pago,'YYYY-MM-DD HH24:MI:SS.MS')       ,
				_id_estado     ,
				_glosa         ,
				_id_moneda,
				_id_cuenta,
				_imp_mora
		)returning array[
				'0',
				TBL_DETMOVPAGO.id_movimcaja::text,
				TBL_DETMOVPAGO.id_sucursal::text,
				TBL_DETMOVPAGO.id_detmovpago::text
			] into res;
		if not found then
			res:=array['504','Verefique que los importes esten ingresados correctamente..!!'];
		end if;
	else
		res:=array['503','la cabecera del movimiento de pago no existe'];
	end if;
	/*if exists(select *from CAJA.TBL_DETMOVPAGO where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal and  id_detmovpago=_id_detmovpago) then
		update CAJA.TBL_DETMOVPAGO set 
				id_banco=_id_banco,
				id_formapago=_id_formapago ,
				id_tarjeta=_id_tarjeta   ,
				id_tipocambio=_id_tipocambio,
				imp_pago=_imp_pago     ,
				imp_recibido=_imp_recibido ,
				imp_vuelto=_imp_vuelto   ,
				nro_operacion=_nro_operacion ,
				fec_pago=to_timestamp(_fec_pago,'YYYY-MM-DD HH24:MI:SS.MS')      ,
				id_estado=_id_estado     ,
				glosa=_glosa         ,
				id_moneda=_id_moneda where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal and  id_detmovpago=_id_detmovpago;
			res:=array['0','Proceso efectuado con exito'];
	else
		res:=array['504','Verefique este ingresado correctamente el movimiento de caja'];
	end if;*/
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.fn_serie_producto_compra(
    _id_compra bigint,
    _id_sucursal integer,
    _id_producto character varying,
    _id_unimed integer)
  RETURNS text AS
$BODY$
DECLARE 
SERIE text;
registro record;
BEGIN 
serie='';
FOR registro in select * from almacen.tbl_seriecompra sc
inner join almacen.tbl_serieproducto ser on (ser.id_serie=sc.id_serie)
where sc.id__compra=_id_compra and sc.id_sucursalcompra=_id_sucursal  and TRIM(ser.id_producto)=TRIM(_id_producto) and ser.id_unidadventa=_id_unimed  loop
SERIE:= SERIE || E'\n' || COALESCE(registro.nro_serie,'');  --||
 
end loop;
return SERIE;
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  

CREATE OR REPLACE  FUNCTION contabilidad.job__compras(
    __id__subdiario integer,
    __id__mes integer,
    __anio integer,
    __id__proceso integer,
    __id__empresa integer)
  RETURNS text[] AS
$BODY$
DECLARE 
	__cur__compras  refcursor;
        __rec__compras record;
	__id__asiento_C integer;
	__res text[];
	__numero_asi integer;
	__rec__impuestos record;
	imp_debe numeric(20,2);
	imp_haber numeric(20,2);
	imp_formula varchar(50);
	__recdat__compras record;
	__ind integer;
	__IndexConta integer;
	__imp_debemov numeric(20,4);
	__imp_habermov numeric(20,4);
	__rec__destino__debe record;
	__rec__destino__haber record;
BEGIN

CREATE TEMPORARY TABLE  tmp_compras_val (
	id_comprobante integer,
	fecha timestamp,
	numero varchar(15),
	serie char(4),
	tipo_documento varchar(30),
	codigo_Sunat text,
	cliente text,
	moneda varchar(30),
	tipocambio numeric(20,4),
	id_auxiliar integer,
	precio numeric(20,5),
	id_compra bigint,
	id_sucursal integer,
	id_operacion integer,
	imp_igv numeric(20,4),
	valor_venta numeric(20,4),
	importe numeric(20,4),	
	concepto_das varchar(200),
	item integer,
	actualizado boolean ,
	contabilizado_cad varchar(50),
	id_centrocostos integer,
	tipo_das char(1),
	id_estado integer,
	id_movasiento bigint,
	id_tablamov integer,
	id_igv integer,
	porcent_igv numeric(20,4),
	id_cuentadebe integer,
	id_cuentahaber integer,
	id_producto varchar(20),
	id_mes integer,
	anio integer,
	fecha_registro timestamp,
	fecha_contable timestamp,
	doc_persona varchar(12),
        id_persona varchar(15),
        codigo_movcab bigint
	

)ON COMMIT DROP;
	--OPEN __cur__compras FOR  

	INSERT INTO tmp_compras_val(
		id_comprobante ,
		fecha ,
		numero ,
		serie ,
		tipo_documento ,
		codigo_Sunat ,
		cliente ,
		moneda ,
		tipocambio ,
		id_auxiliar ,
		precio ,
		id_compra ,
		id_sucursal ,
		id_operacion ,
		imp_igv ,
		valor_venta ,
		importe ,	
		concepto_das ,
		item ,
		actualizado  ,
		contabilizado_cad ,
		id_centrocostos ,
		tipo_das ,
		id_estado ,
		id_movasiento ,
		id_tablamov ,
		id_igv ,
		porcent_igv ,
		id_cuentadebe ,
		id_cuentahaber ,
		id_producto ,
		id_mes,
		anio,
		fecha_registro,
		fecha_contable,
		doc_persona,
		id_persona,
		codigo_movcab
	)
	select 
	cp.id_comprobante,
	f.fec_ingsistema as fecha,
	f.nro_doc_compra as numero,
	f.serie as serie,
	cp.descripcion_larga as tipo_documento,
	cp.codigosunat,
	trim(cli.NOMBRE_RAZON)    as cliente,
	m.descripcion_larga as moneda,
	tc.venta as tipocambio,
	1::integer as id_auxiliar,
	df.precio*f.tipo_cambio as precio,
	(cast(df.id__compra as varchar(20))|| '' || cast(df.id_sucursalcompra as text))::bigint as id_compra,
	df.id_sucursalcompra as id_sucursal,
	f.id_operacion,
	df.imp_igv*f.tipo_cambio as imp_tipocambio,
	df.imp_venta*f.tipo_cambio as valor_venta,
	df.imp_incluido*f.tipo_cambio as importe,
	p.descripcion_larga as  concepto_das,
	df.item,
	df.actualizado,
	df.contabilizado_cad,
	1 as id_centrocostos,
	''::char(1) tipo_das,
	df.id_estado,
	id__detcompra as id_movasientos,
	1 as id_tablamov,
	F.ID_IGV,
	ig.IMP_IGV as porcent_igv,
	conf.id_cuentadebe,
	conf.id_cuentahaber,
	df.id_producto,
	date_part('month',f.fec_ingsistema::date) as id_mes,
	date_part('year',f.fec_ingsistema::date) as anio,
	now() as fecha_registro,
	f.fec_ingsistema as fecha_contable,
	cli.doc_persona,
	cli.id_persona,
	f.id__compra
  from 
  compras.tbl_compra f
  INNER JOIN COMMON.TBL_IGV IG ON (IG.ID_IGV=F.ID_IGV)
  inner join common.tbl_comprobante cp on (cp.id_comprobante=f.id_comprobante)
  inner join contabilidad.tbl_axuliardocumento adx on (adx.id_comprobante=f.id_comprobante and adx.subdiario_id=__id__subdiario)
  INNER JOIN COMMON.TBL_SUCURSAL SC ON (SC.ID_SUCURSAL=F.id_sucursalcompra)
  inner join common.tbl_moneda m on (m.id_moneda=f.id_moneda)
  inner join common.tbl_tipocambio tc on (tc.id_tipocambio=f.id_tipocambio)
  inner join planillas.tbl_persona cli on (cli.id_persona=f.id_proveedor)
  inner join compras.tbl_detcompra df on (f.id_sucursalcompra=df.id_sucursalcompra and f.anio=df.anio and  f.id_compra=df.id_compra and f.id_mes=df.id_mes)
  inner join contabilidad.tbl_configuracioncuenta conf on (conf.id_producto=df.id_producto and conf.id_auxiliar=__id__subdiario)
  inner join contabilidad.tbl_plancuenta debe on (debe.id_plancuenta=conf.id_cuentadebe)
  inner join contabilidad.tbl_plancuenta haber on (haber.id_plancuenta=conf.id_cuentahaber)
  inner join almacen.tbl_producto p on (p.id_producto=df.id_producto)  
  where position('AV1' IN df.contabilizado_cad)=0  and sc.id_empresa=__id__empresa and date_part('year',fec_ingsistema)=__anio;

    if not exists(select * from contabilidad.tbl__asiento__contable where id_proceso=__id__proceso and date_part('month',fecha_asi)=__id__mes  and subdiario_id=__id__subdiario)then
		select max(COALESCE(numero_asi,0))+1 into __numero_asi from contabilidad.tbl__asiento__contable;
		if __numero_asi is null then
			__numero_asi:=1;
		else
			__numero_asi:=__numero_asi+1;
		end if;
		insert into contabilidad.tbl__asiento__contable(
			id_empresa,
			id_proceso,
			subdiario_id,
			fecha_asi,
			id_estado,
			mes_asi,
			glosa_asi,
			numero_asi
		)values(
			__id__empresa,
			__id__proceso,
			__id__subdiario,
			now(),
			  1,
			__id__mes,
			'DS_SISTEMAS',
			__numero_asi
		)returning id_asiento into __id__asiento_c;
	else
		__id__asiento_c:=(select id_asiento from contabilidad.tbl__asiento__contable where id_proceso=__id__proceso and mes_asi=__id__mes);
	end if;


	FOR __rec__compras in select *from tmp_compras_val loop			
		for __rec__impuestos in select plancuentadebe_id,plancuentahaber_id from contabilidad.TBL_CONFIGIMPUESTO
										where subdiario_id=__id__subdiario and enterprise_id=__id__empresa 
			loop
				if COALESCE(__rec__impuestos.plancuentadebe_id,0)<>0  and __rec__impuestos.id_cuentadebe<>0 then			
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, 
						serie, 
						numero, 
						debe_das, 
						haber_das, 
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, 
						__rec__compras.serie, 
						__rec__compras.numero, 
						__rec__compras.imp_igv, 
						0, 
						__rec__compras.cliente, 
						__rec__impuestos.plancuentadebe_id, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) returning array['0'] into __res;
					--print '--';		
					--Inicio de destinos del debe
					for __rec__destino__debe in select id_plancuenta,id_debe,id_haber,porcent_desitrib from contabilidad.tbl_destinos_cuenta 
						where id_plancuenta =__rec__impuestos.plancuentadebe_id and id_estado=1 
						loop
						if __rec__destino__debe.id_debe<>0 then
							INSERT INTO contabilidad.tbl__detalle__asiento__contable(
								fechadoc_das, 
								serie, 
								numero, 
								debe_das, 
								haber_das, 
								responsable, 
								id_plancuenta, 
								id_centrocostos, 
								id_comprobante, 
								id_asiento, 
								concepto_das, 
								debehaber, 
								tipo_das, 
								id_estado, 
								id_movasientos, 
								id_tablamov,
								id_sucursal,
								id_producto,
								id_mes,
								anio,
								fecha_registro,
								fecha_contable,
								doc__persona,
								id__persona,
								codigo_movcab
							)
							VALUES (
								__rec__compras.fecha, 
								__rec__compras.serie, 
								__rec__compras.numero, 
								__rec__compras.imp_igv*(__rec__destino__debe.porcent_desitrib/100), 
								0, 
								__rec__compras.cliente, 
								__rec__destino__debe.id_debe, 
								__rec__compras.id_centrocostos, 
								__rec__compras.id_comprobante, 
								__id__asiento_c, 
								__rec__compras.concepto_das, 
								__rec__compras.importe, 
								__rec__compras.tipo_das, 
								__rec__compras.id_estado, 
								__rec__compras.id_movasiento, 
								__rec__compras.id_tablamov,
								__rec__compras.id_sucursal,
								__rec__compras.id_producto,
								__rec__compras.id_mes,
								__rec__compras.anio,
								now(),
								__rec__compras.fecha_contable,
								__rec__compras.doc_persona,
								__rec__compras.id_persona,
								__rec__compras.codigo_movcab
							) ;
						end if;
						if __rec__destino__debe.id_haber<>0 then
							INSERT INTO contabilidad.tbl__detalle__asiento__contable(
								fechadoc_das, 
								serie, 
								numero, 
								debe_das, 
								haber_das, 
								responsable, 
								id_plancuenta, 
								id_centrocostos, 
								id_comprobante, 
								id_asiento, 
								concepto_das, 
								debehaber, 
								tipo_das, 
								id_estado, 
								id_movasientos, 
								id_tablamov,
								id_sucursal,
								id_producto,
								id_mes,
								anio,
								fecha_registro,
								fecha_contable,
								doc__persona,
								id__persona,
								codigo_movcab
							)
							VALUES (
								__rec__compras.fecha, 
								__rec__compras.serie, 
								__rec__compras.numero, 
								__rec__compras.imp_igv*(__rec__destino__debe.porcent_desitrib/100), 
								0, 
								__rec__compras.cliente, 
								__rec__destino__debe.id_haber, 
								__rec__compras.id_centrocostos, 
								__rec__compras.id_comprobante, 
								__id__asiento_c, 
								__rec__compras.concepto_das, 
								__rec__compras.importe, 
								__rec__compras.tipo_das, 
								__rec__compras.id_estado, 
								__rec__compras.id_movasiento, 
								__rec__compras.id_tablamov,
								__rec__compras.id_sucursal,
								__rec__compras.id_producto,
								__rec__compras.id_mes,
								__rec__compras.anio,
								now(),
								__rec__compras.fecha_contable,
								__rec__compras.doc_persona,
								__rec__compras.id_persona,
								__rec__compras.codigo_movcab
							) ;
						end if;
					end loop;
						--imp_debe:= (select imp_formula);
					if not found then
						RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
					end if;
				end if;
				if COALESCE(__rec__impuestos.plancuentahaber_id,0)<>0 and __rec__impuestos.plancuentahaber_id<>0 then			
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, --1
						serie, --2
						numero, --3
						debe_das, --4
						haber_das, --5
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, --1
						__rec__compras.serie, --2
						__rec__compras.numero, --3
						0, --4
						__rec__compras.imp_igv, --5
						__rec__compras.cliente, 
						__rec__impuestos.plancuentahaber_id, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) returning array['0'] into __res;
					
					--Inicio de destinos del debe
					for __rec__destino__haber in select id_plancuenta,id_debe,id_haber,porcent_desitrib from contabilidad.tbl_destinos_cuenta 
						where id_plancuenta =__rec__impuestos.plancuentahaber_id and id_estado=1 
						loop
						if __rec__destino__haber.id_debe<>0 then
							--Debe
							INSERT INTO contabilidad.tbl__detalle__asiento__contable(
								fechadoc_das, 
								serie, 
								numero, 
								debe_das, 
								haber_das, 
								responsable, 
								id_plancuenta, 
								id_centrocostos, 
								id_comprobante, 
								id_asiento, 
								concepto_das, 
								debehaber, 
								tipo_das, 
								id_estado, 
								id_movasientos, 
								id_tablamov,
								id_sucursal,
								id_producto,
								id_mes,
								anio,
								fecha_registro,
								fecha_contable,
								doc__persona,
								id__persona,
								codigo_movcab
							)
							VALUES (
								__rec__compras.fecha, 
								__rec__compras.serie, 
								__rec__compras.numero, 
								__rec__compras.imp_igv*(__rec__destino__haber.porcent_desitrib/100), 
								0, 
								__rec__compras.cliente, 
								__rec__destino__haber.plancuentadebe_id, 
								__rec__compras.id_centrocostos, 
								__rec__compras.id_comprobante, 
								__id__asiento_c, 
								__rec__compras.concepto_das, 
								__rec__compras.importe, 
								__rec__compras.tipo_das, 
								__rec__compras.id_estado, 
								__rec__compras.id_movasiento, 
								__rec__compras.id_tablamov,
								__rec__compras.id_sucursal,
								__rec__compras.id_producto,
								__rec__compras.id_mes,
								__rec__compras.anio,
								now(),
								__rec__compras.fecha_contable,
								__rec__compras.doc_persona,
								__rec__compras.id_persona,
								__rec__compras.codigo_movcab
							) ;
						end if;
						if __rec__destino__haber.id_haber<>0 then
							/*Haber*/
							INSERT INTO contabilidad.tbl__detalle__asiento__contable(
								fechadoc_das, --1
								serie, --2
								numero, --3
								debe_das, --4
								haber_das, --5
								responsable, 
								id_plancuenta, 
								id_centrocostos, 
								id_comprobante, 
								id_asiento, 
								concepto_das, 
								debehaber, 
								tipo_das, 
								id_estado, 
								id_movasientos, 
								id_tablamov,
								id_sucursal,
								id_producto,
								id_mes,
								anio,
								fecha_registro,
								fecha_contable,
								doc__persona,
								id__persona,
								codigo_movcab
							)
							VALUES (
								__rec__compras.fecha, --1
								__rec__compras.serie, --2
								__rec__compras.numero, --3
								0, --4
								__rec__compras.imp_igv*(__rec__destino__haber.porcent_desitrib/100), --5
								__rec__compras.cliente, 
								__rec__destino__haber.id_haber, 
								__rec__compras.id_centrocostos, 
								__rec__compras.id_comprobante, 
								__id__asiento_c, 
								__rec__compras.concepto_das, 
								__rec__compras.importe, 
								__rec__compras.tipo_das, 
								__rec__compras.id_estado, 
								__rec__compras.id_movasiento, 
								__rec__compras.id_tablamov,
								__rec__compras.id_sucursal,
								__rec__compras.id_producto,
								__rec__compras.id_mes,
								__rec__compras.anio,
								now(),
								__rec__compras.fecha_contable,
								__rec__compras.doc_persona,
								__rec__compras.id_persona,
								__rec__compras.codigo_movcab
							);
						end if;
					end loop;
						
						--imp_debe:= (select imp_formula);
					if not found then
						RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
					end if;
				end if;	
			end loop;
		if COALESCE(__rec__compras.id_cuentadebe,0)>0 and __rec__compras.id_cuentadebe<>0 then			
			INSERT INTO contabilidad.tbl__detalle__asiento__contable(
				fechadoc_das, --1
				serie, --2
				numero, --3
				debe_das, --4
				haber_das, --5
				responsable, 
				id_plancuenta, 
				id_centrocostos, 
				id_comprobante, 
				id_asiento, 
				concepto_das, 
				debehaber, 
				tipo_das, 
				id_estado, 
				id_movasientos, 
				id_tablamov,
				id_sucursal,
				id_producto,
				id_mes,
				anio,
				fecha_registro,
				fecha_contable,
				doc__persona,
				id__persona,
				codigo_movcab
			)
			VALUES (
				__rec__compras.fecha, --1
				__rec__compras.serie, --2
				__rec__compras.numero, --3
				__rec__compras.valor_venta, --4
				0, --5
				__rec__compras.cliente, 
				__rec__compras.id_cuentadebe, 
				__rec__compras.id_centrocostos, 
				__rec__compras.id_comprobante, 
				__id__asiento_c, 
				__rec__compras.concepto_das, 
				__rec__compras.importe, 
				__rec__compras.tipo_das, 
				__rec__compras.id_estado, 
				__rec__compras.id_movasiento, 
				__rec__compras.id_tablamov,
				__rec__compras.id_sucursal,
				__rec__compras.id_producto,
				__rec__compras.id_mes,
				__rec__compras.anio,
				now(),
				__rec__compras.fecha_contable,
				__rec__compras.doc_persona,
				__rec__compras.id_persona,
				__rec__compras.codigo_movcab
			) returning array['0'] into __res;
			
			for __rec__destino__debe in select id_plancuenta,id_debe,id_haber,porcent_desitrib from contabilidad.tbl_destinos_cuenta 
						where id_plancuenta =__rec__compras.id_cuentadebe and id_estado=1 
						loop
				if COALESCE(__rec__destino__debe.id_debe,0)>0 and __rec__destino__debe.id_debe<>0 then
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, --1
						serie, --2
						numero, --3
						debe_das, --4
						haber_das, --5
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, --1
						__rec__compras.serie, --2
						__rec__compras.numero, --3
						__rec__compras.valor_venta*(__rec__destino__debe.porcent_desitrib/100), --4
						0, --5
						__rec__compras.cliente, 
						__rec__destino__debe.id_debe, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) ;
				end if;
				if COALESCE(__rec__destino__debe.id_haber,0)>0 and __rec__destino__debe.id_haber<>0 then
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, --1
						serie, --2
						numero, --3
						debe_das, --4
						haber_das, --5
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, --1
						__rec__compras.serie, --2
						__rec__compras.numero, --3
						0, --4
						__rec__compras.valor_venta*(__rec__destino__debe.porcent_desitrib/100), --5
						__rec__compras.cliente, 
						__rec__destino__debe.id_haber, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) ;
				end if;
			end loop;
			--print '--';					
				--imp_debe:= (select imp_formula);
			if not found then
				RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
			end if;
		end if;
		if COALESCE(__rec__compras.id_cuentahaber,0)>0 and __rec__compras.id_cuentahaber<>0 then			
			INSERT INTO contabilidad.tbl__detalle__asiento__contable(
				fechadoc_das, 
				serie, 
				numero, 
				debe_das, 
				haber_das, 
				responsable, 
				id_plancuenta, 
				id_centrocostos, 
				id_comprobante, 
				id_asiento, 
				concepto_das, 
				debehaber, 
				tipo_das, 
				id_estado, 
				id_movasientos, 
				id_tablamov,
				id_sucursal,
				id_producto,
				id_mes,
				anio,
				fecha_registro,
				fecha_contable,
				doc__persona,
				id__persona,
				codigo_movcab
			)
			VALUES (
				__rec__compras.fecha, 
				__rec__compras.serie, 
				__rec__compras.numero, 
				0, 
				__rec__compras.importe, 
				__rec__compras.cliente, 
				__rec__compras.id_cuentahaber, 
				__rec__compras.id_centrocostos, 
				__rec__compras.id_comprobante, 
				__id__asiento_c, 
				__rec__compras.concepto_das, 
				__rec__compras.importe, 
				__rec__compras.tipo_das, 
				__rec__compras.id_estado, 
				__rec__compras.id_movasiento, 
				__rec__compras.id_tablamov,
				__rec__compras.id_sucursal,
				__rec__compras.id_producto,
				__rec__compras.id_mes,
				__rec__compras.anio,
				now(),
				__rec__compras.fecha_contable,
				__rec__compras.doc_persona,
				__rec__compras.id_persona,
				__rec__compras.codigo_movcab
			) returning array['0'] into __res;

			for __rec__destino__haber in select id_plancuenta,id_debe,id_haber,porcent_desitrib from contabilidad.tbl_destinos_cuenta 
						where id_plancuenta =__rec__compras.id_cuentahaber and id_estado=1 
						loop
				if COALESCE(__rec__destino__haber.id_debe,0)>0 and __rec__destino__haber.id_debe<>0 then
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, --1
						serie, --2
						numero, --3
						debe_das, --4
						haber_das, --5
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, --1
						__rec__compras.serie, --2
						__rec__compras.numero, --3
						__rec__compras.valor_venta*(__rec__destino__haber.porcent_desitrib/100), --4
						0, --5
						__rec__compras.cliente, 
						__rec__destino__haber.id_debe, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) ;
				end if;
				if COALESCE(__rec__destino__haber.id_haber,0)>0 and __rec__destino__haber.id_haber<>0 then
					INSERT INTO contabilidad.tbl__detalle__asiento__contable(
						fechadoc_das, --1
						serie, --2
						numero, --3
						debe_das, --4
						haber_das, --5
						responsable, 
						id_plancuenta, 
						id_centrocostos, 
						id_comprobante, 
						id_asiento, 
						concepto_das, 
						debehaber, 
						tipo_das, 
						id_estado, 
						id_movasientos, 
						id_tablamov,
						id_sucursal,
						id_producto,
						id_mes,
						anio,
						fecha_registro,
						fecha_contable,
						doc__persona,
						id__persona,
						codigo_movcab
					)
					VALUES (
						__rec__compras.fecha, --1
						__rec__compras.serie, --2
						__rec__compras.numero, --3
						0, --4
						__rec__compras.valor_venta*(__rec__destino__haber.porcent_desitrib/100), --5
						__rec__compras.cliente, 
						__rec__destino__debe.id_haber, 
						__rec__compras.id_centrocostos, 
						__rec__compras.id_comprobante, 
						__id__asiento_c, 
						__rec__compras.concepto_das, 
						__rec__compras.importe, 
						__rec__compras.tipo_das, 
						__rec__compras.id_estado, 
						__rec__compras.id_movasiento, 
						__rec__compras.id_tablamov,
						__rec__compras.id_sucursal,
						__rec__compras.id_producto,
						__rec__compras.id_mes,
						__rec__compras.anio,
						now(),
						__rec__compras.fecha_contable,
						__rec__compras.doc_persona,
						__rec__compras.id_persona,
						__rec__compras.codigo_movcab
					) ;
				end if;
			end loop;
			--print '--';
				
				--imp_debe:= (select imp_formula);
			if not found then
				RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
			end if;
		end if;		
end loop;

select  SUM(COALESCE(d.debe_das,0)) into __imp_debemov from         
 contabilidad.tbl__asiento__contable c        
  inner join contabilidad.tbl__detalle__asiento__contable d on(c.id_asiento=d.id_asiento) where c.subdiario_id=__id__subdiario and c.id_asiento=__id__asiento_c;     


select SUM(COALESCE(d.haber_das,0)) into __imp_habermov from         
 contabilidad.tbl__asiento__contable c        
  inner join contabilidad.tbl__detalle__asiento__contable d on(c.id_asiento=d.id_asiento) where c.subdiario_id=__id__subdiario and c.id_asiento=__id__asiento_c;     

        
  UPDATE contabilidad.tbl__asiento__contable  SET debe_asi=__imp_debemov,haber_asi=__imp_habermov WHERE id_asiento=__id__asiento_c;           

__IndexConta:=0;
__ind:=0;

for __recdat__compras in   select * from tmp_compras_val loop
	__ind:= (SELECT position('AV2' IN CONTABILIZADO_CAD ) FROM compras.tbl_detcompra WHERE id__detcompra = __recdat__compras.id_movasiento);
	--RAISE NOTICE '__ind%',__ind;
	if __ind =0 then
		UPDATE compras.tbl_detcompra  SET CONTABILIZADO_CAD = COALESCE(CONTABILIZADO_CAD ,'')|| ',' || 'AV2' 
		WHERE id__detcompra = __recdat__compras.id_movasiento;
		 
		/*UPDATE ventas.tbl_detfacturacion df SET df.CONTABILIZADO_CAD = COALESCE(CONTABILIZADO_CAD ,'')|| ',' || 'AV2' 
			FROM ventas.tbl_detfacturacion d 
			INNER JOIN ventas.tbl_facturacion egr on (egr.id_facturacion=d.id_facturacion and egr.id_sucursal=d.id_sucursal)
			Inner join tmp_ventas_val a  on a.id_detfacturacion = d.id_detfacturacion
			where YEAR(a.fecha)=YEAR(__recdat__ventas.fecha) and month(a.fecha)=month(__recdat__ventas.fecha) and DAY(a.fecha)=DAY(__recdat__ventas.fecha);*/
	end if;
	__IndexConta:=__IndexConta+1;
	--RAISE NOTICE '__IndexConta%',__IndexConta;
	--update ventas.tbl_detfacturacion set contabilizado_cad=contabilizado_cad || ',' || 'AV2' 
	--where id_facturacion=__rec__ventas.id_facturacion and item=__rec__ventas.item and id_sucursal=__rec__ventas.id_sucursal and id_producto=__rec__ventas.id_producto and contabilizado_cad not ilike '%,AV2%' ;
end loop;
--close __cur__ventas;
---DEALLOCATE  __cur__ventas;
__res:=array['0','Proceso efectuado con exito'];	
return __res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from almacen.spiu_familia(2,'46   ','AGA REPRESENTACIONES','01 ','AGA REPRESENTACIONES',1)
select * from almacen.spiu_familia(2,'46','AGA REPRESENTACIONES','01 ','AGA REPRESENTACIONES',1)

CREATE OR REPLACE FUNCTION almacen.spiu_familia(
    op integer,
    _codigo character,
    _descripcion_larga character varying,
    _id_grupo character,
    _descripcion_corta character varying,
    _id_estado integer
)
  RETURNS text[] AS
$BODY$
declare
   cadena character varying;
   item_id   VARCHAR;
   id        INT8;
   regs	     record;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from almacen.tbl_familia where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id_familia::integer) INTO item_id FROM almacen.tbl_familia ;
		IF item_id IS NULL THEN
		   item_id='1';
		ELSE
		  id = item_id::int+1;
		  item_id = id::text ;
		END IF;
		
		insert into almacen.tbl_familia (
			id_familia,
			descripcion_larga,
			id_grupo,
			descripcion_corta,
			id_estado
			)
		values(
			item_id, 
			_descripcion_larga,
			_id_grupo,
			_descripcion_corta,
			_id_estado
		) RETURNING array['0',tbl_familia.id_familia::text] INTO cadena;
		if not found then
			cadena:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		cadena:=array['1'];
	    end if;
end if;
if op=2 then
	if(exists (select * from almacen.tbl_familia where id_familia=_codigo)) then
		update almacen.tbl_familia set descripcion_larga = _descripcion_larga , id_estado = _id_estado, descripcion_corta = _descripcion_corta, id_grupo = _id_grupo 
		where id_familia = _codigo;
		cadena:=array['0',_codigo::text];
	else
		cadena:=array['1'];
	end if;
end if;
return cadena;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION almacen.spiu_add_familia(
    op integer,
    _codigo character,
    _descripcion_larga character varying,
    _id_grupo character,
    _descripcion_corta character varying,
    _id_estado integer
)
  RETURNS table(statuscode int,statusmessage text) AS $$
declare
   cadena character varying;
   item_id   VARCHAR;
   id        INT8;
   regs	     record;
   res       TEXT[];
begin

if(not exists (select * from almacen.tbl_familia where id_familia = _codigo)) then		 	
		insert into almacen.tbl_familia (
			id_familia,
			descripcion_larga,
			id_grupo,
			descripcion_corta,
			id_estado
			)
		values(
			item_id, 
			_descripcion_larga,
			_id_grupo,
			_descripcion_corta,
			_id_estado
		);  
	return query select 1 as statuscode,'Familia registrada' as statusmessage;
else
	update 
		almacen.tbl_familia 
	set 
		descripcion_larga = _descripcion_larga , 
		id_estado = _id_estado, 
		descripcion_corta = _descripcion_corta, 
		id_grupo = _id_grupo 
	where id_familia = _codigo;	
	return query select 1 as statuscode,'Familia actualizada' as statusmessage;	 
end if;
 
end;$$
  LANGUAGE plpgsql VOLATILE
  COST 100;




CREATE OR REPLACE FUNCTION contabilidad.list__libromayor(
    IN __nivel integer,
    IN __id__empresa integer,
    IN __id__proceso integer,
    IN __id__auxiliar integer,
    IN __id__mes integer)
  RETURNS TABLE(__numeracion_cta character varying, __numero_cta character varying, __nombre_cta character varying, __debe numeric, __haber numeric, __asiento integer, __saldodeudor numeric, __glosa_asi character varying, __auxiliar integer) AS
$BODY$
declare
	__anio__proceso integer;
begin
	CREATE TEMPORARY TABLE  tmp_libromayor (
		numeracion_cta varchar(30) ,     
		numero_cta varchar(30) ,              
		nombre_cta varchar(100),     
		Debe   numeric(20,5) default 0 ,              
		Haber   numeric(20,5) default 0,              
		asiento  integer,               
		SaldoDeudor   numeric(20,5),           
		glosa_asi  varchar(200),        
		auxiliar  integer 
	)ON COMMIT DROP;
	select cast(descripcion as integer) into __anio__proceso from contabilidad.tbl_procesocontable where id_proceso=__id__proceso;
	if __nivel<>1 then
		insert into  tmp_libromayor (numeracion_cta,numero_cta ,nombre_cta, Debe , haber, asiento, glosa_asi,auxiliar) 
		select
			pt.numeracion_cta,     
			substring(pt.nro_cuenta  from 1 for __nivel) as cuenta,    
			pt.nombre_cuenta, 
			sum(COALESCE(dm.debe_das,0)) as Debe,    
			sum(COALESCE(dm.haber_das,0)) as Haber,    
			cm.numero_asi asiento,    
			'*************** Importe del Periodo ***************'::varchar(200) glosa_asiAS ,--cm.glosa_asi,    
			1  auxiliar    
		from contabilidad.tbl__asiento__contable cm    
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)    
		inner join contabilidad.tbl_plancuenta pt on (pt.id_plancuenta=dm.id_plancuenta) 
		inner join contabilidad.tbl_subdiario sub on (sub.id=cm.subdiario_id) 
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
				
		--inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=cm.id_auxiliar    
		where date_part('year',dm.fechadoc_das)=__anio__proceso   -- and cm.codigo_aux=2      
		and date_part('month',dm.fechadoc_das)=__id__mes    
		group by pt.numeracion_cta,   pt.nro_cuenta , pt.nombre_cuenta, numero_asi,glosa_asi   
		UNION   ALL                     
		select 
			pt.numeracion_cta,     
			substring(pt.nro_cuenta  from 1 for __nivel) as cuenta,    
			pt.nombre_cuenta,    
			sum(COALESCE(dm.debe_das,0)) as Debe,    
			sum(COALESCE(dm.haber_das,0)) as Haber,    
			0 asiento, 
			'*************** Saldo Anterior ***************' glosa_asi,        
			0  auxiliar    
		from contabilidad.tbl__asiento__contable cm    
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)    
		inner join contabilidad.tbl_plancuenta  pt on (pt.id_plancuenta=dm.id_plancuenta)    
		inner join contabilidad.tbl_subdiario sub on (sub.id=cm.subdiario_id) 
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id  
		where date_part('year',dm.fechadoc_das)=__anio__proceso   -- and cm.codigo_aux=2      
		and date_part('month',dm.fechadoc_das)<__id__mes 
		 group by pt.numeracion_cta,   pt.nro_cuenta ,  pt.nombre_cuenta ;
	else
		insert into  tmp_libromayor (numeracion_cta,numero_cta ,nombre_cta, Debe , haber, asiento, glosa_asi,auxiliar)                                
		select 
			pt.numeracion_cta,     
			pt.nro_cuenta cuenta,    
			pt.nombre_cuenta,    
			sum(COALESCE(dm.debe_das,0)) as Debe,    
			sum(COALESCE(dm.haber_das,0)) as Haber,    
			cm.numero_asi asiento,    
			'*************** Importe del Periodo ***************'::varchar(200) as glosa_asi,    
			1  auxiliar    
		from contabilidad.tbl__asiento__contable cm    
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)    
		inner join contabilidad.tbl_plancuenta  pt on (pt.id_plancuenta=dm.id_plancuenta)    
		inner join contabilidad.tbl_subdiario sub on (sub.id=cm.subdiario_id) 
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
		where date_part('year',dm.fechadoc_das)=__anio__proceso  -- and cm.codigo_aux=2      
		and date_part('month',dm.fechadoc_das)=__id__mes
		group by pt.numeracion_cta,   pt.nro_cuenta , pt.nombre_cuenta, numero_asi,glosa_asi    
		  
	  UNION  all            
		 select pt.numeracion_cta,     
		 pt.nro_cuenta cuenta,    
		 pt.nombre_cuenta,    
		sum(COALESCE(dm.debe_das,0)) as Debe,    
		sum(COALESCE(dm.haber_das,0)) as Haber,    
		0 asiento, '*************** Saldo Anterior ***************' glosa_asi,        
		0 auxiliar     
		from contabilidad.tbl__asiento__contable cm    
		inner join contabilidad.tbl__detalle__asiento__contable dm on (cm.id_asiento=dm.id_asiento)    
		inner join contabilidad.tbl_plancuenta  pt on (pt.id_plancuenta=dm.id_plancuenta)    
		inner join contabilidad.tbl_subdiario sub on (sub.id=cm.subdiario_id) 
		inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id 
		where date_part('year',dm.fechadoc_das)=__anio__proceso   -- and cm.codigo_aux=2      
		and date_part('month',dm.fechadoc_das)<__id__mes 
		 group by pt.numeracion_cta, pt.nro_cuenta, pt.nombre_cuenta     ; 
			    		
	end if;
	update tmp_libromayor set SaldoDeudor= COALESCE(Debe,0)-COALESCE(Haber,0)   ;        

if __nivel <> 1  then
	RETURN QUERY select x.numeracion_cta,        
	    x.numero_cta,        
	    x.nombre_cta,        
	    COALESCE( x.debe ,0 ) as Debe,        
	    COALESCE(x.haber,0) as Haber,        
	    x.asiento,         
	    x.saldodeudor,        
	    x.glosa_asi,        
	    x.auxiliar --add               
	from  tmp_libromayor x          
	where length(x.numero_cta) <= __nivel            
	order by x.numeracion_cta, x.asiento, x.glosa_asi    ;      
else              
	RETURN QUERY select x.numeracion_cta,        
	    x.numero_cta,        
	    x.nombre_cta,        
	    COALESCE( x.debe ,0 ) as Debe,        
	    COALESCE(x.haber,0) as Haber,        
	    x.asiento,        
	    x.saldodeudor,        
	    x.glosa_asi,         
	    auxiliar --add              
	from  tmp_libromayor x              
	order by x.numeracion_cta, asiento, x.glosa_asi  ;	
end if;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE FUNCTION ventas.lis_ventasdiariasproductovendedorComercial(
    IN anio integer,
    IN mes integer,
    IN sucursal integer)
  RETURNS TABLE(producto character varying, vendedor character varying, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_producto,
_vendedor,

COALESCE("_1",0)  as "1",
COALESCE("_2",0)  as "2",
COALESCE("_3",0)  as "3",
COALESCE("_4",0)  as "4",
COALESCE("_5",0)  as "5",
COALESCE("_6",0)  as "6",
COALESCE("_7",0)  as "7",
COALESCE("_8",0)  as "8",
COALESCE("_9",0)  as "9",
COALESCE("_10",0)  as "10",
COALESCE("_11",0)  as "11",
COALESCE("_12",0)  as "12",
COALESCE("_13",0)  as "13",
COALESCE("_14",0)  as "14",
COALESCE("_15",0)  as "15",
COALESCE("_16",0)  as "16",
COALESCE("_17",0)  as "17",
COALESCE("_18",0)  as "18",
COALESCE("_19",0)  as "19",
COALESCE("_20",0)  as "20",
COALESCE("_21",0)  as "21",
COALESCE("_22",0)  as "22",
COALESCE("_23",0)  as "23",
COALESCE("_24",0) as "24",
COALESCE("_25",0) as "25",
COALESCE("_26",0) as "26" ,
COALESCE("_27",0) as "27" ,
COALESCE("_28",0) as "28",
COALESCE("_29",0) as "29" ,
COALESCE("_30",0) as "30",
COALESCE("_31",0) as "31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0) as total
 FROM crosstab(
  ' SELECT 
	p.descripcion_larga as producto,
	ven.nombre_razon, 	
	date_part(''day'',fecha_venta) as dia, 
	sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0)) as cantidad
	FROM ventas.tbl_facturacion f inner join 
	ventas.tbl_detfacturacion df  on (f.id_facturacion=df.id_facturacion) inner join
	common.tbl_sucursal s on (s.id_sucursal=f.id_sucursal) inner join
	planillas.tbl_persona cli on (cli.id_persona=f.id_cliente) inner join 
	planillas.tbl_persona ven on (cli.id_vendtitular=ven.id_persona) inner join
	almacen.tbl_producto p on (p.id_producto=df.id_producto)
	where df.id_estado=1 and  f.id_estado=1 and f.nota_credito=false and date_part(''year'',f.fecha_venta)=''' || anio ||  ''' 
and date_part(''month'',f.fecha_venta)=''' || mes ||''' and f.id_sucursal=''' || sucursal ||'''
	group by 
		ven.nombre_razon,p.descripcion_larga,
		date_part(''day'',fecha_venta)
	ORDER BY ven.nombre_razon
		--date_part(''month'',fecha_venta) ,
		--date_part(''day'',fecha_venta) 
  ',
  ' SELECT m FROM generate_series(1,31) m '
) AS 
(
	_producto varchar(200), 
	_vendedor varchar(400), 
	--mes  integer ,
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"_14" numeric(20,4),
	"_15" numeric(20,4),
	"_16" numeric(20,4),
	"_17" numeric(20,4),
	"_18" numeric(20,4),
	"_19" numeric(20,4),
	"_20" numeric(20,4),
	"_21" numeric(20,4),
	"_22" numeric(20,4),
	"_23" numeric(20,4),
	"_24" numeric(20,4),
	"_25" numeric(20,4),
	"_26" numeric(20,4),
	"_27" numeric(20,4),
	"_28" numeric(20,4),
	"_29" numeric(20,4),
	"_30" numeric(20,4),
	"_31" numeric(20,4)
);
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE FUNCTION ventas.lis_ventasdiariasproductovendedor(
    IN anio integer,
    IN mes integer,
    IN sucursal integer)
  RETURNS TABLE(producto character varying, vendedor character varying, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_producto,
_vendedor,
"_1" ,
 "_2",
"_3",
 "_4",
 "_5",
 "_6",
"_7",
"_8",
 "_9",
 "_10",
 "_11",
 "_12",
 "_13",
 "_14",
 "_15",
 "_16",
"_17",
 "_18",
 "_19",
 "_20",
"_21",
"_22",
"_23",
 "_24",
 "_25",
 "_26",
 "_27",
 "_28",
 "_29",
 "_30",
 "_31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0) as total
 FROM crosstab(
  ' SELECT 
	p.descripcion_larga as producto,
	ven.nombre_razon, 	
	date_part(''day'',fecha_venta) as dia, 
	sum(df.cantidad)-SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF and dff.id_producto=df.id_producto)
			),0)) as cantidad
	FROM ventas.tbl_facturacion f inner join 
	ventas.tbl_detfacturacion df  on (f.id_facturacion=df.id_facturacion) inner join
	common.tbl_sucursal s on (s.id_sucursal=f.id_sucursal) inner join
	planillas.tbl_persona cli on (cli.id_persona=f.id_cliente) inner join 
	planillas.tbl_persona ven on (cli.id_vendtitular=ven.id_persona) inner join
	almacen.tbl_producto p on (p.id_producto=df.id_producto)
	where df.id_estado=1 and  f.id_estado=1 and f.nota_credito=false and date_part(''year'',f.fecha_venta)=''' || anio ||  ''' 
and date_part(''month'',f.fecha_venta)=''' || mes ||''' and f.id_sucursal=''' || sucursal ||'''
	group by 
		ven.nombre_razon,p.descripcion_larga,
		date_part(''day'',fecha_venta)
	ORDER BY ven.nombre_razon
		--date_part(''month'',fecha_venta) ,
		--date_part(''day'',fecha_venta) 
  ',
  ' SELECT m FROM generate_series(1,31) m '
) AS 
(
	_producto varchar(200), 
	_vendedor varchar(400), 
	--mes  integer ,
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"_14" numeric(20,4),
	"_15" numeric(20,4),
	"_16" numeric(20,4),
	"_17" numeric(20,4),
	"_18" numeric(20,4),
	"_19" numeric(20,4),
	"_20" numeric(20,4),
	"_21" numeric(20,4),
	"_22" numeric(20,4),
	"_23" numeric(20,4),
	"_24" numeric(20,4),
	"_25" numeric(20,4),
	"_26" numeric(20,4),
	"_27" numeric(20,4),
	"_28" numeric(20,4),
	"_29" numeric(20,4),
	"_30" numeric(20,4),
	"_31" numeric(20,4)
);
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

CREATE OR REPLACE FUNCTION ventas.list_ventas_diarias(
     _year integer,
    _mes integer,
    _id_empresa integer,
    vend text)
  RETURNS table(
	__vendedor text,
	__uno  NUMERIC(14,3), 
	__dos NUMERIC(14,3),
	__tres NUMERIC(14,3), 
	__cuatro NUMERIC(14,3), 
	__cinco NUMERIC(14,3), 
	__seis NUMERIC(14,3), 
	__ciete NUMERIC(14,3), 
	__ocho NUMERIC(14,3), 
	__nueve NUMERIC(14,3), 
	__diez NUMERIC(14,3), 
	__once NUMERIC(14,3), 
	__doce NUMERIC(14,3),
	__trece NUMERIC(14,3),
	__catorce NUMERIC(14,3),
	__quince  NUMERIC(14,3), 
	__dieciseis NUMERIC(14,3),
	__diecisiete NUMERIC(14,3), 
	__dieciocho NUMERIC(14,3), 
	__diecinueve NUMERIC(14,3), 
	__veinte NUMERIC(14,3), 
	__ventiuno NUMERIC(14,3), 
	__ventidos NUMERIC(14,3), 
	__ventitres NUMERIC(14,3), 
	__venticuatro NUMERIC(14,3), 
	__venticinco NUMERIC(14,3), 
	__ventiseis NUMERIC(14,3),
	__venticiete NUMERIC(14,3),
	__ventiocho NUMERIC(14,3),
	__ventinueve NUMERIC(14,3),
	__trienta NUMERIC(14,3),
	__treintauno NUMERIC(14,3),
	__total NUMERIC(14,3)
  ) AS
$BODY$
begin
return query  select vendedor,
		COALESCE(uno,0) as uno,
		COALESCE(dos,0) as dos,
		COALESCE(tres,0) as tres,
		COALESCE(cuatro,0) as cuatro,
		COALESCE(cinco,0) as cinco,
		COALESCE(seis,0) as seis,
		COALESCE(ciete,0) as ciete,
		COALESCE(ocho,0) as ocho,
		COALESCE(nueve,0) as nueve,
		COALESCE(diez,0) as diez,
		COALESCE(once,0) as once,
		COALESCE(doce,0) as doce,
		COALESCE(trece,0) as trece,
		COALESCE(catorce,0) as catorce,
		COALESCE(quince,0) qunce ,
		   COALESCE(dieciseis ,0) dieciseis,
		   COALESCE(diecisiete ,0) diecisiete,
		   COALESCE(dieciocho,0) dieciocho,
		   COALESCE(diecinueve,0) diecinueve,
		   COALESCE(veinte,0) veinte,
		   COALESCE(ventiuno,0) ventiuno,
		   COALESCE(ventidos,0) ventidos,
		   COALESCE(ventitres,0) ventitres,
		   COALESCE(venticuatro,0) venticuatro,
		   COALESCE(venticinco,0)venticinco,
		   COALESCE(ventiseis,0) ventiseis,
		   COALESCE(venticiete,0) venticiete,
		   COALESCE(ventiocho,0) ventiocho,
		   COALESCE(ventinueve,0) ventinueve,
		   COALESCE(trienta,0) trienta,
		   COALESCE(treintauno,0) treintauno,		   
		(COALESCE(uno,0)+
		COALESCE(dos,0)+ 
		COALESCE(tres,0)+
		COALESCE(cuatro,0)+
		COALESCE(cinco,0)+
		COALESCE(seis,0) +
		COALESCE(ciete,0)+
		COALESCE(ocho,0) +
		COALESCE(nueve,0) +
		COALESCE(diez,0) +
		COALESCE(once,0) +
		COALESCE(doce,0) +
		COALESCE(trece,0)+
		COALESCE(catorce,0)+
		COALESCE(quince,0)+
		   COALESCE(dieciseis ,0) +
		   COALESCE(diecisiete ,0) +
		   COALESCE(dieciocho,0) +
		   COALESCE(diecinueve,0) +
		   COALESCE(veinte,0) +
		   COALESCE(ventiuno,0)+
		   COALESCE(ventidos,0) +
		   COALESCE(ventitres,0) +
		   COALESCE(venticuatro,0)+
		   COALESCE(venticinco,0)+
		   COALESCE(ventiseis,0) +
		   COALESCE(venticiete,0) +
		   COALESCE(ventiocho,0) +
		   COALESCE(ventinueve,0) +
		   COALESCE(trienta,0) +
		   COALESCE(treintauno,0) ) as cantidad_ventas
	
	  from crosstab(
		  '(select p.nombre_razon, date_part(''day'',fecha_venta), sum(f.imp_total)
		  from ventas.tbl_facturacion f
		  inner join planillas.tbl_persona p on (p.id_persona=f.id_vendedor) 		
		  INNER JOIN COMMON.tbl_sucursal S ON (S.ID_SUCURSAL=F.ID_SUCURSAL)
		   where date_part(''year'',fecha_venta::date) = ''' || _year || '''  and 
		   date_part(''month'',fecha_venta::date) = ''' || _mes || '''  and S.ID_EMPRESA= ''' || _id_empresa || ''' and f.id_estado=1
		  group by p.nombre_razon, date_part(''day'',fecha_venta) order by 1) ',
		  'select m from generate_series(1,32) m') as (
		   vendedor text,
		   uno  NUMERIC(14,3), 
		   dos NUMERIC(14,3),
		   tres NUMERIC(14,3), 
		   cuatro NUMERIC(14,3), 
		   cinco NUMERIC(14,3), 
		   seis NUMERIC(14,3), 
		   ciete NUMERIC(14,3), 
		   ocho NUMERIC(14,3), 
		   nueve NUMERIC(14,3), 
		   diez NUMERIC(14,3), 
		   once NUMERIC(14,3), 
		   doce NUMERIC(14,3),
		   trece NUMERIC(14,3),
		   catorce NUMERIC(14,3),
		   quince  NUMERIC(14,3), 
		   dieciseis NUMERIC(14,3),
		   diecisiete NUMERIC(14,3), 
		   dieciocho NUMERIC(14,3), 
		   diecinueve NUMERIC(14,3), 
		   veinte NUMERIC(14,3), 
		   ventiuno NUMERIC(14,3), 
		   ventidos NUMERIC(14,3), 
		   ventitres NUMERIC(14,3), 
		   venticuatro NUMERIC(14,3), 
		   venticinco NUMERIC(14,3), 
		   ventiseis NUMERIC(14,3),
		   venticiete NUMERIC(14,3),
		   ventiocho NUMERIC(14,3),
		   ventinueve NUMERIC(14,3),
		   trienta NUMERIC(14,3),
		   treintauno NUMERIC(14,3),
		   total NUMERIC(14,3)
	  );/*
union
select p.personal,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
from personal.v_listar_personal_ventas as p
where p.idpersonal not in (select idpersonal from ventas.facturacion 
where date_part('month',fecha_emision::date) = date_part('month',now()::date) and 
date_part('year',fecha_emision::date)=date_part('year',now()::date) and anulado='N');*/


	 
end ; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION ventas.list_cantidadproductotrimestralxanio(
    _id_empresa integer,
    _producto text,
    op integer
    )
  RETURNS table(
	__codigo text,
	__producto text,
	__familia text,
	__year integer,
	__primero numeric(20,4),
	__segunda numeric(20,4),
	__tercero numeric(20,4),
	__cuarto numeric(20,4),
	__total numeric(20,4)
  ) AS
$BODY$
declare
begin

 
return query select 		
	codigo,
	producto,
	familia,
	year,
	COALESCE(primero,0) as primero,
	COALESCE(segundo,0) as segundo,
	COALESCE(tercero,0) as tercero,
	COALESCE(cuarto,0) as cuarto,
	(COALESCE(primero,0)+COALESCE(segundo,0)+COALESCE(tercero,0)+COALESCE(cuarto,0)) as total
	   from crosstab(
		  '(select 
		  df.id_producto,
		  p.descripcion_larga as producto,
		 
		  date_part(''year'',f.fecha_venta::date), 
		  fa.descripcion_larga as familia,
		  EXTRACT(QUARTER FROM f.fecha_venta::Date), 
		  sum(df.cantidad)
		  from ventas.tbl_facturacion f
		  inner join ventas.tbl_detfacturacion df on (f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal)
		  inner join almacen.tbl_producto p on (p.id_producto=df.id_producto)
		  inner join almacen.tbl_familia fa on (fa.id_familia=p.id_familia)
		  inner join common.tbl_sucursal s on (s.id_sucursal=f.id_sucursal) where     f.id_estado=1
		group by date_part(''year'',f.fecha_venta::date), EXTRACT(QUARTER FROM f.fecha_venta::date),df.id_producto,p.descripcion_larga,fa.descripcion_larga order by 1) ',
		  'select m from generate_series(1,5) m') as (
		
		codigo text,
		producto text,
		
		YEAR int,familia text,
		primero NUMERIC(14,3), 
		segundo NUMERIC(14,3),
		tercero NUMERIC(14,3), 
		cuarto NUMERIC(14,3), 		  
		total numeric(14,3)
	  );

 
 
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE TABLE color (
    color_id INT GENERATED ALWAYS AS IDENTITY,
    color_name VARCHAR NOT NULL
);

select *from color

INSERT INTO color (color_name)
VALUES
    ('Red');

INSERT INTO color (color_name)
VALUES
    ('verder');    
--http://www.postgresqltutorial.com/postgresql-identity-column/


CREATE OR REPLACE FUNCTION caja.isp_generaplanlilla(
    _id_turno integer,
    _id_caja_destino integer,
    _fecha_mov text)
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
	CORREL INTEGER;
BEGIN
	select max(case when id_liquidacion is null then 0 else id_liquidacion::integer end) into correl 
	from caja.tbl_movcaja where  id_caja_destino=_id_caja_destino and id_turno=_id_turno and fecha_mov::date=cast(_fecha_mov as date);
	if correl is null then
		correl:=1;
	else
		correl:=correl+1;
	end if;
return Array[lpad(correl::text,7,'0') ];
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select * from CAJA.ISP_LIQUIDAR_TURNO('18/11/2018',1,'1',2)

select *from planillas.tbl_turnocolaborador where id_turno=1 and fecha=cast('18/11/2018' as date) and id_colaborador='1' and id_estado=1

CREATE OR REPLACE FUNCTION caja.isp_liquidar_turno(
    _fecha text,
    _id_turno integer,
    _id_colaborador character varying,
    _id_estado integer,
    _liquidacion_id bigint
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select *from planillas.tbl_turnocolaborador where id_turno=_id_turno and fecha=cast(_fecha as date )and id_colaborador=_id_colaborador) then
	if exists(select *from planillas.tbl_turnocolaborador where liquidacion_id=_liquidacion_id )then --id_turno=_id_turno and fecha=cast(_fecha as date) and id_colaborador=_id_colaborador and id_estado=1) then
		update planillas.tbl_turnocolaborador set id_estado=_id_estado where liquidacion_id=_liquidacion_id --id_turno=_id_turno and fecha=cast(_fecha as date)and id_colaborador=_id_colaborador 
		returning array['0',id_turno::text || item::text || id_colaborador::text || fecha::text ,'El turno ha sido liquidado correctamente'] into res;
	else	
		res:=array['504','El turno ya se encuentra liquidado'];
	end if;
else
	res:=array['503','No se encuentra el turno que desea liquidar'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.isp_closeinventario_producto(
    _id_almacen integer,
    _id_inventario integer,
    _id_producto character varying,
    _id_unidad integer)
  RETURNS text[] AS
$BODY$


DECLARE
	res text[];
	dat record;
	datdocs record;
	existencias record;
	invent record;
	_id_sucursal integer;
	correl_s integer;
BEGIN

select id_sucursal into _id_sucursal from almacen.tbl_almacen where id_almacen=_id_almacen;
for invent in select coalesce(din.fecha,inv.fecha) as fec_inventario ,din.id_producto,din.id_almacen,alm.id_sucursal ,din.id_unidadventa,din.costo,din.cantidad_fisica
	from almacen.tbl_cabinventario inv 
    inner join  almacen.tbl_detinventario din on(inv.id_inventario=din.id_inventario and inv.id_almacen=din.id_almacen) 
	inner join almacen.tbl_almacen alm on (alm.id_almacen=din.id_almacen) where alm.id_sucursal=_id_sucursal  and din.id_estado=1 and 
	din.id_producto=_id_producto loop

	update ventas.tbl_detfacturacion d set 	inv_inicial=true 
		where exists(select 1 from ventas.tbl_facturacion f where f.id_facturacion=d.id_facturacion and 
		f.id_sucursal=d.id_sucursal and cast(f.fecha_venta as date)<=cast(invent.fec_inventario as date) and 
		d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);
	
	update ventas.tbl_detfacturacion d set 	inv_inicial=true 
		where exists(select 1 from ventas.tbl_facturacion f where f.id_facturacion=d.id_facturacion and 
		f.id_sucursal=d.id_sucursal and cast(f.fecha_venta as date)<=cast(invent.fec_inventario as date) and 
		d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);

		update COMPRAS.tbl_detcompra d set 	inv_inicial=true 
		where exists(select 1 from compras.tbl_compra f where f.id_sucursalcompra=d.id_sucursalcompra and  f.anio=d.anio and f.id_compra=d.id_compra and f.id_mes =d.id_mes and 
		cast(f.fec_documento as date)<=cast(invent.fec_inventario as date) and d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);
	/****/
		update COMPRAS.tbl_detcompra d set 	inv_inicial=true
		where exists(select 1 from compras.tbl_compra f where f.id_sucursalcompra=d.id_sucursalcompra and  f.anio=d.anio and f.id_compra=d.id_compra and f.id_mes =d.id_mes and 
		cast(f.fec_documento as date)>cast(invent.fec_inventario as date) and d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);

		update almacen.tbl_detmovalm d set 	inv_inicial=true
		where exists(select  1 from almacen.tbl_cabmovalm f where f.id_movimiento=d.id_movimiento and 
		f.fecha<invent.fec_inventario and d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);
		
		update almacen.tbl_detmovalm d set 	inv_inicial=true
		where exists(select  1 from almacen.tbl_cabmovalm f where f.id_movimiento=d.id_movimiento and 
		f.fecha<invent.fec_inventario and d.id_producto=invent.id_producto and d.id_almacen=invent.id_almacen);

		if not exists(select 1 from almacen.TBL_SALDOSEXISTENCIA 			
				where id_producto=invent.id_producto and id_sucursal=invent.id_sucursal and id_unidad=invent.id_unidadventa) then
				
				select  max(id_saldos) into correl_s from almacen.TBL_SALDOSEXISTENCIA;
				if correl_s is null then
					correl_s:=1;
				else
					correl_s:=correl_s+1;
				end if;
				insert into almacen.TBL_SALDOSEXISTENCIA (
					id_saldos,
					stockh,
					stockTransito,
					stockComprometido,
					costounitario,
					id_unidad,
					id_producto,
					id_sucursal
				)values(
					correl_s,
					invent.cantidad_fisica ,
					0,
					0,
					invent.costo,
					invent.id_unidadventa,
					invent.id_producto,
					invent.id_sucursal
					);
				res:=array['0','El estock no se ha generado'];
			else
				update almacen.TBL_SALDOSEXISTENCIA 
					set stockh=stockh+invent.cantidad_fisica ,
					costounitario=invent.costo ,id_estado=1
				where id_producto=invent.id_producto and id_sucursal=invent.id_sucursal ;
				res:=array['0','El estock no se ha generado'];
			end if;
		
		res:= array['0',_id_inventario::text,_id_almacen::text];
end loop;

for dat in select *from almacen.v_consolidadoinv where id_almacen =_id_almacen and id_inventario=_id_inventario loop
	IF NOT EXISTS(select *from almacen.tbl_existencia 
				WHERE id_producto=dat.id_producto and id_unidadventa=dat.id_unidadventa and id_almacen=_id_almacen and  id_inventario=_id_inventario) THEN
		INSERT INTO almacen.tbl_existencia(
			stock_fisico, 
			id_almacen, 
			id_producto, 
			id_unidadventa,
			id_inventario, 
			fec_inventario, 
			valor_incial, 
			stock_inicial, 
			id_estado, 
			observaciones
		)
		VALUES (
			dat.conteo, 
			_id_almacen, 
			dat.id_producto, 
			dat.id_unidadventa,
			_id_inventario, 
			now(), 
			0, 
			dat.conteo, 
			1, 
			''
		) returning array['0',id_inventario::text,id_almacen::text] into res ;
		if not found then
			res:=array['504','Ocurrio un error al momento de registrar el producto ' || dat.id_producto ];
			exit;
		end if;
	ELSE	
		res:=array['0',_id_inventario::text,_id_almacen::text];
	END IF;
      
end loop;
for datdocs in select id_inventario, id_almacen from almacen.tbl_cabinventario where id_almacen =_id_almacen and id_inventario=_id_inventario loop
	update almacen.tbl_cabinventario SET id_estado=26 where id_almacen =datdocs.id_almacen and id_inventario=datdocs.id_inventario ;
	res:= array['0',_id_inventario::text,_id_almacen::text];
end loop;
update almacen.tbl_inventario set id_estado=26 where  id_almacen =_id_almacen and id_inventario=_id_inventario ;
	res:= array['0',_id_inventario::text,_id_almacen::text];

update almacen.tbl_existencia set 
		stock_inicial=0,
		consto_inicial=0,stock_fisico=0 --,fec_inventario=now()
		where 
        id_almacen=_id_almacen and 
        id_inventario=_id_inventario and 
        id_producto=_id_producto and 
        id_unidadventa=_id_unidad;

 
--select *from almacen.tbl_cabinventario		

for existencias in select sum(di.cantidad_fisica)as cantidad_fisica,di.id_almacen,di.id_inventario,to_char(inv.fecha,'dd/mm/yyyy')::timestamp fecha,di.costo,di.id_producto,di.id_unidadventa,di.inv_inicial 
	from almacen.tbl_cabinventario inv 
		inner join  almacen.tbl_detinventario di on(inv.id_inventario=di.id_inventario and inv.id_almacen=di.id_almacen) 
		where di.id_almacen=_id_almacen and di.id_inventario=_id_inventario and di.id_producto=_id_producto and 
        di.id_unidadventa=_id_unidad and di.id_estado=1 
		group by di.id_almacen,di.id_inventario,to_char(inv.fecha,'dd/mm/yyyy'),di.costo,di.id_producto,di.id_unidadventa,di.inv_inicial
		loop

	update almacen.tbl_existencia set 
		stock_inicial= coalesce(stock_inicial,0)+existencias.cantidad_fisica,
		consto_inicial=existencias.costo,
		stock_fisico=coalesce(stock_fisico,0)+existencias.cantidad_fisica ,
		fec_inventario=existencias.fecha
		where 
        id_almacen=_id_almacen and 
        id_inventario=_id_inventario and 
        id_producto=existencias.id_producto and 
        id_unidadventa=existencias.id_unidadventa;

		update almacen.tbl_producto set id_estado=1,inventariado=true where id_producto=existencias.id_producto;
		if existencias.inv_inicial=true then
			update  almacen.tbl_existencia set 
			inv_inicial=true ,
			stock_inicial=existencias.cantidad_fisica,
			stock_fisico=existencias.cantidad_fisica ,
			consto_inicial=existencias.costo,
			fec_inventario=existencias.fecha			
			 where id_almacen=_id_almacen and 
             id_inventario=_id_inventario and 
             id_producto=existencias.id_producto and 
             id_unidadventa=existencias.id_unidadventa;
		end if;
		
		res:= array['0',_id_inventario::text,_id_almacen::text];
end loop;

UPDATE VENTAS.TBL_DETFACTURACION SET inv_inicial=FALSE WHERE 
id_facturacion::text || id_sucursal::text IN(
SELECT distinct dm.id_facturacion::text || dm.id_sucursal::text as ID FROM VENTAS.TBL_DETFACTURACION DM
INNER JOIN VENTAS.TBL_FACTURACION F ON F.ID_FACTURACION=DM.ID_FACTURACION AND DM.ID_SUCURSAL=F.ID_SUCURSAL
INNER JOIN(
SELECT 
P.ID_PRODUCTO,  
U.ID_UNIDADVENTA,
DM.FECHA AS FECHA,
P.CODIGO,
P.DESCRIPCION_LARGA AS PRODUCTO,
DM.CANTIDAD_FISICA AS CANTIDAD ,
U.DESC_LARGA AS UNIDAD    
FROM ALMACEN.TBL_DETINVENTARIO DM
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DM.ID_PRODUCTO=DP.ID_PRODUCTO AND DM.ID_UNIDADVENTA=DP.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_UNIDAD U ON U.ID_UNIDADVENTA=DM.ID_UNIDADVENTA
WHERE DM.ID_ALMACEN=_id_almacen and dm.id_estado=1
) Z  ON Z.ID_PRODUCTO=DM.ID_PRODUCTO AND DM.ID_UNIDADVENTA=Z.ID_UNIDADVENTA
 WHERE F.FECHA_VENTA>Z.FECHA and dm.id_producto=_id_producto and dm.id_unidadventa=_id_unidad
);




UPDATE COMPRAS.TBL_DETCOMPRA SET inv_inicial=FALSE WHERE 
id__detcompra::TEXT || id__compra::TEXT || id_sucursalcompra::TEXT IN(
SELECT distinct dm.id__detcompra::TEXT || dm.id__compra::TEXT || dm.id_sucursalcompra::TEXT as ID FROM compras.tbl_detcompra DM
INNER JOIN compras.TBL_compra F ON  f.id__compra=dm.id__compra and f.id_sucursalcompra=dm.id_sucursalcompra
INNER JOIN(
SELECT 
P.ID_PRODUCTO,  
U.ID_UNIDADVENTA,
DM.FECHA AS FECHA,
P.CODIGO,
P.DESCRIPCION_LARGA AS PRODUCTO,
DM.CANTIDAD_FISICA AS CANTIDAD ,
U.DESC_LARGA AS UNIDAD    
FROM ALMACEN.TBL_DETINVENTARIO DM
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DM.ID_PRODUCTO=DP.ID_PRODUCTO AND DM.ID_UNIDADVENTA=DP.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_UNIDAD U ON U.ID_UNIDADVENTA=DM.ID_UNIDADVENTA
WHERE DM.ID_ALMACEN=_id_almacen and dm.id_estado=1
) Z  ON Z.ID_PRODUCTO=DM.ID_PRODUCTO AND DM.ID_UNIDADVENTA=Z.ID_UNIDADVENTA
 WHERE F.fec_ingsistema>Z.FECHA and dm.id_producto=_id_producto and dm.id_unidadventa=_id_unidad
);



return res;
END;$BODY$

LANGUAGE plpgsql VOLATILE
COST 100;





CREATE OR REPLACE FUNCTION compras.spiu_recibohonorarios(
    op integer,
    _id__compra bigint,
    _nro_doc_compra character,
    _fec_documento text,
    _id_dirproveedor bigint,
    _id_comprobante integer,
    _id_tranzaccion character,
    _id_igv integer,
    _anio integer,
    _id_compra integer,
    _id_mes integer,
    _fec_ingsistema text,
    _imp_venta numeric,
    _imp_dcsto numeric,
    _porcent_dcsto numeric,
    _imp_igv numeric,
    _id_sucursalcompra integer,
    _id_estado integer,
    _id_proveedor character varying,
    _serie character,
    _id_tipocambio integer,
    _id_tipocompra integer,
    _doc_referencia character,
    _imp_bruto numeric,
    _imp_total numeric,
    _imp_exonerado numeric,
    _id_operacion integer,
    _genera_letra boolean,
    _id_moneda integer,
    _imp_afecto numeric,
    _id_responsable character varying,
    _egreso boolean,
    _glosa text,
    _id_centrocostos integer)
  RETURNS text[] AS
$BODY$
DECLARE 
	res TEXT[];
	_id bigint;
	imp_movimiento numeric(20,4);
	_id_credito integer;
	_id_sucursalcredito integer;
	
BEGIN

IF op=1 then
	if not exists(select 1 from COMPRAS.TBL_COMPRA 
		where 
			serie=_serie 
			and nro_doc_compra=_nro_doc_compra 
			and id_comprobante=_id_comprobante 
			and id_proveedor=_id_proveedor) then
		if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirproveedor and  id_persona=_id_proveedor) then
			if exists(select *from common.tbl_comprobante where id_comprobante=_id_comprobante) then
				if exists(select *from common.tbl_tipocambio where id_tipocambio=_id_tipocambio)then
					select max(id__compra) into _id from COMPRAS.TBL_COMPRA;
					if _id is null then
						_id:=1;
					else
						_id:=_id+1;
					end if;
					_id_mes:=date_part('month',now());
					_anio:=date_part('year',now());
					INSERT INTO COMPRAS.TBL_COMPRA(
						id__compra,
						nro_doc_compra,
						fec_documento,
						id_dirproveedor,
						id_comprobante,
						id_tranzaccion,
						id_igv,
						anio,
						id_compra,
						id_mes,
						fec_ingsistema,
						imp_venta,
						imp_dcsto,
						porcent_dcsto,
						imp_igv,
						id_sucursalcompra,
						id_estado,
						id_proveedor,
						serie,
						id_tipocambio,
						id_tipocompra,
						doc_referencia,
						imp_bruto,
						imp_total,
						imp_exonerado,
						id_operacion,
						genera_letra,
						id_moneda,
						imp_afecto,
						id_responsable,
						egreso,
						glosa,
						id_centrocostos
					)VALUES(
						_id,
						_nro_doc_compra,
						to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
						_id_dirproveedor,
						_id_comprobante,
						_id_tranzaccion,
						_id_igv,
						_anio,
						_id_compra,
						_id_mes,
						to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
						_imp_venta,
						_imp_dcsto,
						_porcent_dcsto,
						_imp_igv,
						_id_sucursalcompra,
						_id_estado,
						_id_proveedor,
						_serie,
						_id_tipocambio,
						_id_tipocompra,
						_doc_referencia,
						_imp_bruto,
						_imp_total,
						_imp_exonerado,
						_id_operacion,
						_genera_letra,
						_id_moneda,
						_imp_afecto,
						_id_responsable,
						_egreso,
						_glosa,
						_id_centrocostos
					)returning array['0', id__compra::text, id_sucursalcompra::TEXT] into res;
					if not found then
						res:=array['504', 'Inconsitencia Inesperada al momento de registrar la compra'];
					end if;
					--select *from COMPRAS.TBL_COMPRA where id_mes=date_part('month',now()) and anio=date_part('year',now());
				end if;
			end if;
		end if;
	else
		res:=array['505','El documento ya se encuentra registrado'];
	end if;
ELSE
   IF op=2 then
	if exists(select 1 from COMPRAS.TBL_COMPRA where id_sucursalcompra = _id_sucursalcompra and id__compra = _id__compra) then
		select sum(imp_pago) into imp_movimiento from creditos.tbl_creditoscompra cc
		inner join creditos.tbl_cuota c on (c.id_credito=cc.id_credito and  cc.id_sucursal_credito=c.id_sucursal_credito)
		inner join creditos.tbl_detpagocuota dp on (c.id_cuotas=dp.id_cuotas and c.id_credito=dp.id_credito and c.id_sucursal_credito=dp.id_sucursal_credito)
		where cc.id__compra=_id__compra and cc.id_sucursalcompra = _id_sucursalcompra ;
		if COALESCE(imp_movimiento,0)=0 then
			select id_credito into _id_credito from creditos.tbl_creditoscompra where id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra;
			select id_sucursal_credito into _id_sucursalcredito from creditos.tbl_creditoscompra where id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra;

			delete from creditos.tbl_cuota where id_credito=_id_credito and id_sucursal_credito=_id_sucursalcredito;
			delete from  creditos.tbl_creditoscompra where id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra;
			delete from creditos.tbl_credito where  id_credito=_id_credito and id_sucursal_credito=_id_sucursalcredito;
			
			UPDATE COMPRAS.TBL_COMPRA SET
				nro_doc_compra  =   _nro_doc_compra,
				fec_documento  =   to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
				id_dirproveedor  =   _id_dirproveedor,
				id_comprobante  =   _id_comprobante,
				id_tranzaccion  =   _id_tranzaccion,
				id_igv  =   _id_igv,
				fec_ingsistema  =   to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
				imp_venta  =   _imp_venta,
				imp_dcsto  =   _imp_dcsto,
				porcent_dcsto  =   _porcent_dcsto,
				imp_igv  =   _imp_igv,
				id_estado  =   _id_estado,
				id_proveedor  =   _id_proveedor,
				serie  =   _serie,
				id_tipocambio  =   _id_tipocambio,
				id_tipocompra  =   _id_tipocompra,
				doc_referencia  =   _doc_referencia,
				imp_bruto  =   _imp_bruto,
				imp_total  =   _imp_total,
				imp_exonerado  =   _imp_exonerado,
				id_operacion  =   _id_operacion,
				genera_letra  =   _genera_letra,
				id_moneda  =   _id_moneda,
				imp_afecto = _imp_afecto,
				id_responsable=_id_responsable,
				egreso=_egreso,
				glosa=_glosa,
				id_mes=_id_mes,
				id_centrocostos=_id_centrocostos
			WHERE  id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra ;
			res:= array['0', _id__compra::text, _id_sucursalcompra::TEXT];
		else
			res:=array['506','El registro no es factible Actualizar debido a que existe letras de pago canceladas'];
		end if;		
	else
		res:= array['504','Verifique que los datos de la compra esten ingresados correctamente' || cast(imp_movimiento as varchar(20))];
	end if;
   END IF;
END IF;
  return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.spi_detfacturacion(
    op integer,
    _id_sucursal integer,
    _id_facturacion integer,
    _item integer,
    _cantidad numeric,
    _id_almacen integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _precio numeric,
    _importe numeric,
    _imp_dscto numeric,
    _imp_igv numeric,
    _puntos numeric,
    _id_estado integer,
    _lista integer,
    _id_unimedventa integer,
    _descripcion_linea text,
    _ancho numeric,
    _largo numeric,
    _sugeta_percepcion boolean,
    _tipo_documento character,
    _imp_percepcion numeric,
    _porcent_percepcion numeric,
    _tg boolean,
    _icbper boolean,
    _imp_icbper numeric(20,4),--,
    _anticipo boolean,
    _costo numeric(20,4),
    _val_unidad numeric(20,4)
    --_afectacionigv_id integer
)
  RETURNS text[] AS
$BODY$
DECLARE
 RES TEXT[];
  ITEM_CORREL INTEGER;
  id_detfact bigint;
 -- _imp_percepcion numeric(20,4);
BEGIN
if op=1 then
	if exists (select *from ventas.tbl_facturacion where id_facturacion=_id_facturacion and   id_sucursal=_id_sucursal) then
		select max(item)  into ITEM_CORREL from ventas.tbl_detfacturacion where 
							id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
		if ITEM_CORREL is null then
			ITEM_CORREL=1;
		else
			ITEM_CORREL:=ITEM_CORREL+1;
		end if;

		select max(id_detfacturacion)  into id_detfact from ventas.tbl_detfacturacion ;
		
		if id_detfact is null then
			id_detfact=1;
		else
			id_detfact:=id_detfact+1;
		end if;
		
		/*if _sugeta_percepcion is true then
			if _tipo_documento='F' then
				_imp_percepcion=((_precio-_imp_igv)*0.02);
			end if;
			if _tipo_documento='B' then
				_imp_percepcion=((_precio)*0.02);
			end if;
		else
			_imp_percepcion=0;
		end if;*/
		if exists(select *from almacen.tbl_precio where  id_producto=_id_producto and id_listaprecio=_id_listaprecio and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio ) then 
			insert into VENTAS.TBL_DETFACTURACION(
				id_detfacturacion,
				item ,
				cantidad,
				id_almacen,
				id_producto,
				id_unidadventa,
				id_listaprecio,
				precio     ,
				importe    ,
				imp_dscto  ,
				imp_igv    ,
				puntos     ,
				id_sucursal,
				id_facturacion,
				id_estado,
				lista,
				id_unimedventa,
				descripcion_linea,
				ancho,
				largo,
				imp_percepcion,
				porcent_percepcion,
				tg,
				icbper,
				imp_icbper,
				anticipo,
				costo/*,
				val_unimedventa,
				num_unidades*/
				--afectacionigv_id
			)values(
				id_detfact,
				ITEM_CORREL,
				_cantidad,
				_id_almacen,
				_id_producto,
				_id_unidadventa,
				_id_listaprecio,
				_precio     ,
				_importe    ,
				_imp_dscto  ,
				_imp_igv    ,
				_puntos     ,
				_id_sucursal,
				_id_facturacion,
				_id_estado,
				_lista,
				_id_unimedventa,
				_descripcion_linea,
				_ancho,
				_largo,
				_imp_percepcion,
				_porcent_percepcion,
				_tg,
				_icbper,
				_imp_icbper,
				_anticipo,
				_costo/*,
				_val_unidad,
				(_val_unidad*_cantidad)*/
				--_afectacionigv_id
			)returning array['0',
					TBL_DETFACTURACION.item::text,
					TBL_DETFACTURACION.id_facturacion::text,
					TBL_DETFACTURACION.id_producto::text,
					TBL_DETFACTURACION.id_unidadventa::text,
					TBL_DETFACTURACION.id_listaprecio::text,
					TBL_DETFACTURACION.id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el detalle de la venta'];
			end if;
		else
			res:=array['506','Verifique que exista la unidad del producto ['|| _descripcion_linea ||']'];
		end if;
	else
		res:=array['503','El documento de venta no existe'];
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then

		/*if _sugeta_percepcion =true then
			if _tipo_documento='F' then
				_imp_percepcion=((_precio-_imp_igv)*0.02);
			end if;
			if _tipo_documento='B' then
				_imp_percepcion=((_precio)*0.02);
			end if;
		else
			_imp_percepcion=0;
		end if;
		*/
		update VENTAS.TBL_DETFACTURACION set 
			cantidad=_cantidad,
			precio=_precio,
			importe=_importe,
			imp_dscto=_imp_dscto  ,
			imp_igv=_imp_igv    ,
			puntos=_puntos  ,
			id_estado=_id_estado,
			lista=_lista ,
			id_unimedventa=_id_unimedventa ,
			descripcion_linea=_descripcion_linea,
			ancho=_ancho,
			largo=_largo,
			imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			tg=_tg,
			icbper=_icbper,
			imp_icbper=_imp_icbper,
			anticipo=_anticipo/*,
			val_unimedventa=_val_unidad,
			num_unidades=(_val_unidad*_cantidad)*/
			--afectacionigv_id=_afectacionigv_id
			where item=_item and id_producto=_id_producto and 
			id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and id_sucursal=_id_sucursal and id_facturacion=_id_facturacion;
			res:=array['0','Proceso efectuado con exito'];
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from almacen.fn_get_stock_mobil(332,2)

substring()

CREATE OR REPLACE FUNCTION ventas.spi_detfacturacion_agro(
    op integer,
    _id_sucursal integer,
    _id_facturacion integer,
    _item integer,
    _cantidad numeric,
    _id_almacen integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _precio numeric,
    _importe numeric,
    _imp_dscto numeric,
    _imp_igv numeric,
    _puntos numeric,
    _id_estado integer,
    _lista integer,
    _id_unimedventa integer,
    _descripcion_linea text,
    _ancho numeric,
    _largo numeric,
    _sugeta_percepcion boolean,
    _tipo_documento character,
    _imp_percepcion numeric,
    _porcent_percepcion numeric,
    _NUM_UNIDADES numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE
 RES TEXT[];
  ITEM_CORREL INTEGER;
  id_detfact bigint;
 -- _imp_percepcion numeric(20,4);
BEGIN
if op=1 then
	if exists (select *from ventas.tbl_facturacion where id_facturacion=_id_facturacion and   id_sucursal=_id_sucursal) then
		select max(item)  into ITEM_CORREL from ventas.tbl_detfacturacion where 
							id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
		if ITEM_CORREL is null then
			ITEM_CORREL=1;
		else
			ITEM_CORREL:=ITEM_CORREL+1;
		end if;

		select max(id_detfacturacion)  into id_detfact from ventas.tbl_detfacturacion ;
		
		if id_detfact is null then
			id_detfact=1;
		else
			id_detfact:=id_detfact+1;
		end if;
		
		/*if _sugeta_percepcion is true then
			if _tipo_documento='F' then
				_imp_percepcion=((_precio-_imp_igv)*0.02);
			end if;
			if _tipo_documento='B' then
				_imp_percepcion=((_precio)*0.02);
			end if;
		else
			_imp_percepcion=0;
		end if;*/
		insert into VENTAS.TBL_DETFACTURACION(
			id_detfacturacion,
			item ,
			cantidad,
			id_almacen,
			id_producto,
			id_unidadventa,
			id_listaprecio,
			precio     ,
			importe    ,
			imp_dscto  ,
			imp_igv    ,
			puntos     ,
			id_sucursal,
			id_facturacion,
			id_estado,
			lista,
			id_unimedventa,
			descripcion_linea,
			ancho,
			largo,
			imp_percepcion,
			porcent_percepcion,
			NUM_UNIDADES
		)values(
			id_detfact,
			ITEM_CORREL,
			_cantidad,
			_id_almacen,
			_id_producto,
			_id_unidadventa,
			_id_listaprecio,
			_precio     ,
			_importe    ,
			_imp_dscto  ,
			_imp_igv    ,
			_puntos     ,
			_id_sucursal,
			_id_facturacion,
			_id_estado,
			_lista,
			_id_unimedventa,
			_descripcion_linea,
			_ancho,
			_largo,
			_imp_percepcion,
			_porcent_percepcion,
			_NUM_UNIDADES
		)returning array['0',
				TBL_DETFACTURACION.item::text,
				TBL_DETFACTURACION.id_facturacion::text,
				TBL_DETFACTURACION.id_producto::text,
				TBL_DETFACTURACION.id_unidadventa::text,
				TBL_DETFACTURACION.id_listaprecio::text,
				TBL_DETFACTURACION.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el detalle de la venta'];
		end if;
	else
		res:=array['503','El documento de venta no existe'];
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then

		/*if _sugeta_percepcion =true then
			if _tipo_documento='F' then
				_imp_percepcion=((_precio-_imp_igv)*0.02);
			end if;
			if _tipo_documento='B' then
				_imp_percepcion=((_precio)*0.02);
			end if;
		else
			_imp_percepcion=0;
		end if;
		*/
		update VENTAS.TBL_DETFACTURACION set 
			cantidad=_cantidad,
			precio=_precio,
			importe=_importe,
			imp_dscto=_imp_dscto  ,
			imp_igv=_imp_igv    ,
			puntos=_puntos  ,
			id_estado=_id_estado,
			lista=_lista ,
			id_unimedventa=_id_unimedventa ,
			descripcion_linea=_descripcion_linea,
			ancho=_ancho,
			largo=_largo,
			imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			NUM_UNIDADES=_NUM_UNIDADES
			where item=_item and id_producto=_id_producto and 
			id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and id_sucursal=_id_sucursal and id_facturacion=_id_facturacion;
			res:=array['0','Proceso efectuado con exito'];
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION creditos.isp_actualiz_cuota_cobranza(
    _id_cuotas integer,
    _id_credito integer,
    _id_sucursal integer,
    _nro_letra varchar(5),
    _fec_vencimiento character varying,
    _imp_cuota numeric(14,6),
    _imp_interes numeric(14,6),
    _imp_capital numeric(14,6)
)
  RETURNS text[] AS
$BODY$
declare
	res text[];
begin
if exists(select * from creditos.tbl_cuota where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal) then
	update 
		creditos.tbl_cuota  set 
			 
			 
			nro_letra=_nro_letra,
			fec_vencimiento=_fec_vencimiento::TIMESTAMP,
			imp_cuota=_imp_cuota,
			imp_interes=_imp_interes,
			imp_capital=_imp_capital
			where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal;
			res:=array['0','Actualizacion registrada con exito'];
else
	res:=array['504','verefique que exista el registro que esta actualizando'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION creditos.isp_actualiz_cuota(
    _id_cuotas integer,
    _id_credito integer,
    _id_sucursal integer,
    _nro_letra character varying,
    _fec_vencimiento character varying,
    _fecha_protesto character varying,
    _dias_protesto integer,
    _nro_unicopago character varying)
  RETURNS text[] AS
$BODY$
declare
	res text[];
begin
if exists(select 1 from creditos.tbl_cuota where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal) then
	update 
		creditos.tbl_cuota  set 
			fecha_protesto=_fecha_protesto::TIMESTAMP,
			dias_protesto=_dias_protesto,
			nro_letra=_nro_letra,
			fec_vencimiento=_fec_vencimiento::TIMESTAMP,
			nro_unico_pago=_nro_unicopago
			where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal;
			res:=array['0','Actualizacion registrada con exito'];
else
	res:=array['504','verefique que exista el registro que esta actualizando'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION ventas.ips_detguiaventas(
    op integer,
    _id_guia integer,
    _id_sucursal integer,
    _cantidad numeric,
    _precio numeric,
    _total numeric,
    _dscto numeric,
    _imp_igv numeric,
    _porcent_igv numeric,
    _porcent_dscto numeric,
    _id_estado integer,
    _item integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _observaciones text,
    _lp integer,
    _id_lote character varying,
    _peso numeric,
    _descripcion_linea text,
    _modotexto boolean,
    _id_almacen integer,
    _id_inventario integer,
    _id_unimedventa integer,
    _val_unimedventa numeric,
    _base numeric,
    _haltura numeric)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	registro record;
	cant_acumulada  numeric(14,6);
	reg_orden record;
	
BEGIN
if op=1 then
  cant_acumulada=0.0;
	--if( exists (select 1 from almacen.tbl_almacen   where id_almacen =_id_almacen and id_sucursal= _id_sucursal)) then
		if exists(select  1 from ventas.TBL_GUIAREMISIONVENTA where id_guia=_id_guia and  id_sucursal=_id_sucursal) then
			if exists(select 1 from almacen.tbl_precio where id_producto=_id_producto and  id_unidadventa=_id_unidadventa  and  id_listaprecio=_id_listaprecio) then
				if exists(select *from almacen.tbl_existencia where id_producto=_id_producto and 
					id_unidadventa=_id_unidadventa and id_almacen=_id_almacen and id_inventario=_id_inventario) then
						insert into  VENTAS.TBL_DETGUIAVENTA(
							id_guia,
							id_sucursal,
							cantidad ,
							precio ,
							imp_total,
							dscto,
							imp_igv,
							porcent_igv,
							porcent_dscto,
							id_estado ,
							item,
							id_producto,
							id_unidadventa,
							id_listaprecio,
							--observaciones ,
							lp,
							--id_lote,
							peso,
							descripcion_linea,
							modo_texto ,
							id_almacen,
							id_inventario,
							id_unimedventa,
							VAL_UNIMEDVENTA,
							base,
							haltura
						)values(
							_id_guia,
							_id_sucursal,
							_cantidad ,
							_precio ,
							_total,
							_dscto,
							_imp_igv,
							_porcent_igv,
							_porcent_dscto,
							_id_estado ,
							_item,
							_id_producto,
							_id_unidadventa,
							_id_listaprecio,
							--_observaciones ,
							_lp,
							--_id_lote,
							_peso,
							_descripcion_linea,
							_modotexto ,
							_id_almacen,
							_id_inventario,
							_id_unimedventa,
							_VAL_UNIMEDVENTA,
							_base,
							_haltura
						)returning array['0',
								TBL_DETGUIAVENTA.id_guia::text, 
								TBL_DETGUIAVENTA.id_sucursal::text, 
								TBL_DETGUIAVENTA.item::text, 
								TBL_DETGUIAVENTA.id_producto::text, 
								TBL_DETGUIAVENTA.id_unidadventa::text, 
								TBL_DETGUIAVENTA.id_listaprecio::text] into res;
						if not found then
							res:=array['504','Inconsistencia inesperada al registrar el detelle, verefique que los datos esten ingresados correctamente'];
						end if;
				else
					res:=array['503','seleccione correctamente la unidad de medida del producto con el codigo :  ' || _id_producto || '',
					'Opciones :','1: Haciendo doble click sobre la unidad de medidad',
					'2: Ubicandoce sobre el codigo del producto y precionar enter','3: Verefique que el producto  tenga definido una unida de inventario '];
				end if;
			else
				res:=array['503','Seleccione correctamente el producto con el codigo : ' || _id_producto || '-' || '-'||_id_unidadventa::text];
			end if;
		else
			res:=array['502','verefique que exista la cabecera de la guia de remision '];
		end if;
	--else
	--	res:=array['502','verefique que el almacen este correctamente seleccionado y pertenesta a la sucursal de la empresa 111'];
	--end if;
end if;

if op=2 then
	if( exists (select 1 from almacen.tbl_almacen   where id_almacen =_id_almacen and id_sucursal= _id_sucursal)) then
		if exists(select  1 from ventas.tbl_guiaremisionventa where id_guia=_id_guia and  id_sucursal=_id_sucursal) then
			if exists(select 1 from almacen.tbl_precio where id_producto=_id_producto and  id_unidadventa=_id_unidadventa  and  id_listaprecio=_id_listaprecio) then
				if exists(select  1 from ventas.TBL_DETGUIAVENTA 
					where id_guia=_id_guia and id_sucursal=_id_sucursal and 
						item=_item and id_producto=_id_producto and id_unidadventa=_id_unidadventa and  id_listaprecio=_id_listaprecio) then
					update  VENTAS.TBL_DETGUIAVENTA set 
						cantidad =_cantidad,
						precio=_precio ,
						imp_total=_total,
						dscto=_dscto,
						imp_igv=_imp_igv,
						porcent_igv=_porcent_igv,
						porcent_dscto=_porcent_dscto,
						id_estado=_id_estado ,
						--observaciones=_observaciones ,
						lp=_lp,
						--id_lote=_id_lote,
						peso=_peso,
						descripcion_linea=_descripcion_linea,
						modo_texto =_modotexto ,
						id_almacen=_id_almacen,
						id_unimedventa=_id_unimedventa,
						VAL_UNIMEDVENTA=_VAL_UNIMEDVENTA,
						base=_base,
						haltura=_haltura
						where 
						id_guia=_id_guia and 
						id_sucursal=_id_sucursal and 
						item=_item and 
						id_producto=_id_producto and 
						id_unidadventa=_id_unidadventa and  
						id_inventario=_id_inventario;					
						res:=array['0',
						_id_guia::text,
						_id_sucursal::text,
						_item::text,_id_producto::text,_id_unidadventa::text,_id_listaprecio::text,
						'Inconsistencia inesperada al registrar el detelle, verefique que los datos esten ingresados correctamente'];
				else
					res:=array['503','Uno de los registro del detalle no existe en la base de datos'];
				end if;				
			else
				res:=array['503','Seleccione correctamente el producto con el codigo : ' || _id_producto || ''];
			end if;
		else
			res:=array['502','verefique  que los datos de la guia esten correctamente ingresados'];
		end if;
	else
		res:=array['502','verefique que el almacen este correctamente seleccionado y pertenesta a la sucursal de la empresa'];
	end if;
end if;
if op=3 then
	
end if;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ventas.FN_FACTURAR_PEDIDOS_REPARTO('27/10/2018',26,1)  

CREATE OR REPLACE   FUNCTION VENTAS.FN_FACTURAR_PEDIDOS_REPARTO(
fecha_facturacion text, 
_id_pedido bigint ,
_id_transportista integer,
_id_sucursal integer,
_id_usuario char(5)

)
RETURNS TEXT[] AS $$
DECLARE
	NRORGS integer;
	NroDocumentos INT;--numero de documentos que se tendrian que generar
	contador INT ;
	facturacion_id integer;
	_id_comprobante integer;
	_serie varchar(4);
	_numero varchar(7);	
	_imp_neto numeric(20,4);
	_imp_igv numeric(20,4);
	_imp_venta numeric(20,4);
	_imp_total numeric(20,4);
	_imp_bruto numeric(20,4);
	_imp_dscto numeric(20,4);
	_id_tipdocidentidad integer;
	res text[];
	
BEGIN
update ventas.tbl_cotizacionpreventa set id_transportista=_id_transportista where id_cotizapreventa=_id_pedido;

if (select 1 from VENTAS.V_PEDIDOSPENDIENTESFACTURACION where cantidad_pendiente>0 and id_cotizapreventa=_id_pedido ) then
	CREATE TEMPORARY TABLE  temp_detalle (
	  id int GENERATED ALWAYS AS IDENTITY,
	  id_cotizapreventa bigint NOT NULL,
	  id_sucursal integer NOT NULL,
	  cantidad numeric(20,4),
	  precio numeric(20,4),
	  imp_dscto numeric(20,4),
	  imp_igv numeric(20,4),
	  imp_total numeric(20,4),
	  descripcion_linea text,
	  id_estado integer,
	  id_producto character varying(20) NOT NULL,
	  id_unidadventa integer NOT NULL,
	  id_listaprecio integer NOT NULL,
	  id_almacen integer,
	  lp integer,
	  item integer NOT NULL,
	  tipo character(2),
	  modotexto boolean,
	  observaciones text,
	  id_unimedventa integer DEFAULT 1,  
	  porcent_percepcion numeric(20,6) DEFAULT 0,
	  imp_percepcion numeric(20,6) DEFAULT 0,
	  precio_sinpercepcion numeric(20,4) DEFAULT 0.00, 
	  status_reg integer 
	)ON COMMIT DROP;

	CREATE TEMPORARY TABLE TEM_REGSINTER(
	  id int  ,
	  id_cotizapreventa bigint NOT NULL,
	  id_sucursal integer NOT NULL,
	  cantidad numeric(20,4),
	  precio numeric(20,4),
	  imp_dscto numeric(20,4),
	  imp_igv numeric(20,4),
	  imp_total numeric(20,4),
	  descripcion_linea text,
	  id_estado integer,
	  id_producto character varying(20) NOT NULL,
	  id_unidadventa integer NOT NULL,
	  id_listaprecio integer NOT NULL,
	  id_almacen integer,
	  lp integer,
	  item integer NOT NULL,
	  tipo character(2),
	  modotexto boolean,
	  observaciones text,
	  id_unimedventa integer DEFAULT 1,  
	  porcent_percepcion numeric(20,6) DEFAULT 0,
	  imp_percepcion numeric(20,6) DEFAULT 0,
	  precio_sinpercepcion numeric(20,4) DEFAULT 0.00, 
	  status_reg integer 

	)ON COMMIT DROP;
	 

	INSERT INTO temp_detalle(
	  id_cotizapreventa ,
	  id_sucursal ,
	  cantidad ,
	  precio ,
	  imp_dscto ,
	  imp_igv ,
	  imp_total,
	  descripcion_linea ,
	  id_estado ,
	  id_producto,
	  id_unidadventa ,
	  id_listaprecio,
	  id_almacen ,
	  lp ,
	  item,
	  tipo,
	  modotexto ,
	  observaciones ,
	  id_unimedventa,  
	  porcent_percepcion ,
	  imp_percepcion ,
	  precio_sinpercepcion
	)
	SELECT id_cotizapreventa ,
	  id_sucursal ,
	  cantidad ,
	  precio ,
	  imp_dscto ,
	  imp_igv ,
	  imp_total,
	  descripcion_linea ,
	  id_estado ,
	  id_producto,
	  id_unidadventa ,
	  id_listaprecio,
	  id_almacen ,
	  lp ,
	  item,
	  tipo,
	  modotexto ,
	  observaciones ,
	  id_unimedventa,  
	  porcent_percepcion ,
	  imp_percepcion ,
	  precio_sinpercepcion FROM ventas.tbl_detpreventacotiza WHERE id_cotizapreventa=_id_pedido order by item;
	  select count(1) into NRORGS from temp_detalle; --obtenemos la cantidad de registros del detalle
	 -- select * from seguridad.v__documento__usuario
	  
	
	select cli.id_tipdocidentidad  into _id_tipdocidentidad from ventas.tbl_cotizacionpreventa  cp
	inner join planillas.tbl_persona cli on cli.id_persona=cp.id_cliente
	where id_cotizapreventa=_id_pedido;
	--select *from planillas.tbl_tipdocidentidad
	if (_id_tipdocidentidad in(2,4)) then
	--_serie:='0001';
		
		if _id_tipdocidentidad=2 then
			_id_comprobante:=2;
			--select *from common.tbl_comprobante order by 1
		end if;
		if _id_tipdocidentidad=4 then
			_id_comprobante:=3;
			--select *from common.tbl_comprobante order by 1
		end if;
		select serie into _serie from seguridad.v__documento__usuario where id_proceso=1 and id_comprobante=_id_comprobante and id_usuario=_id_usuario AND id_estado=1  and id_sucursal=_id_sucursal  ;
	   if NRORGS>15 then
		NroDocumentos:=0;
		if NRORGS%15=0 then 
			NroDocumentos:=NRORGS/15;--obtenemos el numero de documentos que se generaria en el pedido
		else
			NroDocumentos:= (NRORGS/15)+1;
		end if;
		contador:=0;
		--select *from common.tbl_comprobante order by 1
		
		
		while contador < NroDocumentos  loop
			select COALESCE(max(id_facturacion),0)+1 into facturacion_id from ventas.tbl_facturacion;
			select max(COALESCE(numero,0))+1 into _numero from common.v_configseries where id_tranzaccion='20' and id_comprobante=2 and serie=_serie AND id_estado=1 and  id_sucursal=_id_sucursal  ;
			insert into ventas.tbl_facturacion(
				id_facturacion,
				numdoc_facturacion,			
				id_tipoventa,
				id_tipocambio,
				id_igv,
				id_direccion,
				id_comprobante ,
				id_tranzaccion ,
				serie_facturacion,
				fecha_venta      ,
				imp_bruto        ,
				imp_dscto        ,
				imp_neto         ,
				imp_igv          ,
				imp_redondeo     ,
				imp_total        ,
				tasa_persepcion  ,
				valor_venta  ,
				id_moneda        ,
				id_estado        ,
				id_cliente       ,
				id_operacion     ,
				id_sucursal,
				id_cotizapreventa ,
				id_sucursalpreventa ,
				id_vendedor,
				id_transportista
							
					) 
			select facturacion_id,
				lpad(_numero,7,'0'),
				id_tipoventa,
				id_tipocambio,
				id_igv,
				id_direccion ,
				_id_comprobante,
				'20',
				_serie,
				fecha_facturacion::timestamp,
				imp_bruto        ,
				imp_dscto        ,
				imp_neto,
				imp_igv,
				0,
				imp_total,
				0,
				valor_venta,
				id_moneda        ,
				id_estado        ,
				id_cliente       ,
				id_operacion     ,
				id_sucursal,
				id_cotizapreventa ,
				id_sucursal ,
				id_vendedor,
				id_transportista
				from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_pedido;

				INSERT INTO TEM_REGSINTER(
					 id   ,
					 id_cotizapreventa ,
					  id_sucursal ,
					  cantidad,
					  precio,
					  imp_dscto ,
					  imp_igv ,
					  imp_total,
					  descripcion_linea,
					  id_estado ,
					  id_producto,
					  id_unidadventa,
					  id_listaprecio,
					  id_almacen ,
					  lp ,
					  item,
					  tipo,
					  modotexto ,
					  observaciones ,
					  id_unimedventa ,  
					  porcent_percepcion ,
					  imp_percepcion ,
					  precio_sinpercepcion , 
					  status_reg
				)
				select id   ,
					 id_cotizapreventa ,
					  id_sucursal ,
					  cantidad,
					  precio,
					  imp_dscto ,
					  imp_igv ,
					  imp_total,
					  descripcion_linea,
					  id_estado ,
					  id_producto,
					  id_unidadventa,
					  id_listaprecio,
					  id_almacen ,
					  lp ,
					  item,
					  tipo,
					  modotexto ,
					  observaciones ,
					  id_unimedventa ,  
					  porcent_percepcion ,
					  imp_percepcion ,
					  precio_sinpercepcion , 
					  0 from temp_detalle where id_cotizapreventa=_id_pedido and COALESCE(status_reg,0)=0  limit 15;
				
				insert into VENTAS.TBL_DETFACTURACION(
					item ,
					cantidad,
					id_almacen,
					id_producto,
					id_unidadventa,
					id_listaprecio,
					precio     ,
					importe    ,
					imp_dscto  ,
					imp_igv    ,
					puntos     ,
					id_sucursal,
					id_facturacion,
					id_estado,
					lista,
					id_unimedventa
				)
				select item ,
					cantidad,
					id_almacen,
					id_producto,
					id_unidadventa,
					id_listaprecio,
					precio     ,
					imp_total    ,
					imp_dscto  ,
					imp_igv    ,
					0     ,
					id_sucursal,
					facturacion_id,
					id_estado,
					lp,
					id_unimedventa from TEM_REGSINTER ;
					update TEMP_DETALLE set status_reg=1 where ID in(
							  select ID from TEM_REGSINTER
							  );
					select sum(imp_total) as imp_total,sum(imp_igv) as imp_igv,(sum(imp_total)-sum(imp_igv)) as imp_venta into _imp_total,_imp_igv,_imp_venta from TEM_REGSINTER;
					update ventas.tbl_facturacion set imp_total=_imp_total,imp_igv=_imp_igv,imp_neto=_imp_total,valor_venta=_imp_venta   where id_facturacion=facturacion_id; 
			delete from TEM_REGSINTER;		
			contador:=contador+1;
		end loop;
	else
		select COALESCE(max(id_facturacion),0)+1 into facturacion_id from ventas.tbl_facturacion;
			select max(COALESCE(numero,0))+1 into _numero from common.v_configseries where id_tranzaccion='20' and id_comprobante=2 and serie='0001' AND id_estado=1 and id_empresa=1 and id_sucursal=1  ;
			insert into ventas.tbl_facturacion(
				id_facturacion,
				numdoc_facturacion,			
				id_tipoventa,
				id_tipocambio,
				id_igv,
				id_direccion,
				id_comprobante ,
				id_tranzaccion ,
				serie_facturacion,
				fecha_venta      ,
				imp_bruto        ,
				imp_dscto        ,
				imp_neto         ,
				imp_igv          ,
				imp_redondeo     ,
				imp_total        ,
				tasa_persepcion  ,
				valor_venta  ,
				id_moneda        ,
				id_estado        ,
				id_cliente       ,
				id_operacion     ,
				id_sucursal,
				id_cotizapreventa ,
				id_sucursalpreventa ,
				id_vendedor,
				id_transportista			
					) 
			select facturacion_id,
				_numero,
				id_tipoventa,
				id_tipocambio,
				id_igv,
				id_direccion ,
				_id_comprobante,
				'20',
				_serie,
				fecha_facturacion::timestamp,
				imp_bruto        ,
				imp_dscto        ,
				imp_neto,
				imp_igv,
				0,
				imp_total,
				0,
				valor_venta,
				id_moneda        ,
				id_estado        ,
				id_cliente       ,
				id_operacion     ,
				id_sucursal,
				id_cotizapreventa ,
				id_sucursal ,
				id_vendedor,
				id_transportista
				from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_pedido;
			INSERT INTO TEM_REGSINTER(
					 id   ,
					 id_cotizapreventa ,
					  id_sucursal ,
					  cantidad,
					  precio,
					  imp_dscto ,
					  imp_igv ,
					  imp_total,
					  descripcion_linea,
					  id_estado ,
					  id_producto,
					  id_unidadventa,
					  id_listaprecio,
					  id_almacen ,
					  lp ,
					  item,
					  tipo,
					  modotexto ,
					  observaciones ,
					  id_unimedventa ,  
					  porcent_percepcion ,
					  imp_percepcion ,
					  precio_sinpercepcion , 
					  status_reg
				)
				select id   ,
					 id_cotizapreventa ,
					  id_sucursal ,
					  cantidad,
					  precio,
					  imp_dscto ,
					  imp_igv ,
					  imp_total,
					  descripcion_linea,
					  id_estado ,
					  id_producto,
					  id_unidadventa,
					  id_listaprecio,
					  id_almacen ,
					  lp ,
					  item,
					  tipo,
					  modotexto ,
					  observaciones ,
					  id_unimedventa ,  
					  porcent_percepcion ,
					  imp_percepcion ,
					  precio_sinpercepcion , 
					  0 from temp_detalle where id_cotizapreventa=_id_pedido and COALESCE(status_reg,0)=0  limit 8;
				
				insert into VENTAS.TBL_DETFACTURACION(
					item ,
					cantidad,
					id_almacen,
					id_producto,
					id_unidadventa,
					id_listaprecio,
					precio     ,
					importe    ,
					imp_dscto  ,
					imp_igv    ,
					puntos     ,
					id_sucursal,
					id_facturacion,
					id_estado,
					lista,
					id_unimedventa
				)
				select item ,
					cantidad,
					id_almacen,
					id_producto,
					id_unidadventa,
					id_listaprecio,
					precio     ,
					imp_total    ,
					imp_dscto  ,
					imp_igv    ,
					0     ,
					id_sucursal,
					facturacion_id,
					id_estado,
					lp,
					id_unimedventa from TEM_REGSINTER ;
					update TEMP_DETALLE set status_reg=1 where ID in(
							  select ID from TEM_REGSINTER
							  );
					select sum(imp_total) as imp_total,sum(imp_igv) as imp_igv,(sum(imp_total)-sum(imp_igv)) as imp_venta into _imp_total,_imp_igv,_imp_venta from TEM_REGSINTER;
					update ventas.tbl_facturacion set imp_total=_imp_total,imp_igv=_imp_igv,imp_neto=_imp_total,valor_venta=_imp_venta   where id_facturacion=facturacion_id; 
			delete from TEM_REGSINTER;	
		res:=array['0','Documentos generados'];
	end if;
      else
	res:=array['501','Tipo de documento de indentidad del cliente incorrecto'];
      end if;
  ----fin

 end if;
return res;
END;$$
LANGUAGE 'plpgsql';

select * from ventas.FN_FACTURAR_PEDIDOS_REPARTO('27/10/2018',26,1)

select *from ventas.tbl_cotizacionpreventa
delete from ventas.tbl_detfacturacion;
delete from ventas.tbl_facturacion;

CREATE OR REPLACE FUNCTION almacen.isp_seriecotizacionpreventa(
    op integer,
    __id_serieventa bigint,
    __id_sucursal integer,
    __id_cotizapreventa bigint,
    __id_almacen integer,
    __id_serie bigint,
    __item integer,
    __fecha_venta text,
    __id_usuario character,
    __id_estado integer,
    __observacion text)
  RETURNS text[] AS
$BODY$
declare
	__res text[];
	__id bigint;
begin
if op=1 then
	if exists(select 1 from almacen.tbl_serieproducto where id_serie=__id_serie)then
		if exists(select 1 from ventas.tbl_cotizacionpreventa f  where f.id_cotizapreventa=__id_cotizapreventa and id_sucursal=__id_sucursal)then
			
			select max(id_serieventa) into __id from almacen.tbl_seriecotizacionpreventa;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			INSERT INTO almacen.tbl_seriecotizacionpreventa(
				fecha_pedido, 
				fecha_reg, 
				id_usuario_r, 
				id_estado, 
				id_sucursal, 
				id_cotizapreventa, 
				id_almacen, 
				id_serie, 
				item, 
				observacion, 
				id_serieventa
			)
			VALUES (
				now(), 
				now(), 
				__id_usuario, 
				__id_estado, 
				__id_sucursal, 
				__id_cotizapreventa, 
				__id_almacen, 
				__id_serie, 
				__item, 
				__observacion, 
				__id
			)returning array['0',id_serie::text] into __res;
			if not found then
				__res=array['504','Inconsistencia inesperad al asociar la venta con serie'];
			end if;
			update almacen.tbl_serieproducto set id_estado=__id_estado where id_serie=__id_serie;
		else
			__res:=array['503','Verefique que exista el documento de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.tbl_seriecotizacionpreventa where id_serieventa=__id_serieventa)then
		update almacen.tbl_seriecotizacionpreventa set id_estado=__id_estado where id_serieventa=__id_serieventa;
		update almacen.tbl_serieproducto set id_estado=case when __id_estado<>18 then 16 else 18 end where id_serie=__id_serie;
		__res:=array['0',__id_serie::text];
	else
		__res:=almacen.isp_seriecotizacionpreventa(
			1,
			__id_serieventa,
			__id_sucursal,
			__id_facturacion,
			__id_almacen ,
			__id_serie,
			__item,
			__fecha_venta,
			__id_usuario,
			__id_estado,	
			__observacion
			);
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from common.tbl_estado order by 1

CREATE OR REPLACE FUNCTION migrate.query(cad text)
returns text[] as $$
declare
begin
  EXECUTE  cad;
return array['0','INSERT OK'];
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION VENTAS.FN_APROBAR_SOLICITUD_CREDITO(
	_id_solicitud bigint,
	_id_sucursal integer,
	_estado integer,
	_observacion text
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
	IF EXISTS(SELECT * FROM VENTAS.TBL_SOLICITUD_CREDITO WHERE ID=_id_solicitud AND ID_SUCURSAL=_id_sucursal) THEN
		UPDATE VENTAS.TBL_SOLICITUD_CREDITO  SET APROBADO=_estado,observaciones=_observacion  WHERE ID=_id_solicitud AND ID_SUCURSAL=_id_sucursal;
		res=array['0',case _estado when 1 then 'En evaluación' when 2 then 'Solicitud Aprobada' when 3 then 'Solicitud Rechazado' end];
	else
		res:=array['501','Verifique que el registro este seleccionado correctamente'];
	END IF;
return res;	
END;$$
LANGUAGE 'plpgsql';

create or replace function common.fn_ubigeo(
	_id_sector integer
)
returns table(
	sector varchar(200),
	zona varchar(200),
	distrito varchar(30),
	provincia varchar(30),
	departamento varchar(30),
	id_sector integer,
	id_zona integer,
	id_distrito varchar(8),
	id_provincia varchar(8),
	id_dpto varchar(8)
)as $$
declare
begin
return query select s.sector,z.zona,dist.distrito,prov.provincia,dpto.departamento,s.id_sector,z.id_zona,dist.id_distrito,prov.id_provincia,dpto.id_dpto 
from    ventas.tbl_sector s 
inner join ventas.tbl_zona z on z.id_zona=s.id_zona
inner join common.tbl_distrito dist on dist.id_distrito=z.id_distrito
inner join common.tbl_provincia prov on prov.id_provincia=dist.id_provincia
inner join common.tbl_dpto dpto on dpto.id_dpto=prov.id_dpto
--where s.id_sector=_id_sector;

end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION almacen.f_stock_unides(
    __id__producto text,
    __id__sucursal integer)
  RETURNS text AS
$BODY$
declare
	und text;
	dat record;
begin
	und:='';
	for dat in  select desc_corta as unidad, sum(stock_fisico) as stock ,dp.unidad_inventario as invent
	from almacen.tbl_existencia ex 
	inner join almacen.tbl_detproducto dp on (dp.id_producto=ex.id_producto and ex.id_unidadventa=dp.id_unidadventa)
	inner  JOIN almacen.tbl_almacen al ON al.id_almacen = ex.id_almacen  
	inner join almacen.tbl_unidad u on (u.id_unidadventa=ex.id_unidadventa)
	where ex.id_producto=__id__producto and al.id_sucursal=__id__sucursal and dp.id_estado=1
	group by desc_corta,dp.unidad_inventario loop
		if dat.invent=true then
			if dat.stock>0 then
				und=to_char(dat.stock,'9,999,999.99') || ' ' || dat.unidad ;
			--else
			--	und=to_char(dat.stock,'0.00') || ' ' || dat.unidad ;
			end if;
			
		else
			if dat.stock>0 then
				und=und || ' + ' || trim(to_char(dat.stock,'9,999,999.99')) || ' ' || dat.unidad ;
			end if;
			
		end if;
		
	
	end loop;
return und;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


create or replace  function almacen.fn_update_stock_migra(
	p_codigo varchar(30),
	p_unidad varchar(10),
	stock numeric(20,4)
)
returns text[] as  $$
declare
	dat record;
begin
for dat in select ex.id_producto,ex.id_unidadventa,ex.id_almacen from almacen.tbl_existencia ex
	   inner join almacen.tbl_unidad u on u.id_unidadventa=ex.id_unidadventa
	   inner join almacen.tbl_producto p on p.id_producto=ex.id_producto
	   where  upper(trim(p.codigo))=upper(trim(p_codigo)) --and upper(trim(u.desc_corta))=upper(trim(p_unidad)) 
	   loop
	   update almacen.tbl_existencia set stock_fisico=stock,stock_inicial=stock 
	   where id_producto=dat.id_producto and id_unidadventa=dat.id_unidadventa and 
	   id_almacen=dat.id_almacen;
end loop;
return array['0',''];
end;$$
language 'plpgsql';

select *from almacen.tbl_existencia

SELECT Id_facturacionref,ID_SUCURSALref, *FROM VENTAS.TBL_FACTURACION where nota_credito is true

update ventas.tbl_facturacion set id_estado=1

select * from ventas.SPI_ANULARVENTA(4,1,7)

CREATE OR REPLACE FUNCTION ventas.spi_anularventa(
    _id_facturacion integer,
    _id_sucursal integer,
    _id_estado integer)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_id_Serie bigint;
	dat record;
	
BEGIN

	IF EXISTS(SELECT *FROM VENTAS.TBL_FACTURACION WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL)THEN
		IF NOT  EXISTS(SELECT *FROM VENTAS.TBL_FACTURACION WHERE Id_facturacionref=_Id_facturacion AND ID_SUCURSALref=_ID_SUCURSAL and id_estado=1)THEN
			UPDATE VENTAS.TBL_FACTURACION SET ID_ESTADO=_ID_ESTADO  WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL;
			UPDATE caja.tbl_movcaja SET ID_ESTADO=_ID_ESTADO  WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL_FAC=_ID_SUCURSAL;
			UPDATE almacen.tbl_serieventa SET ID_ESTADO=_ID_ESTADO WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL;
			select id_serie into _id_serie from almacen.tbl_serieventa   WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL;
			update almacen.tbl_serieproducto set id_estado=1 where  id_serie=_id_serie;
			update creditos.tbl_credito set id_estado=_id_estado from creditos.tbl_ventacredito cv 
			where tbl_credito.id_credito=cv.id_credito and tbl_credito.id_sucursal_credito=cv.id_sucursal_credito 
				and cv.id_facturacion=_id_facturacion and cv.id_sucursal=_id_sucursal;	
			--cuanto se anula una venta que no tiene preventa
			IF exists(SELECT *FROM VENTAS.TBL_FACTURACION WHERE Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL AND id_cotizapreventa is not null) THEN 
				for dat in select id_producto,id_unidadventa,id_almacen ,cantidad
					from ventas.tbl_detfacturacion where Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL LOOP
					res:=(select almacen.spi_actualizar_existencias(2,dat.id_almacen,dat.id_producto,dat.id_unidadventa,dat.cantidad,0.00));
				end loop;
			ELSE
				for dat in select id_producto,id_unidadventa,id_almacen,cantidad 
					from ventas.tbl_detfacturacion where Id_facturacion=_Id_facturacion AND ID_SUCURSAL=_ID_SUCURSAL LOOP
					res:=(select almacen.spi_actualizar_existencias(3,dat.id_almacen,dat.id_producto,dat.id_unidadventa,dat.cantidad,0.00));
				end loop;
			END IF;
			RES:=array['0','Comprobante anulado correctamente'];
		ELSE
			RES:=array['501','El comprobante tiene notas de credito relacionadas'];
		END IF;
	else
		res:=array['504','Verefique que el documento de venta este seleccionado correctamente'];
	END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ventas.SPI_ANULARVENTA(2,1,7)

  SELECT *FROM caja.tbl_movcaja
  select * from contabilidad.list_diario(2,2,1,4,0,1,12)

select distinct @anio + @mes +'01'+'|'+numero_cta+'|'+SUBSTRING(REPLACE(nombre_cta, 'º','o'),1,99)
		+'|'+'01'+'|'+'-'+'|'+'1|'--,*
	from plancta plc with(nolock) 
	inner join DetalleAsientoContable das with(nolock) on plc.codigo_plancta = das.codigo_plancta
	inner join AsientoContable ac with(nolock) on ac.Codigo_asi = das.codigo_Asi
	where codproceso>2009 and LEN(numero_cta) > 3 and ac.codigo_pct = @codigo_pct and ac.mes_asi = CAST(@mes as int)


CREATE OR REPLACE FUNCTION contabilidad.list_diario(
    IN op integer,
    IN __nivel integer,
    IN __id__empresa integer,
    IN __id__proceso integer,
    IN __id__auxiliar integer,
    IN __id__mes__ini integer,
    IN __id__mes__fin integer)
  RETURNS TABLE(
	mes character varying, 
	codigo_cuo_dia bigint, 
	correlativo_dia bigint, 
	numero_asi integer, 
	tipo_das text, 
	auxiliar character varying, 
	cuenta text, 
	nom__cuenta text, 
	glosa__asi text, 
	debe numeric, 
	haber numeric, 
	numero text, 
	fecha text, 
	cod_libro integer, 
	codigosunat text) AS
$BODY$
declare
	__anio__proceso integer;
begin
	select cast(descripcion as integer) into __anio__proceso from contabilidad.tbl_procesocontable where id_proceso=__id__proceso;
	if __id__auxiliar<>-1 then
		if __nivel<>1 then --> Cuando es de 2 o 3 digitos     
			RETURN QUERY  select  
				m.descripcion as mes,
				dc.codigo__cuo__dia,
				dc.correlativo__dia,
				ac.numero_asi,
				case when COALESCE(sum(dc.debe_das),0)>0 then 'D' else 'H' end tipo_das,
				ax.descripcion as auxiliar, 
				substring(pc.nro_cuenta  from 1 for __nivel) as cuenta,
				pc.nombre_cuenta,
				/*case ax.id_auxiliar 
				when 1 then 'Compra de mercaderia' 
				when 2 then 'Venta de mercaderia' 
				end */
				ac.glosa_asi,
				SUM(COALESCE(dc.debe_das,0)) as debe_das,
				SUM(COALESCE(dc.haber_das,0)) as haber_das,
				dc.serie || '-' || dc.numero,
				to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text as fecha,
				ax.cod_libro,
				cp.codigosunat
				--pc.nro_cuenta 
			from 
				contabilidad.tbl__asiento__contable ac 
				inner join contabilidad.tbl_subdiario sub on (sub.id=ac.subdiario_id) 
				inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
				inner join contabilidad.tbl__detalle__asiento__contable dc on (ac.id_asiento=dc.id_asiento) 
				inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dc.id_plancuenta) 
				inner join common.tbl_mes m on (m.id_mes=date_part('month',cast(dc.fechadoc_das as date))) 
				inner join common.tbl_comprobante cp  on(cp.id_comprobante=dc.id_comprobante)
				--select *from contabilidad.tbl_auxiliar
				where 
					date_part('year',cast(dc.fechadoc_das as date))=__anio__proceso 
					AND  m.id_mes>=__id__mes__ini 
					AND  m.id_mes<=__id__mes__fin  
					AND case when op=1 then ax.id_auxiliar=__id__auxiliar else ax.id_auxiliar in(1,2,3,4,5,6,7,8,9,10,11,12) end
				GROUP BY 
					m.descripcion ,
					dc.codigo__cuo__dia,
					dc.correlativo__dia,
					ac.numero_asi,
					ac.glosa_asi,
					ax.descripcion,
					substring(pc.nro_cuenta  from 1 for __nivel),
					pc.nombre_cuenta,
					--dc.concepto_das,
					dc.serie,
					dc.numero,
					to_char(dc.fechadoc_das::DATE,'dd/mm/yyyy')::text,
					ax.cod_libro,
					cp.codigosunat,
					ax.id_auxiliar
					
			order by dc.serie,dc.numero,6 ;
		else -- cuando es analitico
			RETURN QUERY select  m.descripcion as mes,
				dc.codigo__cuo__dia,
				dc.correlativo__dia,
				ac.numero_asi,
				case when COALESCE(sum(dc.debe_das),0)>0 then 'D' else 'H' end tipo_das,
				ax.descripcion as auxiliar, 
				pc.nro_cuenta as cuenta,
				pc.nombre_cuenta,
				/*case ax.id_auxiliar 
				when 1 then 'Compra de mercaderia' 
				when 2 then 'Venta de mercaderia' 
				end */ ac.glosa_asi,
				COALESCE(sum(dc.debe_das),0) as debe_das,
				COALESCE(sum(dc.haber_das),0) as haber_das,
				dc.serie || '-' || dc.numero,
				to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text as fecha,
				ax.cod_libro,
				cp.codigosunat
				--pc.nro_cuenta 
			from 
				contabilidad.tbl__asiento__contable ac 
				inner join contabilidad.tbl_subdiario sub on (sub.id=ac.subdiario_id) 
				inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
				inner join contabilidad.tbl__detalle__asiento__contable dc on (ac.id_asiento=dc.id_asiento) 
				inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dc.id_plancuenta) 
				inner join common.tbl_mes m on (m.id_mes=date_part('month',cast(dc.fechadoc_das as date)))
				inner join common.tbl_comprobante cp  on(cp.id_comprobante=dc.id_comprobante)
				where   
					date_part('year',cast(dc.fechadoc_das as date))=__anio__proceso 
					and m.id_mes>=__id__mes__ini 
					and  m.id_mes<=__id__mes__fin
					AND case when op=1 then ax.id_auxiliar=__id__auxiliar else ax.id_auxiliar in(1,2,3,4,5,6,7,8,9,10,11,12) end
				group by m.descripcion ,
					dc.codigo__cuo__dia,
					dc.correlativo__dia,
					ac.numero_asi,
					ac.glosa_Asi,
					ax.descripcion,
					pc.nro_cuenta,
					pc.nombre_cuenta,
					--dc.concepto_das,
					dc.serie,
					dc.numero,
					to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text,
					ax.cod_libro,
					cp.codigosunat,
					ax.id_auxiliar
			order by dc.serie,dc.numero,6 ;
		end if;	
	else
		if __nivel<>1 then --> Cuando es de 2 o 3 digitos     
			RETURN QUERY  select  m.descripcion as mes,
				dc.codigo__cuo__dia,
				dc.correlativo__dia,
				ac.numero_asi,
				case when COALESCE(sum(dc.debe_das),0)>0 then 'D' else 'H' end tipo_das,
				ax.descripcion as auxiliar, 
				substring(pc.nro_cuenta  from 1 for __nivel) as cuenta,
				pc.nombre_cuenta,
				/*case ax.id_auxiliar 
				when 1 then 'Compra de mercaderia' 
				when 2 then 'Venta de mercaderia' 
				end  */
				ac.glosa_asi,
				COALESCE(sum(dc.debe_das),0) as debe_das,
				COALESCE(sum(dc.haber_das),0) as haber_das,
				dc.serie || '-' || dc.numero,
				to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text as fecha,
				ax.cod_libro,
				cp.codigosunat
				--pc.nro_cuenta 
			from 
				contabilidad.tbl__asiento__contable ac 
				inner join contabilidad.tbl_subdiario sub on (sub.id=ac.subdiario_id) 
				inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id
				inner join contabilidad.tbl__detalle__asiento__contable dc on (ac.id_asiento=dc.id_asiento) 
				inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dc.id_plancuenta) 
				inner join common.tbl_mes m on (m.id_mes=date_part('month',cast(dc.fechadoc_das as date)))
				inner join common.tbl_comprobante cp  on(cp.id_comprobante=dc.id_comprobante)
				where 
					date_part('year',cast(dc.fechadoc_das as date))=__anio__proceso 
					AND  m.id_mes>=__id__mes__ini 
					AND  m.id_mes<=__id__mes__fin
					AND case when op=1 then ax.id_auxiliar=__id__auxiliar else ax.id_auxiliar in(1,2,3,4,5,6,7,8,9,10,11,12) end
				group by m.descripcion ,
					dc.codigo__cuo__dia,
					dc.correlativo__dia,
					ac.numero_asi,
					ac.glosa_asi,
					ax.descripcion,
					pc.nro_cuenta,
					pc.nombre_cuenta,
					--dc.concepto_das,
					dc.serie,
					dc.numero,
					to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text,
					ax.cod_libro,
					cp.codigosunat,
					ax.id_auxiliar
			order by dc.serie,dc.numero,6 ;
		else -- cuando es analitico
			RETURN QUERY select  m.descripcion as mes,
				dc.codigo__cuo__dia,
				dc.correlativo__dia,
				ac.numero_asi,
				case when COALESCE(sum(dc.debe_das),0)>0 then 'D' else 'H' end tipo_das,
				ax.descripcion as auxiliar, 
				pc.nro_cuenta as cuenta,
				pc.nombre_cuenta,
				/*case ax.id_auxiliar 
				when 1 then 'Compra de mercaderia' 
				when 2 then 'Venta de mercaderia' 
				end */ ac.glosa_asi,
				COALESCE(sum(dc.debe_das),0) as debe_das,
				COALESCE(sum(dc.haber_das),0) as haber_das,
				dc.serie || '-' || dc.numero,
				to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text as fecha,
				ax.cod_libro,
				cp.codigosunat
				--pc.nro_cuenta 
			from 
				contabilidad.tbl__asiento__contable ac 
				inner join contabilidad.tbl_subdiario sub on (sub.id=ac.subdiario_id) 
				inner join contabilidad.tbl_auxiliar ax on ax.id_auxiliar=sub.auxiliar_id 
				inner join contabilidad.tbl__detalle__asiento__contable dc on (ac.id_asiento=dc.id_asiento) 
				inner join contabilidad.tbl_plancuenta pc on (pc.id_plancuenta=dc.id_plancuenta) 
				inner join common.tbl_mes m on (m.id_mes=date_part('month',cast(dc.fechadoc_das as date)))
				inner join common.tbl_comprobante cp  on(cp.id_comprobante=dc.id_comprobante)
				where   
					date_part('year',cast(dc.fechadoc_das as date))=__anio__proceso 
					and m.id_mes>=__id__mes__ini 
					and  m.id_mes<=__id__mes__fin	
					AND case when op=1 then ax.id_auxiliar=__id__auxiliar else ax.id_auxiliar in(1,2,3,4,5,6,7,8,9,10,11,12) end
				group by m.descripcion ,
					dc.codigo__cuo__dia,
					dc.correlativo__dia,
					ac.numero_asi,
					ac.glosa_asi,
					ax.descripcion,
					pc.nro_cuenta,
					pc.nombre_cuenta,
					--dc.concepto_das,
					dc.serie,
					dc.numero,
					to_char(dc.fechadoc_das::date,'dd/mm/yyyy')::text,
					ax.cod_libro,
					cp.codigosunat,
					ax.id_auxiliar
			order by dc.serie,dc.numero,6 ;
		end if;	
	end if;			
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE FUNCTION contabilidad.list_consultarlibroventa(
    IN op integer,
    IN mes integer,
    IN fecha_ini text,
    IN fecha_fin text,
    IN __id__empresa integer,
    IN __anio integer)
  RETURNS TABLE(_fecha text, _tipo_doc character, _serie character, _numero character varying, _codigo character varying, _cliente character varying, _valor_venta numeric, _igv numeric, _imp_neto numeric, _codigo_cov bigint, _id_estado integer, _id_movtabla bigint, _id_empresa integer, _id_sucursal integer, _tipo_doccliente integer, _tipo_docsunat text, _va_afecto numeric, _va_exonerado numeric, _imp_percepcion numeric, _fecha_ref text, _serie_ref text, _numero_ref text) AS
$BODY$
declare
begin

 return query SELECT     
  Fecha,    
  tipodoc as tipo_doc,    
  serie,    
  NUMERO,    
  Codigo,    
  cliente,    
  --case when codigo_Tdo=19 then valor_venta*-1 else valor_venta end  as Valor_Venta,    
   CASE estado_das
            WHEN 1 THEN case when codigo_Tdo =19 then valor_venta*-1 else valor_venta end
            WHEN 7 THEN 0::numeric
            WHEN 3 THEN 0::numeric
            ELSE 0::numeric(20,4)
        END AS valor_venta,
CASE estado_das
            WHEN 1 THEN case when codigo_Tdo =19 then imp_igv*-1 else imp_igv end 
            WHEN 7 THEN 0::numeric
            WHEN 3 THEN 0::numeric
            ELSE 0::numeric(20,4)
        END AS igv   ,
  CASE estado_das
            WHEN 1 THEN case when codigo_Tdo =19 then total*-1 else total end 
            WHEN 7 THEN 0::numeric
            WHEN 3 THEN 0::numeric
            ELSE 0::numeric(20,4)
        END AS imp_neto,
  --case when codigo_Tdo=19 then  total*-1 else total end as Precio_Venta,
     
  --ROW_NUMBER() OVER ( PARTITION BY date_part('month',Fecha::date)     ORDER BY FECHA ASC) as     
  1::bigint codigo_cov ,
  estado_das ,
  CODIGO_MOVTABLA ,
  id_empresa,
  id_sucursal ,
  CASE
            WHEN length(Codigo::text) <= 8 THEN 1
            ELSE 6
        END AS tipo_docliente,
      CASE codigo_Tdo
            WHEN 3 THEN '01'::text
            WHEN 2 THEN '03'::text
            WHEN 19 THEN '07'::text
            ELSE '00'::text
        END AS tipo,
        case when imp_igv>0 then  
	 CASE estado_das
            WHEN 1 THEN case when codigo_Tdo =19 then valor_venta*-1 else valor_venta end
            WHEN 7 THEN 0::numeric
            WHEN 3 THEN 0::numeric
            ELSE 0::numeric(20,4)
        END  else 0 end as va_afecto,
        0::numeric(20,4) as va_exonerado,
        0::numeric(20,4) as imp_percepcion,
        null::text fecha_ref,
        null::text serie_ref,
        null::text numero_ref
 FROM CONTABILIDAD.V_PIVOTLIBROVENTAS 
    
 where case when op=1 then 
Fecha::date>=fecha_ini::date and Fecha::date<=fecha_fin::date else (id_mes=mes and anio=__anio) end and  id_empresa=__id__empresa
 --datediff('second',fecha_ini::timestamp, Fecha::timestamp)>=0    --> Fecha de inicio      
  -- and datediff('second',fecha_fin::timestamp, Fecha::timestamp)<0 --> Fecha fin
order by Fecha::date,codigo_Tdo,serie::integer,numero::integer;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

  
CREATE OR REPLACE FUNCTION ventas.fn_ref_guia_ventas(
    _id_facturacion bigint,
    _id_sucursal integer)
  RETURNS text AS
$BODY$
declare 
	response text;
	dat record;
begin
response:='';
	for dat in select * from ventas.tbl_guiaremisionventa  
	where id_facturacion=_id_facturacion and id_sucursalfac=_id_sucursal and id_estado=1 loop
		response='T'||right(dat.serie,3) || '-' || dat.numero || ', ' || response;
	end loop;
	return response;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.func_correlativo_solicitud_credito()
  RETURNS trigger AS
$BODY$
DECLARE
	CORRELATIVO NUMERIC(20,0);
	MUMERO_CORREL TEXT;
BEGIN
	IF exists(select *from COMMON.TBL_CONFIGSERIE where id_tranzaccion=new.id_tranzaccion and 
								id_comprobante=new.id_comprobante and 
								serie=new.serie and id_estado=1 and id_sucursal=new.id_sucursal ) then
		 
			select  max(numero::NUMERIC) into CORRELATIVO from  COMMON.TBL_CONFIGSERIE where  
									id_tranzaccion=NEW.id_tranzaccion and 
									id_comprobante=NEW.id_comprobante and 
									serie=NEW.serie and id_estado=1 and id_sucursal=new.id_sucursal;
			if CORRELATIVO IS NULL THEN
				MUMERO_CORREL='1';
			ELSE
				MUMERO_CORREL=(CORRELATIVO+1)::TEXT;
			END IF;
			UPDATE COMMON.TBL_CONFIGSERIE SET NUMERO =MUMERO_CORREL::integer WHERE   
								id_tranzaccion=NEW.id_tranzaccion and 
								id_comprobante=NEW.id_comprobante and 
								serie=NEW.serie  and id_estado=1 and id_sucursal=new.id_sucursal;
		 
	ELSE
		RAISE EXCEPTION 'NO SE HA GENERADO EL CORRELATIVO OPERACION BLOQUEDA';
	end if;
RETURN NEW;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE TRIGGER trig_gencod_corel_solicitud_credito
  BEFORE INSERT
  ON ventas.tbl_solicitud_credito
  FOR EACH ROW
  EXECUTE PROCEDURE ventas.func_correlativo_solicitud_credito();

select *from ventas.tbl_solicitud_credito

CREATE OR REPLACE FUNCTION ventas.fn_solicitud_credito(
	op integer,
	_id bigint,
	_id_sucursal integer,
	_uuid character varying,
	_id_comprobante integer,
	_serie character varying,
	_numero character varying,
	_tipo_credito character,
	_precio_lista numeric,
	_inicial numeric,
	_nro_cuotas numeric,
	_importe_cuotas numeric,
	_importe_financiamiento numeric,
	_monto_afinanciar numeric,
	_id_vendedor character varying,
	_id_serie bigint,
	_id_pedido bigint,
	_id_facturacion integer,
	_id_estado integer,
	_id_usuario character,
	_id_cliente character varying,
	_id_dircliente bigint,
	_id_evaluacioncliente bigint,
	_id_cliente_conyuge character varying,
	_id_dircli_conyuge bigint,
	_id_garante character varying,
	_id_credito integer,
	_id_tranzaccion character,
	_id_tipoventa integer,
	_observaciones text,
	_id_ussaprueba character,
	_id_producto character varying,
	_id_unidadventa integer,
	_id_listaprecios integer,
	_fec_primer_vencimiento text,
	_fec_vencimiento text,
	_otros_imp numeric,
	_id_moneda integer,
	_imp_debe_inicial numeric,
	_imp_interes_cuota numeric,
	_imp_capital_cuota numeric,
	_imp_debe_dias integer,
	_intervalo_dias integer,
	_intervalo_entre_cuotas boolean,
	_imp_tasa numeric,
	_dias_gracia integer,
	_ocupacion_cliente varchar(200) ,
	_profecion_cliente varchar(200) ,
	_trabajo_actual_cliente varchar(200) ,
	_cargo_cliente varchar(150) ,
	_dir_trabajo_cliente varchar(500) ,
	_antiguedad_trabajo_cliente varchar(30) ,
	_ingresos_cliente numeric(14,2) ,
	_otros_ingresos_cliente numeric(14,2) ,
	_ocupacion_conyuge varchar(200) ,
	_profecion_conyuge varchar(200) ,
	_trabajo_actual_conyuge varchar(200) ,
	_cargo_conyuge varchar(150) ,
	_dir_trabajo_conyuge varchar(500) ,
	_antiguedad_trabajo_conyuge varchar(30) ,
	_ingresos_conyuge numeric(14,2) ,
	_otros_ingresos_conyuge numeric(14,2) 
    )
  RETURNS text AS
$BODY$
DECLARE 
	res text;
	--_id bigint;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_dircliente) THEN		
		IF(SELECT 1 FROM PLANILLAS.TBL_PERSONA WHERE ID_PERSONA=_ID_VENDEDOR) THEN
			select max(id) into _id from ventas.tbl_solicitud_credito;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO ventas.tbl_solicitud_credito(
				id, 
				id_sucursal, 
				id_comprobante, 
				serie, 
				numero, 
				fecha_registro, 				   
				precio_lista, 
				inicial, 
				nro_cuotas, 
				importe_cuotas, 
				importe_financiamiento, 
				monto_afinanciar, 
				id_vendedor, 
				id_serie, 
				id_pedido, 
				id_facturacion, 
				id_estado, 
				id_usuario, 
				id_cliente, 
				id_dircliente, 
				id_evaluacioncliente, 
				id_cliente_conyuge, 
				id_dircli_conyuge, 
				id_garante, 
				id_credito, 
				id_tranzaccion, 
				id_tipoventa, 
				observaciones, 
				id_ussaprueba, 			   
				fec_primer_vencimiento, 
				fec_vencimiento, 
				otros_imp, 
				id_moneda,
				imp_debe_inicial,
				imp_interes_cuota,
				imp_capital_cuota,
				imp_debe_dias,
				intervalo_dias,
				intervalo_entre_cuotas,
				imp_tasa, 
				dias_gracia,
				ocupacion_cliente ,
				profecion_cliente ,
				trabajo_actual_cliente ,
				cargo_cliente  ,
				dir_trabajo_cliente  ,
				antiguedad_trabajo_cliente ,
				ingresos_cliente  ,
				otros_ingresos_cliente  ,
				ocupacion_conyuge ,
				profecion_conyuge ,
				trabajo_actual_conyuge ,
				cargo_conyuge  ,
				dir_trabajo_conyuge  ,
				antiguedad_trabajo_conyuge ,
				ingresos_conyuge  ,
				otros_ingresos_conyuge  
			    )
		    VALUES (
			_id, 
			_id_sucursal, 
			_id_comprobante, 
			_serie, 
			_numero, 
			now(), 				   
			_precio_lista, 
			_inicial, 
			_nro_cuotas, 
			_importe_cuotas, 
			_importe_financiamiento, 
			_monto_afinanciar, 
			_id_vendedor, 
			_id_serie, 
			_id_pedido, 
			_id_facturacion, 
			_id_estado, 
			_id_usuario, 
			_id_cliente, 
			_id_dircliente, 
			_id_evaluacioncliente, 
			_id_cliente_conyuge, 
			_id_dircli_conyuge, 
			_id_garante, 
			_id_credito, 
			_id_tranzaccion, 
			_id_tipoventa, 
			_observaciones, 
			_id_ussaprueba, 			    
			_fec_primer_vencimiento::timestamp, 
			_fec_vencimiento::timestamp, 
			_otros_imp, 
			_id_moneda,
			_imp_debe_inicial,
			_imp_interes_cuota,
			_imp_capital_cuota,
			_imp_debe_dias,
			_intervalo_dias,
			_intervalo_entre_cuotas,
			_imp_tasa, 
			_dias_gracia,
			_ocupacion_cliente ,
			_profecion_cliente ,
			_trabajo_actual_cliente ,
			_cargo_cliente  ,
			_dir_trabajo_cliente  ,
			_antiguedad_trabajo_cliente ,
			_ingresos_cliente  ,
			_otros_ingresos_cliente  ,
			_ocupacion_conyuge ,
			_profecion_conyuge ,
			_trabajo_actual_conyuge ,
			_cargo_conyuge  ,
			_dir_trabajo_conyuge  ,
			_antiguedad_trabajo_conyuge ,
			_ingresos_conyuge  ,
			_otros_ingresos_conyuge  
			   ) returning array['0',id::text,id_sucursal::text,'Solicitud registrada correctamente'] into res;
			   if not found then
				res:=array['504','Inconsistencia inesperada'];
			   end if;
			   --res:=array['0','Solicitud registrada correctamente'];
			
		ELSE
			res:=array['0','Seleccione el vendedor'];
		END IF;		 	
	ELSE
		res:=array['0','Verifique que los datos del cliente este ingresado correctamente'];
	END IF;
END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_dircliente) THEN		
			IF(SELECT 1 FROM PLANILLAS.TBL_PERSONA WHERE ID_PERSONA=_ID_VENDEDOR) THEN
				 
				UPDATE ventas.tbl_solicitud_credito SET
				    id_sucursal=_id_sucursal, 
				    id_comprobante=_id_comprobante, 
				    serie=_serie, 
				    numero=_numero, 
				    precio_lista=_precio_lista, 
				    inicial=_inicial, 
				    nro_cuotas=_nro_cuotas, 
				    importe_cuotas=_importe_cuotas, 
				    importe_financiamiento=_importe_financiamiento, 
				    monto_afinanciar=_monto_afinanciar, 
				    id_vendedor=_id_vendedor, 
				    id_serie=_id_serie, 
				    id_pedido=_id_pedido, 
				    id_facturacion=_id_facturacion, 
				    id_estado=_id_estado, 
				    id_usuario=_id_usuario, 
				    id_cliente=_id_cliente, 
				    id_dircliente=_id_dircliente, 
				    id_evaluacioncliente=_id_dircliente, 
				    id_cliente_conyuge=_id_cliente_conyuge, 
				    id_dircli_conyuge=_id_dircli_conyuge, 
				    id_garante=_id_garante, 
				    id_credito=_id_credito, 
				    id_tranzaccion=_id_tranzaccion, 
				    id_tipoventa=_id_tipoventa, 
				    observaciones=_observaciones, 
				    id_ussaprueba=_id_ussaprueba, 				    
				    fec_primer_vencimiento=_fec_primer_vencimiento::timestamp, 
				    fec_vencimiento=_fec_vencimiento::timestamp, 
				    otros_imp=_otros_imp, 
				    id_moneda=_id_moneda,
				    imp_debe_inicial=_imp_debe_inicial,
				    imp_interes_cuota=_imp_interes_cuota,
				    imp_capital_cuota=_imp_capital_cuota,
				    imp_debe_dias=_imp_debe_dias,
				    intervalo_dias=_intervalo_dias,
				    intervalo_entre_cuotas=_intervalo_entre_cuotas,
				    imp_tasa=_imp_tasa, 
				    dias_gracia=_dias_gracia,
					ocupacion_cliente =_ocupacion_cliente ,
					 profecion_cliente=_profecion_cliente ,
					 trabajo_actual_cliente=_trabajo_actual_cliente ,
					 cargo_cliente=_cargo_cliente  ,
					 dir_trabajo_cliente=_dir_trabajo_cliente  ,
					 antiguedad_trabajo_cliente=_antiguedad_trabajo_cliente ,
					 ingresos_cliente=_ingresos_cliente  ,
					 otros_ingresos_cliente=_otros_ingresos_cliente  ,
					 ocupacion_conyuge=_ocupacion_conyuge ,
					 profecion_conyuge=_profecion_conyuge ,
					 trabajo_actual_conyuge=_trabajo_actual_conyuge ,
					 cargo_conyuge=_cargo_conyuge  ,
					 dir_trabajo_conyuge=_dir_trabajo_conyuge  ,
					 antiguedad_trabajo_conyuge=_antiguedad_trabajo_conyuge ,
					 ingresos_conyuge=_ingresos_conyuge  ,
					 otros_ingresos_conyuge=_otros_ingresos_conyuge  
				    where  id=_id;
				   res:=array['0',_id::text,_id_sucursal::text,'Solicitud actualizada correctamente'];
				
			ELSE
				res:=array['0','Seleccione el vendedor'];
			END IF;			
	ELSE
		res:=array['0','Verifique que los datos del cliente este ingresado correctamente'];
	END IF;
END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ventas.spi_direccion(2,'JR: 20 DE ABRIL Y E. SAN MARTIN S7N',1691,'01036419','',1,0)

CREATE OR REPLACE FUNCTION ventas.spi_direccion(
    op integer,
    _direccion text,
    _id_sector integer,
    _id_persona text,
    _referencia text,
    _id_estado integer,
    _id_direccion bigint,
    _id_tipvivienda INTEGER
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl bigint;
BEGIN
if op=1 then
		select max(id_direccion) into correl from ventas.tbl_direccion;
		if correl is null then
			correl = 1;
		else
			correl = correl + 1;
		end if;
		insert into ventas.tbl_direccion(
			  id_direccion,
			  direccion,
			  id_sector,
			  id_persona,
			  referencia,
			  id_estado,
			  id_tipvivienda
		)values(
			  correl,
			  _direccion,
			  _id_sector,
			  _id_persona,
			  _referencia,
			  _id_estado,
			  _id_tipvivienda
		)returning array['0',tbl_direccion.id_direccion::text] into res;
		if not found then
			res:=array['504','Inconsistencia inespera al momento de registar el telefono del cliente'];
		end if;
end if;
if op = 2 then
	if exists(select * from ventas.tbl_direccion where id_persona = _id_persona and id_direccion = _id_direccion) then
		update ventas.tbl_direccion set 
			  direccion = _direccion,
			  id_sector = _id_sector,
			  referencia = _referencia,
			  id_estado = _id_estado,
			  id_tipvivienda=_id_tipvivienda
		  where id_persona = _id_persona and id_direccion = _id_direccion;
		  res:=array['0',_id_direccion::text, _id_persona];
	else
		res:=array['504','Verifique que los datos del cliente esten ingresado correctamente \n<<Direccion no Actualizada>>'];
	end if;
end if;
	return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION compras.spiu_egresos(
    op integer,
    _nro_doc_compra character,
    _fec_documento text,
    _id_dirproveedor bigint,
    _id_comprobante integer,
    _id_tranzaccion character,
    _id_igv integer,
    _anio integer,
    _id_compra integer,
    _id_mes integer,
    _fec_ingsistema text,
    _imp_venta numeric,
    _imp_dcsto numeric,
    _porcent_dcsto numeric,
    _imp_igv numeric,
    _id_sucursalcompra integer,
    _id_estado integer,
    _id_proveedor character varying,
    _serie character,
    _id_tipocambio integer,
    _id_tipocompra integer,
    _doc_referencia character,
    _imp_bruto numeric,
    _imp_total numeric,
    _imp_exonerado numeric,
    _id_operacion integer,
    _genera_letra boolean,
    _id_moneda integer,
    _imp_afecto numeric,
    _id_responsable character varying,
    _egreso boolean,
    _glosa text,
    _id__compra bigint,
    _fec_vencimiento text,
    _afecto_detraccion boolean,
    _nrooperacion_detatracion character varying,
    _imp_detraccion numeric,
    _fec_pago text,
    _egreso_movilidad boolean
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res TEXT[];
	_id bigint;
BEGIN

IF op=1 then
	if exists(select 1 from ventas.tbl_direccion where id_persona=_id_proveedor  and id_direccion=_id_dirproveedor)then
		if not exists(select 1  from compras.tbl_compra 
			where nro_doc_compra=_nro_doc_compra and serie=_serie and id_proveedor=_id_proveedor and id_comprobante=_id_comprobante AND id_estado=1)then 
			select max(id__compra) into _id from COMPRAS.TBL_COMPRA;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO COMPRAS.TBL_COMPRA(
				  nro_doc_compra,
				  fec_documento,
				  id_dirproveedor,
				  id_comprobante,
				  id_tranzaccion,
				  id_igv,
				  anio,
				  id__compra,
				  id_mes,
				  fec_ingsistema,
				  imp_venta,
				  imp_dcsto,
				  porcent_dcsto,
				  imp_igv,
				  id_sucursalcompra,
				  id_estado,
				  id_proveedor,
				  serie,
				  id_tipocambio,
				  id_tipocompra,
				  doc_referencia,
				  imp_bruto,
				  imp_total,
				  imp_exonerado,
				  id_operacion,
				  genera_letra,
				  id_moneda,
				  imp_afecto,
				  id_responsable,
				  egreso,
				  glosa,
				  id_compra,
				  fec_vencimiento,
				  afecto_detraccion,
				  NroOperacion_detatracion,
				  imp_detraccion,
				  fec_pago,
				  egreso_movilidad
			)VALUES(
				  _nro_doc_compra,
				  to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
				  _id_dirproveedor,
				  _id_comprobante,
				  _id_tranzaccion,
				  _id_igv,
				  _anio,
				  _id,
				  _id_mes,
				  to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
				  _imp_venta,
				  _imp_dcsto,
				  _porcent_dcsto,
				  _imp_igv,
				  _id_sucursalcompra,
				  _id_estado,
				  _id_proveedor,
				  _serie,
				  _id_tipocambio,
				  _id_tipocompra,
				  _doc_referencia,
				  _imp_bruto,
				  _imp_total,
				  _imp_exonerado,
				  _id_operacion,
				  _genera_letra,
				  _id_moneda,
				  _imp_afecto,
				  _id_responsable,
				  _egreso,
				  _glosa,
				  _id,
				  _fec_vencimiento::Timestamp,
				  _afecto_detraccion,
				  _NroOperacion_detatracion,
				  _imp_detraccion,
				  _fec_pago::timestamp,
				  _egreso_movilidad
			)returning array['0', id_compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id__compra::text] into res;
			if not found then
				res:=array['504', 'Inconsitencia Inesperada al momento de registrar la compra'];
			end if;
		else
			res:=array['502','El nro de documento ya se encuentra registrado'];
		END IF;
	ELSE
		res:=array['501','verifique que el proveedor este ingresado correctamente'];
	END IF;
END IF;
  IF op=2 then
	if exists(select 1 from COMPRAS.TBL_COMPRA where id_sucursalcompra = _id_sucursalcompra  and id__compra = _id__compra) then
		UPDATE COMPRAS.TBL_COMPRA SET
		  nro_doc_compra  =   _nro_doc_compra,
		  fec_documento  =   to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_dirproveedor  =   _id_dirproveedor,
		  id_comprobante  =   _id_comprobante,
		  id_tranzaccion  =   _id_tranzaccion,
		  id_igv  =   _id_igv,
		  fec_ingsistema  =   to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
		  imp_venta  =   _imp_venta,
		  imp_dcsto  =   _imp_dcsto,
		  porcent_dcsto  =   _porcent_dcsto,
		  imp_igv  =   _imp_igv,
		  id_estado  =   _id_estado,
		  id_proveedor  =   _id_proveedor,
		  serie  =   _serie,
		  id_tipocambio  =   _id_tipocambio,
		  id_tipocompra  =   _id_tipocompra,
		  doc_referencia  =   _doc_referencia,
		  imp_bruto  =   _imp_bruto,
		  imp_total  =   _imp_total,
		  imp_exonerado  =   _imp_exonerado,
		  id_operacion  =   _id_operacion,
		  genera_letra  =   _genera_letra,
		  id_moneda  =   _id_moneda,
		  imp_afecto = _imp_afecto,
		  id_responsable=_id_responsable,
		  egreso=_egreso,
		  glosa=_glosa,
		  id_mes=_id_mes,
		  anio=_anio,
		  fec_vencimiento=_fec_vencimiento::timestamp,
		  afecto_detraccion=_afecto_detraccion,
		  NroOperacion_detatracion=_NroOperacion_detatracion,
		  imp_detraccion=_imp_detraccion,
		  fec_pago=_fec_pago::timestamp,
		  egreso_movilidad=_egreso_movilidad
		WHERE id_sucursalcompra = _id_sucursalcompra and id__compra = _id__compra;
		res:= array['0', _id_compra::text, _id_sucursalcompra::TEXT, _id_mes::TEXT, _anio::TEXT,_id__compra::text];
	else
		res:= array['504','Verifique que los datos de la compra esten ingresados correctamente'];
	end if;
   END IF;

  return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from ventas.v_zona

CREATE OR REPLACE FUNCTION compras.spiu_detcompras(
    op integer,
    _item integer,
    _cantidad numeric,
    _precio numeric,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_almacen integer,
    _id_sucursalcompra integer,
    _id_inventario integer,
    _anio integer,
    _id_compra integer,
    _imp_dscto numeric,
    _id_estado integer,
    _imp_igv numeric,
    _imp_incluido numeric,
    _imp_venta numeric,
    _imp_flete numeric,
    _imp_total numeric,
    _imp_costofinal numeric,
    _porcent_igv numeric,
    _porcent_dscto numeric,
    _peso numeric,
    _id_mes integer,
    _lote character varying,
    _id__compra bigint,
    _fecha_lote text,
    _observacion_lote text,
    _id_estado_lote integer,
    _id_usuario character,
    _cantidad_old numeric,
    _id_detcompra bigint,
    _modificar_costos boolean,
    _descripcion_linea text 
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res text[];
	__id bigint;
	__id__lote bigint;
	__res__lote text[];
	__res__detcompra text[];
	_imp_tipocambio numeric(20,4);
	_id_moneda integer;
	___imp_costo numeric(20,6);
	dat_pre record;
BEGIN
select tipo_cambio,id_moneda into _imp_tipocambio,_id_moneda from compras.tbl_compra where id__compra=_id__compra and id_sucursalcompra=_id_sucursalcompra; 
___imp_costo:=(case when _id_moneda=1 then _imp_costofinal else _imp_costofinal*_imp_tipocambio end); 
if(op = 1) then
	if(exists(select 1 from almacen.tbl_existencia where id_producto = _id_producto and id_unidadventa = _id_unidadventa and id_almacen = _id_almacen)) then
		select max(id__detcompra) into __id from compras.tbl_detcompra;
		if __id is null then
			__id:=1;
		else
			__id:=__id+1;
		end if;
		insert into compras.tbl_detcompra(
		  id__detcompra,
		  id__compra,
		  item,
		  cantidad,
		  precio ,
		  id_producto ,
		  id_unidadventa,
		  id_almacen ,
		  id_sucursalcompra ,
		  id_inventario ,
		  anio,
		  id_compra ,
		  imp_dscto ,
		  id_estado ,
		  imp_igv ,
		  imp_incluido ,
		  imp_venta ,
		  imp_flete ,
		  imp_total ,
		  imp_costofinal ,
		  porcent_igv ,
		  porcent_dscto,
		  peso ,
		  id_mes,
		  lote,
		  descripcion_linea
		  )values(
		  __id,
		  _id__compra,
		  _item,
		  _cantidad ,
		  _precio ,
		  _id_producto ,
		  _id_unidadventa,
		  _id_almacen ,
		  _id_sucursalcompra ,
		  _id_inventario ,
		  _anio ,
		  _id_compra ,
		  _imp_dscto ,
		  _id_estado ,
		  _imp_igv ,
		  _imp_incluido ,
		  _imp_venta ,
		  _imp_flete ,
		  _imp_total ,
		  _imp_costofinal ,
		  _porcent_igv ,
		  _porcent_dscto ,
		  _peso ,
		  _id_mes,
		  _lote,
		  _descripcion_linea
		  )returning array['0',item::text, id_almacen::text, id_producto::text, id_unidadventa::text, id_sucursalcompra::text, id__compra::text] into res;
		  if not found then
			res:= array['503','Inconsitencia Inesperada al momento de registrar el detalle de la compra'];
		  end if;
			RAISE NOTICE 'res : %',res[1];
		if res[1]='0' then
		-- select *from  compras.tbl_detcompra select *from almacen.tbl_precio
		       if _modificar_costos=true then
				--select tipo_cambio,id_moneda into _imp_tipocambio,_id_moneda from compras.tbl_compra where id__compra=_id__compra and id_sucursalcompra=_id_sucursalcompra; 
				
				--select  almacen.tbl_precio set coste= (case when _id_moneda=1 then _imp_costofinal else _imp_costofinal*_imp_tipocambio end)  where id_producto=_id_producto and id_unidadventa=_id_unidadventa;
				
				--select *from compras.fn_costocompra('2765',2,190.512);
				for dat_pre in select *from compras.fn_costocompra(_id_producto,_id_unidadventa,___imp_costo) loop
					if _imp_incluido>0 then
						update almacen.tbl_precio set coste= dat_pre.costo_unitario  where id_producto=dat_pre.id_producto and id_unidadventa=dat_pre.id_unidad;
					end if;
				end loop;

				--update almacen.tbl_precio set coste= (case when _id_moneda=1 then _imp_costofinal else _imp_costofinal*_imp_tipocambio end)  where id_producto=_id_producto and id_unidadventa=_id_unidadventa;
			end if;
			if exists(select 1 from almacen.tbl_producto where gestiona_lotes=true and id_producto=_id_producto) then
				if not exists(select 1 from almacen.tbl__lote 
						where nro__lote=_lote 
						and id__producto=_id_producto 
						and id__almacen=_id_almacen 
						and id__unidadventa=_id_unidadventa)then
						select max(id__lote) into __id__lote from almacen.tbl__lote where id__sucursal=_id_sucursalcompra;
						if __id__lote is null then
							__id__lote:=1;
						else
							__id__lote:=__id__lote+1;
						end if;
					INSERT INTO almacen.tbl__lote
					(
						id__lote, 
						id__sucursal, 
						id__almacen, 
						nro__lote, 
						stock, 
						stock__inicial, 
						costo__inicial, 
						valor__actual, 
						fecha__registro, 
						fecha__vencimiento, 
						id__producto, 
						id__unidadventa, 
						id__estado, 
						id__usuario__reg
					)
				    VALUES (
						__id__lote, 
						_id_sucursalcompra, 
						_id_almacen, 
						_lote, 
						_cantidad, 
						_cantidad, 
						_precio, 
						_imp_total, 
						now(), 
						 _fecha_lote::DATE ,
						_id_producto, 
						_id_unidadventa, 
						_id_estado_lote, 
						_id_usuario
						
				    )returning array['0','Registro procesado'] into res;

				    update compras.tbl_detcompra  set id__lote=__id__lote,id__sucursal__lote=_id_sucursalcompra where id__detcompra=__id; 
				else
					update almacen.tbl__lote set stock=stock+_cantidad 
						where nro__lote=_lote 
						and id__producto=_id_producto 
						and id__almacen=_id_almacen 
						and id__unidadventa=_id_unidadventa returning array['0',id__lote::text,id__sucursal::text] into res;
						update compras.tbl_detcompra  set id__lote=res[2]::bigint,id__sucursal__lote=res[3]::integer where id__detcompra=__id; 
						res:=array['0','Registro procesado'];
				end if;
			end if;			
		end if;
	  else
		res:= array['502','Producto no ha sido declarado en existencias [Inventario] IDs :: prod: ' || _id_producto || ' unidMed : ' || _id_unidadventa || ' almac: ' || _id_almacen || ' inventa: ' || _id_inventario];
	  end if;
end if;
if(op = 2) then
	if exists (select 1 from compras.tbl_detcompra where item = _item and id_almacen = _id_almacen and id_unidadventa = _id_unidadventa and
			id_producto = _id_producto  and id_sucursalcompra = _id_sucursalcompra  and 
			id__compra = _id__compra ) then

			update compras.tbl_detcompra set
				cantidad  =   _cantidad ,
				precio   =   _precio ,
				imp_dscto   =   _imp_dscto ,
				id_estado   =   _id_estado ,
				imp_igv   =   _imp_igv ,
				imp_incluido   =   _imp_incluido ,
				imp_venta   =   _imp_venta ,
				imp_flete   =   _imp_flete ,
				imp_total   =   _imp_total ,
				imp_costofinal   =   _imp_costofinal ,
				porcent_igv   =   _porcent_igv ,
				porcent_dscto  =   _porcent_dscto ,
				peso   =   _peso,
				lote	=  _lote,
				descripcion_linea=_descripcion_linea
			where item = _item and id_almacen = _id_almacen and id_unidadventa = _id_unidadventa and
			id_producto = _id_producto  and id_sucursalcompra = _id_sucursalcompra and 
			id__compra = _id__compra returning array['0',id__detcompra] into res;
			--res:= array['0', _id_sucursalcompra::text, _id_detcompra::text];
			if res[1]='0' then
				if _modificar_costos=true then
					
					
					for dat_pre in select *from compras.fn_costocompra(_id_producto,_id_unidadventa,___imp_costo) loop
						if _imp_incluido>0 then
							update almacen.tbl_precio set coste= dat_pre.costo_unitario  where id_producto=dat_pre.id_producto and id_unidadventa=dat_pre.id_unidad;
						end if;
					end loop;
					--update almacen.tbl_precio set coste=(case when _id_moneda=1 then _imp_costofinal else _imp_costofinal*_imp_tipocambio end)  where id_producto=_id_producto and id_unidadventa=_id_unidadventa;
				end if;
				if exists(select 1 from almacen.tbl_producto where gestiona_lotes=true and id_producto=_id_producto) then
					if not exists(select 1 from almacen.tbl__lote 
							where nro__lote=_lote 
							and id__producto=_id_producto 
							and id__almacen=_id_almacen 
							and id__unidadventa=_id_unidadventa)then
							select max(id__lote) into __id__lote from almacen.tbl__lote where id__sucursal=_id_sucursalcompra;
							if __id__lote is null then
								__id__lote:=1;
							else
								__id__lote:=__id__lote+1;
							end if;
						INSERT INTO almacen.tbl__lote
						(
							id__lote, 
							id__sucursal, 
							id__almacen, 
							nro__lote, 
							stock, 
							stock__inicial, 
							costo__inicial, 
							valor__actual, 
							fecha__registro, 
							fecha__vencimiento, 
							id__producto, 
							id__unidadventa, 
							id__estado, 
							id__usuario__reg
						)
					    VALUES (
							__id__lote, 
							_id_sucursalcompra, 
							_id_almacen, 
							_lote, 
							_cantidad, 
							_cantidad, 
							_precio, 
							_imp_total, 
							now(), 
							 to_char(_fecha_lote::timestamp,'dd/MM/yyyy')::timestamp ,
							_id_producto, 
							_id_unidadventa, 
							_id_estado_lote, 
							_id_usuario
							
					    )returning array['0','Registro procesado'] into __res__lote;

					    update compras.tbl_detcompra set id__lote=__id__lote,id__sucursal__lote=_id_sucursalcompra where id__detcompra=res[2]::BIGINT;
					    res:=array['0','Proceso efectuado con exito'];
					else
						
						update almacen.tbl__lote set stock=stock+_cantidad- _cantidad_old
							where nro__lote=_lote 
							and id__producto=_id_producto 
							and id__almacen=_id_almacen 
							and id__unidadventa=_id_unidadventa returning array['0',id__lote::text,id__sucursal::text] into __res__lote;
						update compras.tbl_detcompra set id__lote=__res__lote[2]::bigint,id__sucursal__lote=res[3]::integer where id__detcompra=_id_detcompra;
						res:=array['0','Registro procesado con exito'];
					end if;
				end if;			
			end if;
		else
			res:=array['504','Verifique que los datos del detalle de la compra esten ingresados correctamente **'|| _id__compra::text ||'- _item:'|| _item::text || ' - _id_almacen:'|| _id_almacen::text || ' -_id_unidadventa: '||_id_unidadventa::text || ' -_id_producto:'|| _id_producto || ' -_id_sucursalcompra:'|| _id_sucursalcompra::text];
		end if;
end if;
	RETURN res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

SELECT *FROM ALMACEN.TBL_PRECIO WHERE ID_PRODUCTO='2590'

CREATE OR REPLACE FUNCTION common.fn_documentos(
    IN _id_subdiario integer,
    IN _id_empresa integer)
  RETURNS TABLE(id integer, descripcion character varying, abreviatura character, id_estado integer) AS
$BODY$
SELECT ID_COMPROBANTE,descripcion_larga,descripcion_corta,id_estado 
FROM COMMON.TBL_COMPROBANTE 
	where id_comprobante not in (
		select 
			ax.id_comprobante 
		from contabilidad.tbl_axuliardocumento ax 
		where ax.subdiario_id=_id_subdiario  and id_empresa=_id_empresa
	);
$BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;


select * from contabilidad.list_documentosAuxiliar(2,1)

CREATE OR REPLACE FUNCTION contabilidad.list_documentosauxiliar(
    IN _id_subdiario integer,
    IN _id_empresa integer)
  RETURNS TABLE(
	id integer, 
	comprobante character varying, 
	subdiario varchar(100), 
	debe text,
	haber text, 
	nom_debe text, 
	nom_haber text,
	motivo varchar(200),
	id_estado integer,
	op integer,
	id_comprobante integer,
	id_cuentadebe bigint,
	id_cuentahaber bigint,
	id_motivo char(2),	
	subdiario_id integer
) AS
$BODY$
SELECT
	ax.id_auxiliardocumento,	
	tc.descripcion_larga as comprobante,
	sub.name as subdiario,
	debe.nro_cuenta as debe,
	haber.nro_cuenta as haber,
	debe.nombre_cuenta as nom_debe,
	haber.nombre_cuenta as nom_haber,
	mtvo.descripcion_larga as motivo,
	tc.id_estado ,
	2::integer op,
	tc.ID_COMPROBANTE,
	ax.id_cuentadebe,
	ax.id_cuentahaber,
	ax.id_motivo	,
	ax.subdiario_id
FROM COMMON.TBL_COMPROBANTE tc
inner join contabilidad.tbl_axuliardocumento ax on (ax.id_comprobante=tc.id_comprobante)
inner join contabilidad.tbl_subdiario sub on sub.id=ax.subdiario_id
inner join contabilidad.tbl_plancuenta debe on debe.id_plancuenta=ax.id_cuentadebe
inner join contabilidad.tbl_plancuenta haber on haber.id_plancuenta=ax.id_cuentahaber
inner join common.tbl_motivonotacredito mtvo on mtvo.id_motivonotacredito=ax.id_motivo
	where ax.subdiario_id=_id_subdiario  and ax.id_empresa=_id_empresa;
	
$BODY$
  LANGUAGE sql VOLATILE

 
  
select *from contabilidad.tbl_axuliardocumento 

CREATE OR REPLACE FUNCTION compras.isp_detegresos(
    op integer,
    __id_detegreso bigint,
    __item integer,
    __cantidad numeric,
    __precio numeric,
    __id_concepto character varying,
    __id_sucursalcompra integer,
    __anio integer,
    __id_compra bigint,
    __imp_dscto numeric,
    __id_estado integer,
    __imp_igv numeric,
    __imp_venta numeric,
    __imp_total numeric,
    __porcent_igv numeric,
    __porcent_dscto numeric,
    __id_mes integer,
    __id__compra bigint)
  RETURNS text[] AS
$BODY$
DECLARE
	correl_item integer;
	correl_id bigint;
	res text[];
BEGIN
if op=1 then
	IF EXISTS(SELECT *FROM COMPRAS.TBL_COMPRA WHERE id_sucursalcompra=__id_sucursalcompra AND anio=__anio  AND id_compra=__id_compra AND id_mes=__id_mes)THEN
		IF EXISTS(SELECT *FROM COMMON.TBL_CONCEPTO WHERE id::text=__ID_CONCEPTO)THEN
			select max(item) into correl_item from compras.tbl_detegreso 
				where id_sucursalcompra=__id_sucursalcompra AND anio=__anio  AND id_compra=__id_compra AND id_mes=__id_mes;
			if correl_item is null then
				correl_item:=1;
			else
				correl_item:=correl_item+1;
			end if;
		
			select max(id_detegreso) into correl_id from compras.tbl_detegreso;
			if correl_id is null then
				correl_id:=1;
			else
				correl_id:=correl_id+1;
			end if;

			INSERT INTO compras.tbl_detegreso(
				id_detegreso, 
				item, 
				cantidad, 
				precio, 
				id_concepto, 
				id_sucursalcompra, 
				anio, 
				id_compra, 
				imp_dscto, 
				id_estado, 
				imp_igv, 
				imp_venta, 
				imp_total, 
				porcent_igv, 
				porcent_dscto, 
				id_mes,
				id__compra
			)
			VALUES (
				correl_id, 
				correl_item, 
				__cantidad, 
				__precio, 
				__id_concepto, 
				__id_sucursalcompra, 
				__anio, 
				__id_compra, 
				__imp_dscto, 
				__id_estado, 
				__imp_igv, 
				__imp_venta, 
				__imp_total, 
				__porcent_igv, 
				__porcent_dscto, 
				__id_mes,
				__id__compra
			)returning array['0',id_detegreso::text] into res;
			if not found then
				res:=array['503','Inconsistencia inesperada al registra el detalle'];
			end if;
		else
			res:=array['502','Verefique que exista el concepto de la operación'];
		END IF;
	else
		res:=array['501','Verefique que exista la cabecera del documento'];
	END IF;
end if;
if op=2 then
	if exists(select *from compras.tbl_detegreso where id_detegreso=__id_detegreso)then
		UPDATE compras.tbl_detegreso
		   SET 			
			cantidad=__cantidad, 
			precio=__precio, 
			id_concepto=__id_concepto, 
			id_sucursalcompra=__id_sucursalcompra, 
			imp_dscto=__imp_dscto, 
			id_estado=__id_estado, 
			imp_igv=__imp_igv, 
			imp_venta=__imp_venta, 
			imp_total=__imp_total, 
			porcent_igv=__porcent_igv, 
			porcent_dscto=__porcent_dscto		
		 WHERE item=__item and id_detegreso=__id_detegreso and  id_sucursalcompra=__id_sucursalcompra  and id__compra=__id__compra;
		res:=array['0',__id_detegreso::text];
	else
		res:=array['503','Verefique que exista el registro del detalle'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  
CREATE OR REPLACE FUNCTION compras.isp_deterbohonorarios(
    op integer,
    __id_detegreso bigint,
    __item integer,
    __cantidad numeric,
    __precio numeric,
    __id_concepto character varying,
    __id_sucursalcompra integer,
    __anio integer,
    __id_compra integer,
    __imp_dscto numeric,
    __id_estado integer,
    __imp_igv numeric,
    __imp_venta numeric,
    __imp_total numeric,
    __porcent_igv numeric,
    __porcent_dscto numeric,
    __id_mes integer,
    __id__compra bigint
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl_item integer;
	correl_id bigint;
	res text[];
BEGIN
if op=1 then
	IF EXISTS(SELECT *FROM COMPRAS.TBL_COMPRA WHERE id_sucursalcompra=__id_sucursalcompra  AND id__compra=__id_compra )THEN
		IF EXISTS(SELECT *FROM COMMON.TBL_CONCEPTO WHERE id::text=__ID_CONCEPTO)THEN
			select max(item) into correl_item from compras.tbl_detegreso 
				where id_sucursalcompra=__id_sucursalcompra AND   id__compra=__id_compra;
			if correl_item is null then
				correl_item:=1;
			else
				correl_item:=correl_item+1;
			end if;
		
			select max(id_detegreso) into correl_id from compras.tbl_detegreso;
			if correl_id is null then
				correl_id:=1;
			else
				correl_id:=correl_id+1;
			end if;

			INSERT INTO compras.tbl_detegreso(
				id_detegreso, 
				item, 
				cantidad, 
				precio, 
				id_concepto, 
				id_sucursalcompra, 
				anio, 
				id__compra, 
				imp_dscto, 
				id_estado, 
				imp_igv, 
				imp_venta, 
				imp_total, 
				porcent_igv, 
				porcent_dscto, 
				id_mes--,
				--id__compra
			)
			VALUES (
				correl_id, 
				correl_item, 
				__cantidad, 
				__precio, 
				__id_concepto, 
				__id_sucursalcompra, 
				__anio, 
				__id_compra, 
				__imp_dscto, 
				__id_estado, 
				__imp_igv, 
				__imp_venta, 
				__imp_total, 
				__porcent_igv, 
				__porcent_dscto, 
				__id_mes--,
				--__id_compra
			)returning array['0',id_detegreso::text] into res;
			if not found then
				res:=array['503','Inconsistencia inesperada al registra el detalle'];
			end if;
		else
			res:=array['502','Verefique que exista el concepto de la operación'];
		END IF;
	else
		res:=array['501','Verefique que exista la cabecera del documento'];
	END IF;
end if;
if op=2 then
	if exists(select *from compras.tbl_detegreso where id_detegreso=__id_detegreso)then
		UPDATE compras.tbl_detegreso
		   SET 			
			cantidad=__cantidad, 
			precio=__precio, 
			id_concepto=__id_concepto, 
			id_sucursalcompra=__id_sucursalcompra, 
			imp_dscto=__imp_dscto, 
			id_estado=__id_estado, 
			imp_igv=__imp_igv, 
			imp_venta=__imp_venta, 
			imp_total=__imp_total, 
			porcent_igv=__porcent_igv, 
			porcent_dscto=__porcent_dscto		
		 WHERE id_detegreso=__id_detegreso and  id_sucursalcompra=__id_sucursalcompra and id__compra=__id_compra ;
		res:=array['0',__id_detegreso::text];
	else
		res:=array['503','Verefique que exista el registro del detalle'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


 
CREATE OR REPLACE FUNCTION contabilidad.job__ventas(
    __id__subdiario integer,
    __id__mes integer,
    __anio integer,
    __id__proceso integer,
    __id__empresa integer)
  RETURNS text[] AS
$BODY$
DECLARE 
	__cur__ventas  record;
        __rec__ventas record;
	__id__asiento_C integer;
	__res text[];
	__numero_asi integer;
	__rec__impuestos record;
	imp_debe numeric(20,2);
	imp_haber numeric(20,2);
	imp_formula varchar(50);
	idx integer;
	cadSql text;
	__i integer;
	__recdat__ventas record;
	__ind integer;
	__IndexConta integer;
	__imp_debemov numeric(20,4);
	__imp_habermov numeric(20,4);
BEGIN

CREATE TEMPORARY TABLE  tmp_ventas_val (
	id_comprobante integer,
	fecha timestamp,
	numero char(7),
	serie char(4),
	tipo_documento varchar(30),
	codigosunat text,
	cliente text,
	moneda varchar(30),
	tipocambio numeric(20,4),
	id_auxiliar integer,	
	id_facturacion integer,
	id_sucursal integer,
	id_operacion integer,
	imp_igv numeric(20,4),
	valor_venta numeric(20,4),
	importe numeric(20,4),
	actualizado char(1),
	contabilizado_cad varchar(50),
	concepto_das text,
	item integer,
	id_plancuenta integer,
	id_centrocostos integer,
	tipo_das char(1),
	id_estado integer,
	id_movasientos bigint,
	id_tablamov integer,
	id_igv integer,
	porcent_igv numeric(20,4),
	id_cuentadebe bigint,
	id_cuentahaber bigint,
	id_producto varchar(20),
        id_detfacturacion bigint,
        doc_persona varchar(12),
        id_persona varchar(15),
        id_mes integer,
        anio integer
	
)ON COMMIT DROP;

insert into tmp_ventas_val(
	id_comprobante ,
	fecha ,
	numero,
	serie ,
	tipo_documento,
	codigosunat ,
	cliente ,
	moneda ,
	tipocambio,
	id_auxiliar ,
	
	id_facturacion ,
	id_sucursal ,
	id_operacion,
	imp_igv ,
	valor_venta,
	importe ,
	actualizado ,
	contabilizado_cad,
	concepto_das,
	item ,
	id_plancuenta,
	id_centrocostos,
	tipo_das,
	id_estado,
	id_movasientos,
	id_tablamov,
	id_igv,
	porcent_igv,
	id_cuentadebe,
	id_cuentahaber,
	id_producto,
        id_detfacturacion,
        doc_persona,
        id_persona,
        id_mes,
        anio
)  select 
	cp.id_comprobante,
	f.fecha_venta as fecha,
	f.numdoc_facturacion as numero,
	f.serie_facturacion as serie,
	cp.descripcion_larga as tipo_documento,
	cp.codigosunat,
	CASE WHEN trim(f.id_cliente)='000' then trim(f.NOMAPE_CLIENTE) else  trim(cli.NOMBRE_RAZON)  end  as cliente,
	m.descripcion_larga as moneda,
	tc.venta as tipocambio,
	2::integer as id_auxiliar,
	
	df.id_facturacion,
	df.id_sucursal,
	f.id_operacion,
	df.imp_igv as imp_igv,--df.imp_igv,
	df.importe-df.imp_igv as valor_venta,--(df.importe-df.imp_igv) as valor_venta,
	df.importe,
	df.actualizado,
	df.contabilizado_cad,
	case when TRIM(df.id_producto)='TXT-01' then df.descripcion_linea else
		(split_part(p.descripcion_larga,',',1) || COALESCE((CASE WHEN Df.ANCHO>0 AND df.LARGO>0 
		THEN split_part(df.descripcion_linea,',',2) END),'') ) end || case when df.precio=0 then E'\nTRANSFERENCIA GRATUITA' else '' end as  concepto_das,
	df.item,
	0 as id_plancuenta,
	1 as id_centrocostos,
	''::char(1) tipo_das,
	case when f.id_estado=1 then df.id_estado else f.id_estado end,
	df.id_detfacturacion as id_movasientos,
	2 as id_tablamov,
	F.ID_IGV,
	ig.IMP_IGV as porcent_igv,
	conf.id_cuentadebe,
	conf.id_cuentahaber,
	df.id_producto,
	df.id_detfacturacion,	
	cli.doc_persona,
	cli.id_persona,
	date_part('month',f.fecha_venta) id_mes,
	date_part('year',f.fecha_venta) anio
  from 
  ventas.tbl_facturacion f
  INNER JOIN COMMON.TBL_IGV IG ON (IG.ID_IGV=F.ID_IGV)
  inner join common.tbl_comprobante cp on (cp.id_comprobante=f.id_comprobante)
  inner join contabilidad.tbl_axuliardocumento adx on (adx.id_comprobante=f.id_comprobante and adx.subdiario_id=__id__subdiario)
  INNER JOIN COMMON.TBL_SUCURSAL SC ON (SC.ID_SUCURSAL=F.ID_SUCURSAL)
  inner join common.tbl_moneda m on (m.id_moneda=f.id_moneda)
  inner join common.tbl_tipocambio tc on (tc.id_tipocambio=f.id_tipocambio)
  inner join planillas.tbl_persona cli on (cli.id_persona=f.id_cliente)
  inner join ventas.tbl_detfacturacion df on (df.id_facturacion=f.id_facturacion and f.id_sucursal=df.id_sucursal and df.id_estado=1)
  inner join contabilidad.tbl_configuracioncuenta conf on (conf.id_producto=df.id_producto and conf.subdiario_id=__id__subdiario)
  inner join contabilidad.tbl_plancuenta debe on (debe.id_plancuenta=conf.id_cuentadebe)
  inner join contabilidad.tbl_plancuenta haber on (haber.id_plancuenta=conf.id_cuentahaber)
  inner join almacen.tbl_producto p on (p.id_producto=df.id_producto)  
  where position('AV2' IN df.contabilizado_cad)=0  and  sc.id_empresa=__id__empresa and date_part('year',f.fecha_venta)=__anio ;--and date_part('month',f.fecha_venta::date)=1;--__id__empresa;


 
  __i:=0;
  if not exists(select * from contabilidad.tbl__asiento__contable where id_proceso=__id__proceso and date_part('month',fecha_asi)=__id__mes  and subdiario_id=__id__subdiario)then
		select max(COALESCE(numero_asi,0))+1 into __numero_asi from contabilidad.tbl__asiento__contable;
		if __numero_asi is null then
			__numero_asi:=1;
		else
			__numero_asi:=__numero_asi+1;
		end if;
		insert into contabilidad.tbl__asiento__contable(
			id_empresa,
			id_proceso,
			subdiario_id,
			fecha_asi,
			id_estado,
			mes_asi,
			glosa_asi,
			numero_asi
		)values(
			__id__empresa,
			__id__proceso,
			__id__subdiario,
			now(),
			  1,
			__id__mes,
			'DS_SISTEMAS',
			__numero_asi
		)returning id_asiento into __id__asiento_c;
	else
		__id__asiento_c:=(select id_asiento from contabilidad.tbl__asiento__contable where id_proceso=__id__proceso and mes_asi=__id__mes);
	end if;
	
for __rec__ventas  in select * from tmp_ventas_val loop
	--fetch __cur__ventas into __rec__ventas;
		--if found then
			for __rec__impuestos in select plancuentadebe_id as id_cuentadebe,plancuentahaber_id as id_cuentahaber from contabilidad.TBL_CONFIGIMPUESTO
											where subdiario_id=__id__subdiario and enterprise_id=__id__empresa 
				loop
					if COALESCE(__rec__impuestos.id_cuentadebe,0)<>0  and __rec__impuestos.id_cuentadebe<>0 then			
						INSERT INTO contabilidad.tbl__detalle__asiento__contable(
							fechadoc_das, 
							serie, 
							numero, 
							debe_das, 
							haber_das, 
							responsable, 
							id_plancuenta, 
							id_centrocostos, 
							id_comprobante, 
							id_asiento, 
							concepto_das, 
							debehaber, 
							tipo_das, 
							id_estado, 
							id_movasientos, 
							id_tablamov,
							id_sucursal,
							id_producto,
							doc__persona,
							id__persona,
							id_mes,
							anio
						)
						VALUES (
							__rec__ventas.fecha, 
							__rec__ventas.serie, 
							__rec__ventas.numero, 
							__rec__ventas.imp_igv, 
							0, 
							__rec__ventas.cliente, 
							__rec__impuestos.id_cuentadebe, 
							__rec__ventas.id_centrocostos, 
							__rec__ventas.id_comprobante, 
							__id__asiento_c, 
							__rec__ventas.concepto_das, 
							__rec__ventas.importe, 
							__rec__ventas.tipo_das, 
							__rec__ventas.id_estado, 
							__rec__ventas.id_movasientos, 
							__rec__ventas.id_tablamov,
							__rec__ventas.id_sucursal,
							__rec__ventas.id_producto,
							__rec__ventas.doc_persona,
							__rec__ventas.id_persona,
							__rec__ventas.id_mes,
							__rec__ventas.anio
						) returning array['0'] into __res;
						--print '--';					
							--imp_debe:= (select imp_formula);
						if not found then
							RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
						end if;
					end if;
					if COALESCE(__rec__impuestos.id_cuentahaber,0)<>0 and __rec__impuestos.id_cuentahaber<>0 then			
						INSERT INTO contabilidad.tbl__detalle__asiento__contable(
							fechadoc_das, 
							serie, 
							numero, 
							debe_das, 
							haber_das, 
							responsable, 
							id_plancuenta, 
							id_centrocostos, 
							id_comprobante, 
							id_asiento, 
							concepto_das, 
							debehaber, 
							tipo_das, 
							id_estado, 
							id_movasientos, 
							id_tablamov,
							id_sucursal,
							id_producto,
							doc__persona,
							id__persona,
							id_mes,
							anio
						)
						VALUES (
							__rec__ventas.fecha, 
							__rec__ventas.serie, 
							__rec__ventas.numero, 
							0, 
							__rec__ventas.imp_igv, 
							__rec__ventas.cliente, 
							__rec__impuestos.id_cuentahaber, 
							__rec__ventas.id_centrocostos, 
							__rec__ventas.id_comprobante, 
							__id__asiento_c, 
							__rec__ventas.concepto_das, 
							__rec__ventas.importe, 
							__rec__ventas.tipo_das, 
							__rec__ventas.id_estado, 
							__rec__ventas.id_movasientos, 
							__rec__ventas.id_tablamov,
							__rec__ventas.id_sucursal,
							__rec__ventas.id_producto,
							__rec__ventas.doc_persona,
							__rec__ventas.id_persona,
							__rec__ventas.id_mes,
							__rec__ventas.anio
						) returning array['0'] into __res;
						--print '--';
							
							--imp_debe:= (select imp_formula);
						if not found then
							RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
						end if;
					end if;	
				end loop;

			if COALESCE(__rec__ventas.id_cuentadebe,0)>0 and __rec__ventas.id_cuentadebe<>0 then			
				INSERT INTO contabilidad.tbl__detalle__asiento__contable(
					fechadoc_das, 
					serie, 
					numero, 
					debe_das, 
					haber_das, 
					responsable, 
					id_plancuenta, 
					id_centrocostos, 
					id_comprobante, 
					id_asiento, 
					concepto_das, 
					debehaber, 
					tipo_das, 
					id_estado, 
					id_movasientos, 
					id_tablamov,
					id_sucursal,
					id_producto,
					doc__persona,
					id__persona,
					id_mes,
					anio
					
				)
				VALUES (
					__rec__ventas.fecha, 
					__rec__ventas.serie, 
					__rec__ventas.numero, 
					__rec__ventas.importe, 
					0, 
					__rec__ventas.cliente, 
					__rec__ventas.id_cuentadebe, 
					__rec__ventas.id_centrocostos, 
					__rec__ventas.id_comprobante, 
					__id__asiento_c, 
					__rec__ventas.concepto_das, 
					__rec__ventas.importe, 
					__rec__ventas.tipo_das, 
					__rec__ventas.id_estado, 
					__rec__ventas.id_movasientos, 
					__rec__ventas.id_tablamov,
					__rec__ventas.id_sucursal,
					__rec__ventas.id_producto,
					__rec__ventas.doc_persona,
					__rec__ventas.id_persona,
					__rec__ventas.id_mes,
					__rec__ventas.anio
				) returning array['0'] into __res;

				if not found then
					RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
				end if;
			end if;
			if COALESCE(__rec__ventas.id_cuentahaber,0)>0 and __rec__ventas.id_cuentahaber<>0 then			
				INSERT INTO contabilidad.tbl__detalle__asiento__contable(
					fechadoc_das, 
					serie, 
					numero, 
					debe_das, 
					haber_das, 
					responsable, 
					id_plancuenta, 
					id_centrocostos, 
					id_comprobante, 
					id_asiento, 
					concepto_das, 
					debehaber, 
					tipo_das, 
					id_estado, 
					id_movasientos, 
					id_tablamov,
					id_sucursal,
					id_producto,
					doc__persona,
					id__persona,
					id_mes,
					anio
				)
				VALUES (
					__rec__ventas.fecha, 
					__rec__ventas.serie, 
					__rec__ventas.numero, 
					0, 
					__rec__ventas.valor_venta, 
					__rec__ventas.cliente, 
					__rec__ventas.id_cuentahaber, 
					__rec__ventas.id_centrocostos, 
					__rec__ventas.id_comprobante, 
					__id__asiento_c, 	
					__rec__ventas.concepto_das, 
					__rec__ventas.importe, 
					__rec__ventas.tipo_das, 
					__rec__ventas.id_estado, 
					__rec__ventas.id_movasientos, 
					__rec__ventas.id_tablamov,
					__rec__ventas.id_sucursal,
					__rec__ventas.id_producto,
					__rec__ventas.doc_persona,
					__rec__ventas.id_persona,
					__rec__ventas.id_mes,
					__rec__ventas.anio
				) returning array['0'] into __res;
				if not found then
					RAISE EXCEPTION 'Unable to create a new job: a job is currently running';
				end if;
				--print '--';
				
				--idx:=(select position('AV2' IN contabilizado_cad)  from ventas.tbl_detfacturacion where id_detfacturacion=__rec__ventas.id_detfacturacion);	
				
				---IF IDX=0 THEN
					--RAISE NOTICE  'Index %'  ,'Actualizando : ' || COALESCE(__rec__ventas.id_detfacturacion::text,'0');
					--update ventas.tbl_detfacturacion set contabilizado_cad=contabilizado_cad || ',' || 'AV2' where id_detfacturacion=__rec__ventas.id_detfacturacion and contabilizado_cad not ilike '%,AV2%' ;
				--END IF;
					--imp_debe:= (select imp_formula);
				__i:=__i+1;
				--RAISE NOTICE '__i%',__i;
			end if;		
		--else
		--	exit;
		--end if;
end loop;

select  SUM(COALESCE(d.debe_das,0)) into __imp_debemov from         
 contabilidad.tbl__asiento__contable c        
  inner join contabilidad.tbl__detalle__asiento__contable d on(c.id_asiento=d.id_asiento) where c.id_asiento=__id__asiento_c;     


select SUM(COALESCE(d.haber_das,0)) into __imp_habermov from         
 contabilidad.tbl__asiento__contable c        
  inner join contabilidad.tbl__detalle__asiento__contable d on(c.id_asiento=d.id_asiento) where  c.id_asiento=__id__asiento_c;     

        
  UPDATE contabilidad.tbl__asiento__contable  SET debe_asi=__imp_debemov,haber_asi=__imp_habermov WHERE id_asiento=__id__asiento_c;           

__IndexConta:=0;
__ind:=0;

for __recdat__ventas in   select * from tmp_ventas_val loop
	__ind:= (SELECT position('AV2' IN CONTABILIZADO_CAD ) FROM ventas.tbl_detfacturacion WHERE id_detfacturacion = __recdat__ventas.id_detfacturacion);
	--RAISE NOTICE '__ind%',__ind;
	if __ind =0 then
		UPDATE ventas.tbl_detfacturacion  SET CONTABILIZADO_CAD = COALESCE(CONTABILIZADO_CAD ,'')|| ',' || 'AV2' 
		WHERE id_detfacturacion = __recdat__ventas.id_detfacturacion;
		 
		/*UPDATE ventas.tbl_detfacturacion df SET df.CONTABILIZADO_CAD = COALESCE(CONTABILIZADO_CAD ,'')|| ',' || 'AV2' 
			FROM ventas.tbl_detfacturacion d 
			INNER JOIN ventas.tbl_facturacion egr on (egr.id_facturacion=d.id_facturacion and egr.id_sucursal=d.id_sucursal)
			Inner join tmp_ventas_val a  on a.id_detfacturacion = d.id_detfacturacion
			where YEAR(a.fecha)=YEAR(__recdat__ventas.fecha) and month(a.fecha)=month(__recdat__ventas.fecha) and DAY(a.fecha)=DAY(__recdat__ventas.fecha);*/
	end if;
	__IndexConta:=__IndexConta+1;
	--RAISE NOTICE '__IndexConta%',__IndexConta;
	--update ventas.tbl_detfacturacion set contabilizado_cad=contabilizado_cad || ',' || 'AV2' 
	--where id_facturacion=__rec__ventas.id_facturacion and item=__rec__ventas.item and id_sucursal=__rec__ventas.id_sucursal and id_producto=__rec__ventas.id_producto and contabilizado_cad not ilike '%,AV2%' ;
end loop;
--close __cur__ventas;
---DEALLOCATE  __cur__ventas;
__res:=array['0','Proceso efectuado con exito'];
return __res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

update ventas.tbl_detfacturacion set contabilizado_cad='';
delete from contabilidad.tbl__detalle__asiento__contable;
delete from contabilidad.tbl__asiento__contable;

select *from ventas.tbl_detfacturacion

select *from contabilidad.tbl_configuracioncuenta where tabla='PRODUCTO'

select CONTABILIDAD.FN_CONFIGURAR_PRODUCTOS_CUENTA();


CREATE    OR REPLACE FUNCTION CONTABILIDAD.FN_CONFIGURAR_PRODUCTOS_CUENTA()
RETURNS TEXT AS $$
DECLARE 
    dat record;
    _id bigint;
BEGIN
 for dat in select *from almacen.tbl_producto  where id_estado=1 loop
	select max(id_configuracicon) into _id from contabilidad.tbl_configuracioncuenta;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO contabilidad.tbl_configuracioncuenta
			(
				id_configuracicon, 
				id_cuentadebe, 
				id_cuentahaber, 
				id_producto, 
				subdiario_id, 
				id_empresa, 
				id_estado, 
				id_usuarior, 
				fecha_reg, 
				observaciones,
				concepto_id,
				tabla
			)
		        VALUES (
				_id, 
				56, 
				1494, 
				dat.id_producto , 
				1, 
				1, 
				1, 
				1, 
				now(), 
				'Automatico',
				NULL,
				'PRODUCTO'
		        );
 end loop;
 return 'ok';
END ;$$
LANGUAGE 'plpgsql';


select * from contabilidad.tbl__asiento__contable 
  /*
 __id__subdiario integer,
    __id__mes integer,
    __anio integer,
    __id__proceso integer,
    __id__empresa integer
  */

CREATE OR REPLACE FUNCTION contabilidad.isp_contabilzarauxiliares(
    op integer,
    __id__mes integer,
    __id__subdiario integer,
    __id__empresa integer,
    __id__sucursal integer,
    __anio integer,
    __id__proceso integer
    )
  RETURNS text[] AS
$BODY$
declare
res text[];

begin
if op=1 then
	case __id__subdiario
		--when 1 then res:=(select contabilidad.job__compras(,3,__anio,1,__id__empresa));
		when 1 then res:=(select contabilidad.job__ventas(1,__id__mes,__anio,__id__proceso,__id__empresa));
		when 4 then res:=(select contabilidad.job__compras(__id__subdiario,__id__mes,__anio,__id__proceso,__id__empresa));
		when 6 then res:=(select contabilidad.job__compras(__id__subdiario,__id__mes,__anio,__id__proceso,__id__empresa));
		when 7 then res:=(select contabilidad.job__compras(__id__subdiario,__id__mes,__anio,__id__proceso,__id__empresa));
		--when 3 then res:=(select *from contabilidad.job__cajaingreso(3,1,__anio,1,__id__empresa));
		--when 4 then res:=(select *from contabilidad.job__cajaegreso(4,1,__anio,1,__id__empresa));
		--when 5 then res:=(select *from contabilidad.job__bancoingreso(5,1,__anio,1,__id__empresa));
	end case;
	res:=array['0','oks'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select * from CONTABILIDAD.isp_contabilzarAuxiliares(1,1,5,1,1,2015,1)

select *from contabilidad.tbl_subdiario

select *from CREATE OR REPLACE FUNCTION contabilidad.job__compras(
    __id__subdiario integer,
    __id__mes integer,
    __anio integer,
    __id__proceso integer,
    __id__empresa integer)





CREATE OR REPLACE FUNCTION public.codigo_barras_generar_dv(
    p_codigo character varying,
    p_tipo character varying DEFAULT 'EAN13'::character varying)
  RETURNS text AS
$BODY$
	declare
    L_SUM          bigint;
    L_MULTIPLE     bigint;
    V_CODIGO_EAN13 VARCHAR(13) DEFAULT NULL;
BEGIN
    IF (P_TIPO = 'EAN13') THEN
        V_CODIGO_EAN13 := SUBSTR(LPAD(P_CODIGO,12,'0'),1,12);
        FOR I IN 1..12 LOOP
            IF (MOD(I,2) = 0) THEN
                L_MULTIPLE := 3;
            ELSE
                L_MULTIPLE := 1;
            END IF;

            L_SUM := COALESCE(L_SUM, 0) + SUBSTR(V_CODIGO_EAN13, I, 1)::bigint * L_MULTIPLE;
        END LOOP;

        RETURN V_CODIGO_EAN13||REPLACE((10 - MOD(L_SUM, 10))::text,'10','0');
    ELSE
        RETURN NULL;
    END IF;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



select public.codigo_barras_generar_dv_1('72538886','EAN13');

CREATE OR REPLACE FUNCTION public.codigo_barras_generar_dv_1(
    p_codigo character varying,
    p_tipo character varying DEFAULT 'EAN13'::character varying)
  RETURNS text AS
$BODY$
	declare
    L_SUM          bigint;
    L_MULTIPLE     bigint;
    V_CODIGO_EAN13 VARCHAR(13) DEFAULT NULL;
BEGIN
    IF (P_TIPO = 'EAN13') THEN
        V_CODIGO_EAN13 := SUBSTR(LPAD(P_CODIGO,4,'0'),1,4);
        FOR I IN 1..4 LOOP
            IF (MOD(I,2) = 0) THEN
                L_MULTIPLE := 3;
            ELSE
                L_MULTIPLE := 1;
            END IF;

            L_SUM := COALESCE(L_SUM, 0) + SUBSTR(V_CODIGO_EAN13, I, 1)::bigint * L_MULTIPLE;
        END LOOP;

        RETURN V_CODIGO_EAN13||REPLACE((2 - MOD(L_SUM, 2))::text,'2','0');
    ELSE
        RETURN NULL;
    END IF;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

create or replace function almacen.fn_generate_barrcode_products()
returns text[] as  $$
declare
	res text[];
	code text;
begin

  code:=codigo_barras_generar_dv((((((random() * ((('77777'::bigint - '11111'::bigint) + 1))::double precision) + ('1111'::bigint)::double precision))::bigint)::text)::character varying, 'EAN13'::character varying);
  res:=array['0',code::bigint::text];
  return res;
end;$$
language 'plpgsql';


select *from almacen.fn_generate_barrcode_products()



select * from ventas.v_editfacturacion  where (id_facturacion::text || id_sucursal::text)='81'


select *from VENTAS.SPI_DET_FACTURAR_GUIAS('''''41'''',''''31''''');
select id_guia,id_sucursal ,* from ventas.V_DETGUIAVENTA

select * from ventas.fn_DET_FACTURAR_GUIAS('''41'',''51''')



CREATE OR REPLACE FUNCTION contabilidad.isp_plancuentas(
    op integer,
    _id_plancuenta bigint,
    _id_plancuentapadre bigint,
    _nro_cuenta text,
    _id_tipocuenta integer,
    _id_clase integer,
    _id_centrocostos integer,
    _id_empresa integer,
    _nombre_cuenta text,
    _id_estado integer,
    _cuenta_presupuesto boolean,
    _cuenta_monetaria boolean,
    _confidencial boolean,
    _acm boolean,
    _nivel_cuenta integer,
    _id_tiposaldo integer,
    _tiene_destinos boolean)
  RETURNS text[] AS
$BODY$
DECLARE
 res text[];
 id bigint;
BEGIN
IF OP=1 THEN
	IF NOT EXISTS(SELECT *FROM contabilidad.tbl_plancuenta WHERE nro_cuenta=_nro_cuenta)THEN
	select max(id_plancuenta) into _id_plancuenta from  contabilidad.tbl_plancuenta;
	if _id_plancuenta is null then
		_id_plancuenta:=0;
	else
		_id_plancuenta:=_id_plancuenta+1;
	end if;
		INSERT INTO contabilidad.tbl_plancuenta(
			id_plancuenta, 
			id_plancuentapadre, 
			nro_cuenta, 
			id_tipocuenta, 
			id_clase, 
			id_centrocostos, 
			id_empresa, 
			nombre_cuenta, 
			id_estado, 
			cuenta_presupuesto, 
			cuenta_monetaria, 
			confidencial, 
			acm, 
			nivel_cuenta,
			id_tiposaldo,
			tiene_destinos
			)
		VALUES (
			_id_plancuenta, 
			_id_plancuentapadre, 
			_nro_cuenta, 
			_id_tipocuenta, 
			_id_clase, 
			_id_centrocostos, 
			_id_empresa, 
			_nombre_cuenta, 
			_id_estado, 
			_cuenta_presupuesto, 
			_cuenta_monetaria, 
			_confidencial, 
			_acm, 
			_nivel_cuenta,
			_id_tiposaldo,
			_tiene_destinos
		) RETURNING ARRAY['0',id_plancuenta::TEXT] INTO RES;
		IF NOT FOUND THEN 
			RES:=ARRAY['503','Inconsistencia inesperada al registrar la cuenta'];
		END IF;
	ELSE
		RES:=ARRAY['502','La cuenta ya esta registrada'];
	END IF;
END IF;
IF OP=2 THEN 
	IF EXISTS(SELECT *FROM CONTABILIDAD.TBL_PLANCUENTA WHERE id_plancuenta=_id_plancuenta) THEN 
		UPDATE contabilidad.tbl_plancuenta
		   SET id_plancuentapadre=_id_plancuentapadre, 
			nro_cuenta=_nro_cuenta, 
			id_tipocuenta=_id_tipocuenta, 
		        id_clase=_id_clase, 
		        id_centrocostos=_id_centrocostos, 
		        id_empresa=_id_empresa, 
		        nombre_cuenta=_nombre_cuenta, 
		        id_estado=_id_estado, 
		        cuenta_presupuesto=_cuenta_presupuesto, 
		        cuenta_monetaria=_cuenta_monetaria, 
		        confidencial=_confidencial, 
		        acm=_acm, 
		        nivel_cuenta=_nivel_cuenta,
		        id_tiposaldo=_id_tiposaldo,
		        tiene_destinos=_tiene_destinos
		WHERE id_plancuenta=_id_plancuenta returning ARRAY['0',id_plancuenta::text] into res;
		--RES:=ARRAY['0','Actualizacion efectuado con exito'];
	else
		res:=array['503','Verefique que haya editado correctamente el registro'];
	END IF;
END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from almacen.ISP_CABKIT(1,0,1,'4599',1,'1221',40,28,29,'0001','0001','0001','0000007','0000018','0000001','10'::numeric,'12.58'::numeric,1,'2019-11-20 20:46:19.596','1    ','ANTICIPO A CLIENTES',1,'1',1,1,1,'CANASTA NAVIDEÑA')

select* from almacen.tbl__kitproducto

CREATE OR REPLACE FUNCTION almacen.isp_cabkit(
    __op integer,
    __id__kit bigint,
    __id__sucursal integer,
    __id__producto character varying,
    __id__unidadventa integer,
    __id__concepto character varying,
    __id__comprobante__kit integer,
    __id__comprobante__ni integer,
    __id__comprobante__ns integer,
    __serie__kit character,
    __serie__ni character,
    __serie__ns character,
    __numero__ni character varying,
    __numero__ns character varying,
    __numero__kit character,
    __cantidad numeric,
    __costo numeric,
    __id__almacen integer,
    __fecha__reg text,
    __id__usuario character,
    __glosa text,
    __id__estado integer,
    __id__responsable character varying,
    __id__moneda integer,
    __id__tipo__cambio integer,
    __id__igv integer,
    __descripcion__linea text
)
  RETURNS text[] AS
$BODY$
DECLARE
	__id 			bigint;
	__res 			text[];
	__id__cliente 		varchar(15);
	__id__direccion 	bigint;
	__id__fkref 		TEXT;
	__id__kit__ 		text[];
	__id__nota__salida	bigint;
BEGIN
if __op=1 then
	if exists(select *from ALMACEN.TBL_DETPRODUCTO where id_producto=__id__producto and id_unidadventa=__id__unidadventa)then
		if exists(select 1 from COMMON.TBL_CONCEPTO where id=__id__concepto::integer)then
			select max(id__kit) into __id from almacen.tbl__kitproducto;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			INSERT INTO almacen.tbl__kitproducto(
				id__kit, 
				id__sucursal, 
				id__producto, 
				id__unidadventa, 
				id__concepto, 
				id__comprobante__kit, 
				id__comprobante__ni, 
				id__comprobante__ns, 
				serie__kit, 
				serie__ni, 
				serie__ns, 
				numero__ni, 
				numero__ns, 
				numero__kit, 
				cantidad, 
				costo, 
				id__almacen, 
				fecha__reg, 
				fecha__act, 
				id__usuario__reg, 
				id__usuario__act, 
				glosa, 
				id__estado
			)
			VALUES (
				__id, 
				__id__sucursal, 
				__id__producto, 
				__id__unidadventa, 
				__id__concepto, 
				__id__comprobante__kit, 
				__id__comprobante__ni, 
				__id__comprobante__ns, 
				__serie__kit, 
				__serie__ni, 
				__serie__ns, 
				__numero__ni, 
				__numero__ns, 
				__numero__kit, 
				__cantidad, 
				__costo, 
				__id__almacen, 
				to_timestamp(__fecha__reg,'YYYY-MM-DD HH24:MI:SS.MS'), 
				now(), 
				__id__usuario, 
				__id__usuario, 
				__glosa, 
				__id__estado
			)returning array['0',id__kit::text,id__sucursal::text] into __id__kit__;
			
			__id__fkref:=__id__kit__[2] || '-' || __id__kit__[3];
			
			if not found then
				__res:=array['504','Inconsistencia Inesperada al registrar la cabecera del KIT'];
			end if;
			RAISE NOTICE '%', __id__kit__[1] ;
			if __id__kit__[1]='0' then
				RAISE NOTICE '%', __id__kit__[1] ;
				SELECT id__cliente into __id__cliente  from common.tbl_sucursal where id_sucursal=__id__sucursal;
				SELECT id__direccion into __id__direccion from common.tbl_sucursal where id_sucursal=__id__sucursal;
				if exists(select *from ventas.tbl_direccion where id_direccion=__id__direccion and  id_persona=__id__cliente) then
					IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=__id__comprobante__ni AND 
					serie=__serie__ni AND numero=__numero__ni AND id_sucursal=__id__sucursal) then
						__ID:=(__id__comprobante__ni::text || __serie__ni || __numero__ni|| __id__sucursal::text)::BIGINT;

						RAISE NOTICE '%', __id__kit__[1] ;
						RAISE NOTICE '%', __id__kit__[2] ;
						RAISE NOTICE '%', __id__kit__[3] ;
						insert into almacen.tbl_cabmovalm(
							id_movimiento,
							serie,
							numero,
							id_comprobante       ,
							id_almdestino        ,
							id_tranzaccion       ,
							fecha                ,
							id_motivo            ,
							fec_llegada          ,
							imp_bruto            ,
							imp_dscto            ,
							porcent_dscto	     ,
							valor_venta          ,
							imp_igv              ,
							imp_neto             ,
							glosa                ,
							id_sucursal          ,
							id_dirclientprov     ,
							id_clientprov        ,
							id_igv               ,
							id_tipocambio        ,
							id_moneda            ,
							id_vendedor,
							schema,
							tabla,
							codigorefk,
							ingreso,
							ing_conversion,
							ing_kit
						)values(
							__ID,
							__serie__ni,
							__numero__ni,
							__id__comprobante__ni       ,
							__id__almacen        ,
							'38'       ,
							to_timestamp(__fecha__reg,'YYYY-MM-DD HH24:MI:SS.MS'),
							'0301',--_id_motivo            ,
							to_timestamp(__fecha__reg,'YYYY-MM-DD HH24:MI:SS.MS'),
							__costo*__cantidad,--_imp_bruto            ,
							0,--_imp_dscto            ,
							0,--_porcent_dscto	     ,
							__costo*__cantidad,--_valor_venta          ,
							0,--_imp_igv              ,
							__costo*__cantidad,--_imp_neto             ,
							'',--_glosa                ,
							__id__sucursal          ,
							__id__direccion     ,
							__id__cliente        ,
							__id__igv               ,
							__id__tipo__cambio        ,
							__id__moneda            ,
							__id__responsable,
							'almacen',--_schema,
							'tbl__kitproducto',--_tabla,
							__id__fkref,--_codigorefk,
							TRUE,--_ingreso
							FALSE,
							TRUE
						)returning array['0',id_movimiento::text] into __res;
						--registrando el del detalle del ingreso
						IF TRIM(__RES[1])='0' THEN
						
							if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=__RES[2]::bigint)then
								if exists(select *from almacen.tbl_detproducto where id_producto=__ID__PRODUCTO 
								and id_unidadventa=__id__unidadventa)then
									/*select max(item) into __id from almacen.tbl_detmovalm where id_movimiento=__RES[2]::bigint;
									if __id is null then
										__id:=1;
									else
										__id:=__id+1;
									end if;
									*/
									INSERT INTO almacen.tbl_detmovalm(
										id_movimiento, 
										cantidad, 
										precio, 
										total, 
										imp_dscto, 
										imp_igv, 
										porcent_igv, 
										porcent_dscto, 
										id_estado, 
										item, 
										observaciones, 
										lp, 
										peso, 
										descripcion_linea, 
										modotexto, 
										id_producto, 
										id_unidadkardex, 
										id_unidadingreso, 
										id_inventario, 
										id_almacen, 
										fec_actualiza, 
										fecha, 
										imp_valorventa, 
										imp_bruto, 
										id_usuario,
										ing_conversion
									)
									VALUES (
										__RES[2]::bigint, 
										__cantidad, 
										__costo,--_precio, 
										__costo*__cantidad,--_total, 
										0,--_imp_dscto, 
										0,--_imp_igv, 
										0,--_porcent_igv, 
										0,--_porcent_dscto, 
										1,--_id_estado, 
										1,--__item, 
										'',--_observaciones, 
										1,--_lp, 
										0,--_peso, 
										__descripcion__linea,--_descripcion_linea, 
										false, 
										__ID__PRODUCTO, 
										__id__unidadventa, 
										__id__unidadventa, 
										1,--_id_inventario, 
										__id__almacen, 
										NOW(), 
										NOW(), 
										__costo*__cantidad,--_imp_valorventa, 
										__costo*__cantidad,--_imp_bruto, 
										__id__usuario,--_id_usuario
										true-- ingreso por conversion
									) returning array['0',id_movimiento::text] into __res;
									update ALMACEN.TBL_EXISTENCIA 
											set 
											stock_fisico=stock_fisico+COALESCE(__cantidad,0)
										where 
										id_producto=__id__producto and id_unidadventa=__id__unidadventa and id_almacen=__id__almacen;
								ELSE
									__res:=array['503','Verefique que exista el producto con el codigo '|| __id__producto];
								end if;
							else
								RAISE NOTICE '%', 'no';
								__res:=array['502','Verefique exista la cabecera del documento'];
							end if;
						END IF;
					ELSE
						__RES:=ARRAY['502','El numero de nota de ingreso ya existe'];
					END IF;
				ELSE
					__res:=array['503','Verefique que exista el proveedor'];
				END IF;
				---REGISTRANDO LA SALIDA DE ALMACEN
				IF __RES[1]='0' THEN
					if exists(select *from ventas.tbl_direccion where id_direccion=__id__direccion and  id_persona=__id__cliente) then
						IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=__id__comprobante__ns 
						AND serie=__serie__ns AND numero=__numero__ns AND id_sucursal=__id__sucursal) then
							__ID:=(__id__comprobante__ns::text || __serie__ns || __numero__ns|| __id__sucursal::text)::BIGINT;
							insert into almacen.tbl_cabmovalm(
								id_movimiento,
								serie,
								numero,
								id_comprobante       ,
								id_almdestino        ,
								id_tranzaccion       ,
								fecha                ,
								id_motivo            ,
								fec_llegada          ,
								imp_bruto            ,
								imp_dscto            ,
								porcent_dscto	     ,
								valor_venta          ,
								imp_igv              ,
								imp_neto             ,
								glosa                ,
								id_sucursal          ,
								id_dirclientprov     ,
								id_clientprov        ,
								id_igv               ,
								id_tipocambio        ,
								id_moneda            ,
								id_vendedor,
								schema,
								tabla,
								codigorefk,
								salida,
								ingreso,
								ing_conversion,
								ing_kit
							)values(
								__ID,
								__serie__ns,
								__numero__ns,
								__id__comprobante__ns       ,
								__id__almacen        ,
								'39'       ,
								to_timestamp(__fecha__reg,'YYYY-MM-DD HH24:MI:SS.MS'),
								'0301',--_id_motivo            ,
								to_timestamp(__fecha__reg,'YYYY-MM-DD HH24:MI:SS.MS'),
								__costo*__cantidad,--_imp_bruto            ,
								0,--_imp_dscto            ,
								0,--_porcent_dscto	     ,
								__costo*__cantidad,--_valor_venta          ,
								0,--_imp_igv              ,
								__costo*__cantidad,--_imp_neto             ,
								'',--_glosa                ,
								__id__sucursal          ,
								__id__direccion     ,
								__id__cliente        ,
								__id__igv               ,
								__id__tipo__cambio        ,
								__id__moneda            ,
								__id__responsable,
								'almacen',--_schema,
								'tbl__kitproducto',--_tabla,
								__id__fkref,--_codigorefk,
								true,--salida
								false,
								false,
								true
							)returning id_movimiento into __id__nota__salida;
							
							__res:=array['0',__id__kit__[2],__id__kit__[3],__id__nota__salida::text];
						ELSE
							__RES:=ARRAY['502','El numero de nota de salida ya existe'];
						END IF;
					ELSE
						__res:=array['503','Verefique que exista el proveedor'];
					END IF;
				END IF;
			end if;
		else
			__res:=array['502','Seleccione correctamente el concepto'];
		end if;
	else
		__res:=array['502','Seleccione el producto correctamente'];
	end if;
	
end if;
if __op=2 then
	if exists(select 1 from almacen.tbl__kitproducto where id__kit=__id__kit and id__sucursal=__id__sucursal)then
		UPDATE almacen.tbl__kitproducto
		   SET 	
			id__producto=__id__producto, 
			id__unidadventa=__id__unidadventa, 
			id__concepto=__id__concepto, 
			id__comprobante__kit=__id__comprobante__kit, 
			id__comprobante__ni=__id__comprobante__ni, 
			id__comprobante__ns=__id__comprobante__ns, 
			serie__kit=__serie__kit, 
			serie__ni=__serie__ni, 
			serie__ns=__serie__ns, 
			numero__ni=__numero__ni, 
			numero__ns=__numero__ns, 
			numero__kit=__numero__kit, 
			cantidad=__cantidad, 
			costo=__costo, 
			id__almacen=__id__almacen, 
			fecha__act=now(), 
			id__usuario__act=__id__usuario,  
			glosa=__glosa, 
			id__estado=__id__estado
		 WHERE id__kit=__id__kit and id__sucursal=__id__sucursal;
		__res:=array['0',__id__kit::text,__id__sucursal::text];
	else
		__res:=array['503','Edite correctamente el registro'];
	end if;
end if;
return __res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION VENTAS.Fn_Actualizar_relacion_guia_factura(p_id_guia varchar(20),p_id_facturacion bigint ,p_id_sucursal integer)
returns text as  $$
declare
	res text[];
begin
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=p_id_facturacion and id_sucursal=p_id_sucursal) then
		update ventas.tbl_guiaremisionventa set id_facturacion=p_id_facturacion,id_sucursalfac=p_id_sucursal where id_guia::text || id_sucursal::text=p_id_guia;
		res:=array['0','Guia de remisión Actualizado'];
	else
		res:=array['504','No existe la factura de venta para relacionar con la guia de remisión'];
	end if;
return res;
end;$$
language 'plpgsql';


CREATE OR REPLACE FUNCTION VENTAS.fn_DET_FACTURAR_GUIAS(guias varchar(500))
RETURNS TABLE(
	_id_producto varchar(20),
	_id_almacen integer,
	_producto text,
	_stock numeric(20,4),
	_unidad varchar(20),
	_cantidad numeric(20,4),
	_lista integer,
	_precio numeric(20,4),
	_imp_dscto numeric(20,4),
	_tot_detalle numeric(20,4),
	_agregar text,
	_id_unidadventa integer,
	_id_listaprecio integer,
	_subtotal numeric(20,4),
	_porcent_igv numeric(20,4),
	_imp_bruto numeric(20,4),
	_cantidad_edidata numeric(20,4),
	_ctrl_stock boolean,
	_coste numeric(20,4),
	_id_estado  integer,
	_val_unidad  numeric(20,4),
	_val_minimo numeric(20,4),
	_imp_igv numeric(20,4),
	_op integer,
	_id_old text,
	_id_facturacion text,
	_id_sucursal integer,
	_idunimedcontrolventa integer,
	_val_controlventa numeric(20,4),
	_ancho numeric(20,4),
	_largo numeric(20,4),
	_codigo varchar(20),
	_sujet_perception boolean,
	_procen_perception numeric(20,4),
	_imp_percepcion numeric(20,4),
	_presinpercep numeric(20,4),
	_totsinpercep numeric(20,4),
	_gestionaseries boolean
	
) AS $$
DECLARE
	cad text;
BEGIN
RAISE NOTICE 'guias(%)', guias;

cad:='select 
id_producto,
id_almacen,
producto,
0::numeric(20,4) as stock,
unidad,
sum(cantidad)::numeric(20,4) as cantidad,
lp as lista, 
precio,
sum(dscto)::numeric(20,4) as imp_dscto,
sum(imp_total)::numeric(20,4) as tot_detalle,
''+'' as agregar,
id_unidadventa ,
id_listaprecio,
0::numeric(20,4) as subtotal,
0::numeric(20,4) as porncent_igv,
sum(imp_total)::numeric(20,4) as imp_bruto,
0::numeric(20,4) as cantidad_editada,
false ctrl_stock,
0::numeric(20,4) as coste,
id_estado,
val_unimedventa  as val_unidad,
1::numeric(20,4) as val_minimo,
0::numeric(20,4) as imp_igv,
1 as op,
'''' as id_old,
null as id_facturacion,
id_sucursal,
id_unidadventa as idunimedcontrolventa,
val_unimedventa as val_controlventa,
base as ancho,
haltura as largo,
id_producto as codigo,
false as sujet_perception,
0::numeric(20,4) as procent_percepcion,
0::numeric(20,4) as imp_percepcion ,
0::numeric(20,4) as presinpercep,
0::numeric(20,4) as totsinpercep,
false as gestionaseries
from ventas.V_DETGUIAVENTA where id_guia::text || id_sucursal::text  in('||guias||')
group by id_producto,
id_almacen,precio,
producto,unidad,id_unidadventa ,
id_listaprecio,id_estado,
val_unimedventa,id_sucursal,
 base,haltura,id_producto,lp '
;
return query EXECUTE  cad;
END;$$
LANGUAGE 'plpgsql';


select * from common.V_SERIESLIST  where id_empresa=1 and id_tranzaccion='20'  and id_estado =1 and documento in('BVT','FAC','TCK')

CREATE OR REPLACE FUNCTION creditos.spi_cuota(
    op integer,
    _id_cuotas integer,
    _id_credito integer,
    _id_sucursal_credito integer,
    _nro_letra character varying,
    _nro_cuota integer,
    _fec_vencimiento text,
    _imp_capital numeric,
    _imp_interes numeric,
    _imp_cuota numeric,
    _imp_adicional numeric,
    _imp_mora numeric,
    _intervalo_dias integer,
    _dias_gracia integer,
    _imp_total numeric,
    _fec_registro text,
    _genera_mora boolean,
    _id_estado integer)
  RETURNS text[] AS
$BODY$
DECLARE	
	res text[];
	correl integer;
BEGIN
if op=1 then
	if exists(select *from creditos.tbl_credito where id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
		select max(id_cuotas) into correl from CREDITOS.TBL_CUOTA;-- where id_credito=_id_credito and  id_sucursal_credito=_id_sucursal_credito;
		if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CREDITOS.TBL_CUOTA(
			id_cuotas ,
			id_credito,
			id_sucursal_credito,
			nro_letra  ,
			nro_cuota  ,
			fec_vencimiento,
			imp_capital ,
			imp_interes ,
			imp_cuota   ,
			imp_adicional,
			imp_mora     ,
			intervalo_dias,
			dias_gracia   ,
			imp_total     ,
			fec_registro  ,
			genera_mora   ,
			id_estado
		)
		values(
			correl ,
			_id_credito,
			_id_sucursal_credito,
			_nro_letra  ,
			_nro_cuota  ,
			to_timestamp(cast(_fec_vencimiento as date)::text,'YYYY-MM-DD HH24:MI:SS.MS'),
			_imp_capital ,
			_imp_interes ,
			_imp_cuota   ,
			_imp_adicional,
			_imp_mora     ,
			_intervalo_dias,
			_dias_gracia   ,
			_imp_total     ,
			now(),--to_timestamp(_fec_registro,'YYYY-MM-DD HH24:MI:SS.MS')  ,
			_genera_mora   ,
			_id_estado
		)returning array
			[
				'0',
				TBL_CUOTA.id_cuotas::text,
				TBL_CUOTA.id_credito::text,
				TBL_CUOTA.id_sucursal_credito::text,
				nro_cuota::TEXT
			] into res;
		if not found then
			res=array['504','Inconsistencia inesperada al reguistrar las cuotas de credito'];
		end if;
	else
		res:=array['503','Verefique que los datos del credito esten ingresados correctamente'];
	end if;
end if;
if  op=2 then
	if exists(select *from creditos.tbl_credito where id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
		if exists(select *from creditos.TBL_CUOTA where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
			update creditos.TBL_CUOTA set 
			nro_letra=_nro_letra  ,
			nro_cuota=_nro_cuota  ,
			fec_vencimiento=to_timestamp(cast(_fec_vencimiento as date)::text,'YYYY-MM-DD HH24:MI:SS.MS'),
			imp_capital =_imp_capital,
			imp_interes=_imp_interes ,
			imp_cuota=_imp_cuota   ,
			imp_adicional=_imp_adicional,
			imp_mora=_imp_mora     ,
			intervalo_dias=_intervalo_dias,
			dias_gracia=_dias_gracia   ,
			imp_total=_imp_total     ,
			--fec_registro=now()   ,
			genera_mora=_genera_mora   ,
			id_estado =_id_estado 
			where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito;
			res:=array['0',_id_cuotas::text,_id_credito::text,_id_sucursal_credito::text];
		else
			res:=array['503','Verefique que la cuota este seleccionado correctamente para realizar la actualización'];
		end if;
	else
		res:=array['503','Verefique que los datos del credito esten ingresados correctamente'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


create or replace function ventas.fn_calcula_comiciones(
	_id_vendedor varchar(15),
	_fec_desde text,
	_fec_hasta text 
)
returns  text as  $$
declare
	_data record;
	_imp_comicion numeric(20,4);
	_porcent_comicion numeric(20,4);
begin
for _data in SELECT sum(imp_neto)  as importe,id_tipoventa,id_vendedor FROM VENTAS.TBL_FACTURACION F
where f.id_estado=1  and f.id_vendedor=_id_vendedor and f.fecha_venta::date between _fec_desde::Date and _fec_hasta::Date
group by id_tipoventa,id_vendedor loop

select porcentaje into _porcent_comicion from VENTAS.TBL_COMISIONPORCENT where id_tipoventa=_data.id_tipoventa and _data.importe between imp_desde and imp_hasta  and id_estado=1;
if _porcent_comicion is null then
	_imp_comicion:=0;
else
	_imp_comicion:=(_porcent_comicion/100)*_data.importe;
end if;	
end loop;
return _imp_comicion;
end;$$
language 'plpgsql';

create or replace function ventas.isp_reporte_comiciones(_fec_desde text,_fec_hasta text)
returns table(
	dni varchar(11),
	colaborador varchar(500),
	imp_venta numeric(20,2),
	imp_comicion numeric(20,2)
) as $$
declare
begin
return query select 
	p.doc_persona::varchar(11) as dni, 
	nombre_razon::varchar(500) as vendedor,
	sum(f.imp_neto)::numeric(20,2) as imp_venta,
	ventas.fn_calcula_comiciones(f.id_vendedor,_fec_desde,_fec_hasta)::numeric(20,2) as imp_comicion 
from ventas.tbl_facturacion f
inner join planillas.tbl_persona p on f.id_vendedor=p.id_persona
where  f.fecha_venta::date between _fec_desde::Date and _fec_hasta::Date and f.id_estado=1
group by nombre_razon,p.doc_persona,f.id_vendedor;
end;$$
language 'plpgsql';

select *from ventas.isp_reporte_comiciones('01/08/2018','30/08/2018')

SELECT sum(imp_neto)  as importe,id_tipoventa,id_vendedor FROM VENTAS.TBL_FACTURACION F
where f.id_estado=1  -- and f.id_vendedor=_id_vendedor and f.fecha_venta::date between _fec_desde::Date and _fec_hasta::Date
group by id_tipoventa,id_vendedor


select *from planillas.tbl_persona limit 10
select *  from VENTAS.TBL_COMISIONPORCENT where id_tipoventa=1 and 16400 between imp_desde and imp_hasta  and id_estado=1;

select ventas.fn_calculo_comiciones('1','01/08/2018','15/08/2018')

CREATE OR REPLACE FUNCTION ventas.isp_comisionporcent(
    op integer,
    _id_tipocomision integer,
    _fecha_inicio text,
    _fecha_fin text,
    _id_empresa integer,
    _descripcion character varying,
    _porcentaje numeric,
    _id_tipoventa integer,
    _id_usuario character,
    _id_estado integer,
    _imp_desde numeric(20,4),
    _imp_hasta numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	id integer;
begin
if op=1 then
	if exists(select 1 from COMMON.TBL_TIPOVENTA  where id_tipoventa=_id_tipoventa ) then 
		select max(id_tipocomision) into id from  VENTAS.TBL_COMISIONPORCENT;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		
		INSERT INTO ventas.tbl_comisionporcent(
			id_tipocomision, 
			fecha_inicio, 
			fecha_fin, 
			id_empresa, 
			descripcion, 
			porcentaje, 
			id_tipoventa, 
			id_usuarior, 
			id_usuarioa, 
			fecha_reg,
			id_estado,
			imp_desde,
			imp_hasta
		)
		VALUES 
		(
			id, 
			_fecha_inicio::date, 
			_fecha_fin::date, 
			_id_empresa, 
			_descripcion, 
			_porcentaje, 
			_id_tipoventa, 
			_id_usuario, 
			_id_usuario, 
			now(),
			_id_estado,
			_imp_desde,
			_imp_hasta
		)returning array['0','Proceso efectuado con exito']into res;
		if not found then
			res:=array['504','Inconsistencia Inesperada'];
		end if;
	else
		res:=array['503'];
	end if;
end if;
if op=2 then
	if exists(select * from ventas.tbl_comisionporcent where id_tipocomision=_id_tipocomision)then
		UPDATE ventas.tbl_comisionporcent
		SET 
			fecha_inicio=_fecha_inicio::date,--to_timestamp(_fecha_inicio,'YYYY-MM-DD HH24:MI:SS.MS'), 
			fecha_fin=_fecha_fin::date, --to_timestamp(_fecha_fin,'YYYY-MM-DD HH24:MI:SS.MS'), 
			id_empresa=_id_empresa, 
			descripcion=_descripcion, 
			porcentaje=_porcentaje, 
			id_tipoventa=_id_tipoventa, 
			id_usuarior=_id_usuario,
			fecha_reg=now(),
			id_estado=_id_estado,
			imp_desde=_imp_desde,
			imp_hasta=_imp_hasta
		WHERE id_tipocomision=_id_tipocomision;
		res:=array['0','Proceso actualizado con exito'];
	else
		res:=array['503','Verfique que exista el registro '];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select * from ventas.tbl_comisionporcent

CREATE OR REPLACE FUNCTION caja.spi_movcajaingdiversos(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _id_concepto character varying,
    _signo integer,
    _id_personaingdiv character varying,
    _dni_cliente character,
    _nomape_cliente text,
      _liquidacion_id bigint,
    _fecha_liquidacion text
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from COMMON.TBL_CONCEPTO
		where id=_id_concepto::integer) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			id_concepto,
			signo,
			id_personaingdiv,
			DNI_CLIENTE ,
			NOMAPE_CLIENTE ,
			liquidacion_id ,
			fecha_liquidacion 
		)values(
			correl,
			case when _id_facturacion=0 then null else _id_facturacion end ,
			_id_caja_destino,
			_id_persona,
			case when _id_sucursal_fac =0 then null else _id_sucursal_fac end ,
			_serie,
			_numero,
			case when _fecha_mov is null then now() else  to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS')  end ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_id_concepto,
			_signo,
			_id_personaingdiv,
			_DNI_CLIENTE ,
			_NOMAPE_CLIENTE ,
			_liquidacion_id ,
			_fecha_liquidacion::date 
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','Verefique que este seleccionado el motivo del movimiento de caja'];
	end if;
end if;
if op=2 then
	if exists (select *from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
		delete from caja.tbl_detmovpago where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal;
		update CAJA.TBL_MOVCAJA set 
			id_caja_destino=_id_caja_destino,
			id_persona=_id_persona,
			id_sucursal_fac=_id_sucursal_fac,
			serie=_serie,
			numero=_numero,
			fecha_mov=to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			imp_movimiento=_imp_movimiento,
			imp_recibido =_imp_recibido  ,
			imp_vuelto  =_imp_vuelto    ,
			glosa      =_glosa         ,
			id_comprobante=_id_comprobante,
			id_moneda=_id_moneda     ,
			id_tipocambio=_id_tipocambio ,
			id_usuario=_id_usuario    ,
			doc_referencia=_doc_referencia,
			id_estado=_id_estado,
			id_tranzaccion=_id_tranzaccion,
			id_turno=_id_turno,
			id_concepto=_id_concepto,
			signo=_signo,
			id_personaingdiv=_id_personaingdiv ,
			DNI_CLIENTE=_DNI_CLIENTE ,
			NOMAPE_CLIENTE=_NOMAPE_CLIENTE ,
			liquidacion_id=_liquidacion_id ,
			fecha_liquidacion=_fecha_liquidacion::date 
			where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal;
			res:=array['0',_id_movimcaja::text,_id_sucursal::text,'Proceso efectuado con exito'];
	else
		res:=array['504','Verefique que el registro editado seleccionado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


--Actualizacion 18/05/2020
CREATE OR REPLACE FUNCTION ventas.isp_detpreventa_mobil(
    op integer,
    _id_cotizapreventa bigint,
    _id_sucursal integer,
    _cantidad numeric,
    _precio numeric,
    _imp_dscto numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _descripcion_linea text,
    _id_estado integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _lp integer,
    _item integer,
    _tipo character,
    _modotexto boolean,
    _observaciones text,
    _id_almacen integer,
    _id_unimedventa integer,
    _imp_percepcion numeric,
    _porcent_percepcion numeric,
    _precio_sinpercepcion numeric,
    _id_estado integer
)
  RETURNS text[] AS
$BODY$

DECLARE
	res text[];
	_correl_item integer;
	_cantidad_old numeric(20,4);
BEGIN
if op=1 then
	if exists(select *from  ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
		if exists(select *from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			select max(item) into _correl_item from ventas.tbl_detpreventacotiza where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal;
			if _correl_item is null then
				_correl_item=1;
			else
				_correl_item:=_correl_item+1;
			end if;
			INSERT INTO ventas.tbl_detpreventacotiza(
				id_cotizapreventa, 
				id_sucursal, 
				cantidad, 
				precio, 
				imp_dscto, 
				imp_igv, 
				imp_total, 
				descripcion_linea, 
				id_estado, 
				id_producto, 
				id_unidadventa, 
				id_listaprecio, 
				lp, 
				item, 
				tipo, 
				modotexto, 
				observaciones,
				id_almacen,
				id_unimedventa,
				imp_percepcion,
				porcent_percepcion,
				precio_sinpercepcion,
				id_estado
			)
			VALUES (
				_id_cotizapreventa, 
				_id_sucursal, 
				_cantidad, 
				_precio, 
				_imp_dscto, 
				_imp_igv, 
				_imp_total, 
				_descripcion_linea, 
				_id_estado, 
				_id_producto, 
				_id_unidadventa, 
				_id_listaprecio, 
				_lp, 
				_correl_item, 
				_tipo, 
				_modotexto, 
				_observaciones,
				case when _id_almacen=0 then 1 else _id_almacen end,
				_id_unimedventa,
				_imp_percepcion,
				_porcent_percepcion,
				_precio_sinpercepcion,
				1
			) returning array['0',id_cotizapreventa::text, id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el detalle de la cotizacion'];
			end if;
		else
			res:=array['503','Verefique que este seleccionado correctamente el producto : idprdod'|| _id_producto || '  _id_unidadventa :' || _id_unidadventa ];
		end if;
	else
		res:=array['504','Ingrese correctamente los datos de la cabecera de la cotizacion'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_detpreventacotiza 
		where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio and item=_item) then
			select  cantidad into _cantidad_old from ventas.tbl_detpreventacotiza  where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		UPDATE ventas.tbl_detpreventacotiza
		   SET  cantidad=_cantidad, 
			precio=_precio, 
			imp_dscto=_imp_dscto, 
		        imp_igv=_imp_igv, 
		        imp_total=_imp_total, 
		        descripcion_linea=_descripcion_linea, 
		        id_estado=_id_estado, 
		        lp=_lp,
		        tipo=_tipo, 
		        modotexto=_modotexto, 
		        observaciones=_observaciones,
		        id_almacen=_id_almacen,
		        id_unimedventa=_id_unimedventa,
		        imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			precio_sinpercepcion=_precio_sinpercepcion,
			cantidad_old=_cantidad_old,
			printed=case when _cantidad-COALESCE(_cantidad_old,0)=0 then true else false end,
			id_estado=_id_estado
		 WHERE id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		res:=array['0','Proceso efectuado con exito'];
		
	else
		res:=array['504','Verefique que exista el producto :' || _descripcion_linea::text];
	end if;
end if;
return res;
END;

$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

/*

CREATE OR REPLACE  FUNCTION ventas.isp_detpreventa_mobil(
    op integer,--1
    _id_cotizapreventa bigint,--2
    _id_sucursal integer,--3
    _cantidad numeric,--4
    _precio numeric,--5
    _imp_dscto numeric,--6
    _imp_igv numeric,--7
    _imp_total numeric,--8
    _descripcion_linea text,--9
    _id_estado integer,--10
    _id_producto character varying,--11
    _id_unidadventa integer,--12
    _id_listaprecio integer,--13
    _lp integer,--14
    _item integer,--15
    _tipo character,--16
    _modotexto boolean,--17
    _observaciones text,--18
    _id_almacen integer,--19
    _id_unimedventa integer,--20
    _imp_percepcion numeric,--21
    _porcent_percepcion numeric,--22
    _precio_sinpercepcion numeric--23
 
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_correl_item integer;
BEGIN
if op=1 then
	if exists(select *from  ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
		if exists(select *from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			select max(item) into _correl_item from ventas.tbl_detpreventacotiza where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal;
			if _correl_item is null then
				_correl_item=1;
			else
				_correl_item:=_correl_item+1;
			end if;
			INSERT INTO ventas.tbl_detpreventacotiza(
				id_cotizapreventa, 
				id_sucursal, 
				cantidad, 
				precio, 
				imp_dscto, 
				imp_igv, 
				imp_total, 
				descripcion_linea, 
				id_estado, 
				id_producto, 
				id_unidadventa, 
				id_listaprecio, 
				lp, 
				item, 
				tipo, 
				modotexto, 
				observaciones,
				id_almacen,
				id_unimedventa,
				imp_percepcion,
				porcent_percepcion,
				precio_sinpercepcion
			)
			VALUES (
				_id_cotizapreventa, 
				_id_sucursal, 
				_cantidad, 
				_precio, 
				_imp_dscto, 
				_imp_igv, 
				_imp_total, 
				_descripcion_linea, 
				_id_estado, 
				_id_producto, 
				_id_unidadventa, 
				_id_listaprecio, 
				_lp, 
				_correl_item, 
				_tipo, 
				_modotexto, 
				_observaciones,
				case when _id_almacen=0 then 1 else _id_almacen end,
				_id_unimedventa,
				_imp_percepcion,
				_porcent_percepcion,
				_precio_sinpercepcion
			) returning array['0',id_cotizapreventa::text, id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el detalle de la cotizacion'];
			end if;
		else
			res:=array['503','Verefique que este seleccionado correctamente el producto : idprdod'|| _id_producto || '  _id_unidadventa :' || _id_unidadventa ];
		end if;
	else
		res:=array['504','Ingrese correctamente los datos de la cabecera de la cotizacion'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_detpreventacotiza 
		where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio and item=_item) then
		UPDATE ventas.tbl_detpreventacotiza
		   SET  cantidad=_cantidad, 
			precio=_precio, 
			imp_dscto=_imp_dscto, 
		        imp_igv=_imp_igv, 
		        imp_total=_imp_total, 
		        descripcion_linea=_descripcion_linea, 
		        id_estado=_id_estado, 
		        lp=_lp,
		        tipo=_tipo, 
		        modotexto=_modotexto, 
		        observaciones=_observaciones,
		        id_almacen=_id_almacen,
		        id_unimedventa=_id_unimedventa,
		        imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			precio_sinpercepcion=_precio_sinpercepcion
		 WHERE id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		res:=array['0','Proceso efectuado con exito'];
		
	else
		res:=array['504','Verefique que exista el producto :' || _descripcion_linea::text];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

*/
SELECT *FROM ventas.tbl_cotizacionpreventa



CREATE OR REPLACE FUNCTION restaurant.usp_comandamesa(
    op integer,
    _id_mesacomanda bigint,
    _id_cotizapreventa bigint,
    _id_mesa integer,
    _fecha text,
    _ocupado boolean,
    _id_estado integer,
    _id_mesero character varying
 )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	id bigint;
BEGIN
if op=1 then
	if exists(select 1 from  ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa)then
		select max(id_mesacomanda) into id from restaurant.tbl_comandamesa;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		if exists(select 1 from restaurant.tbl_mesa where id_mesa=_id_mesa)then	
			INSERT INTO restaurant.tbl_comandamesa(
			    id_mesacomanda, 
			    id_cotizapreventa, 
			    id_mesa, 
			    fecha, 
			    ocupado, 
			    id_estado, 
			    id_mesero
			    )
			VALUES (   
			    id, 
			    _id_cotizapreventa, 
			    _id_mesa, 
			    _fecha::timestamp, 
			    true, 
			    _id_estado, 
			    _id_mesero
			)RETURNING ARRAY['0','Proceso efectuado con exito',tbl_comandamesa.id_mesacomanda::TEXT] into res;
			if not found then
				res:=array['504','Inconsistencia Inesperada '];
			end if;
		else
			res:=array['504','Verefique que la mesa este seleccionado correctamente'];
		end if;
	else
		res:=array['504','Verefique esten ingresado correctamente los datos de la camanda'];
	end if;
end if;
if op=2 then
	res:=ARRAY['0','Proceso efectuado con exito'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from ventas.tbl_cotizacionpreventa

 
CREATE OR REPLACE FUNCTION ventas.isp_add_commanda_mobil(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono character varying,
    _id_mesa integer)
  RETURNS text AS
$BODY$

DECLARE
	res text;
	correl integer;
	--serie char(4);
	--_numero varchar(7);
	correlativo integer;
	cad text[];
	__ID BIGINT;
	_User_id varchar(5);
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		--select *from common.v_configseries
		--select *from seguridad.tbl_usuariodocumento
		select ud.serie into _serie from seguridad.tbl_usuario us
		inner join seguridad.tbl_usuariodocumento ud on us.id_usuario=ud.id_usuario
		where ud.id_sucursal=_id_sucursal and us.id_persona=_ID_VENDEDOR and ud.id_comprobante=_id_comprobante and ud.predeterminado=true and ud.id_estado=1;

		--select us.id_usuario into _User_id from seguridad.tbl_usuario us where  us.id_persona=_ID_VENDEDOR ;

		select numero into correlativo from common.V_CONFIGSERIES  where id_tranzaccion='20' and id_comprobante ='16' and serie=_serie and id_estado =1 and id_empresa=1  and id_sucursal=1;
		if correlativo is null then
			correlativo:=1;
		else
			correlativo=correlativo+1;
		end if;
		
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    lpad(correlativo::text,7,'0'), 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono
			    			    
		) RETURNING id_cotizapreventa INTO __ID;

		cad:=(select * from restaurant.usp_comandamesa(
		    op ,
		    0,
		    __ID ,
		    _id_mesa ,
		    now()::text,
		    true,
		    1,
		    _ID_VENDEDOR
		 ));

		--res:=to_json(message('success','Commanda registrado->' || _ID_VENDEDOR,__ID::TEXT,''))::text;  
		res:=(select to_json(t) from(select 'success' as status,'Pedido generado' as message,_serie || '-' || lpad(correlativo::text,7,'0') as number,__ID::text as code,'' as sql,_imp_total::text as amount ) t);
		IF NOT FOUND THEN
			RES:=to_json(message('error','Inconsistencia inesperada verfique que los datos esten ingresados correctamente','504',''))::text;  
			--RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		RES:=to_json(message('error','Seleccione un cliente para realizar este proceso','503',''))::text;  
		--RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    --serie=_serie, 
				    --numero=_numero, 
				   -- id_comprobante=_id_comprobante, 				     
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    --valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				--RES:=to_json(message('success','Registro actualizado',_id_cotizapreventa::text,''))::text;  
				res:=(select to_json(t) from(select 'success' as status,'Pedido generado' as message,_serie || '-' || lpad(_numero::text,7,'0') as number,_id_cotizapreventa::text as code,'' as sql,_imp_total::text as amount ) t);
				--res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		--RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
		RES:=to_json(message('error','Verifique que el registro este seleccionado correctamente el registro ','504',''))::text;  
	END IF;
END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION ventas.isp__unidad__transporte(
    _op integer,
    _id_unidadtransporte integer,
    _id_sucursal integer,
    _placa character varying,
    _capacidad numeric,
    _modelo character varying,
    _marca character varying,
    _id_estado integer,
    _color character varying,
    _ruc text,
    _razon_social text,
    _direccion text)
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
	CORREL INTEGER;
BEGIN
IF _OP=1 THEN
	IF NOT EXISTS(SELECT 1 FROM VENTAS.TBL_UNIDADTRANSPORTE WHERE PLACA=_PLACA) THEN
		SELECT MAX(ID_UNIDADTRANSPORTE) INTO CORREL FROM VENTAS.TBL_UNIDADTRANSPORTE;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		INSERT INTO ventas.tbl_unidadtransporte(
			    id_unidadtransporte, 
			    id_sucursal, 
			    placa, 
			    capacidad, 
			    modelo, 
			    marca, 
			    id_estado,
			    COLOR,
			    ruc,
			    razon_social,
			    direccion
			    )
		    VALUES (
			    correl, 
			    _id_sucursal, 
			    _placa, 
			    _capacidad, 
			    _modelo, 
			    _marca, 
			    _id_estado,
			    _COLOR,
			    _ruc,
			    _razon_social,
			    _direccion
		    ) returning array['0',id_unidadtransporte::text] into res;
		    if not found then
			res:=array['503','Inconsitencia inesperada la registrar'];
		    end if;
	ELSE
		RES:=ARRAY['504','Ya existe un registro con el numero de placa ingresado'];
	END IF;
END IF;
IF _OP=2 THEN
	if exists(select *from ventas.tbl_unidadtransporte where id_unidadtransporte=_id_unidadtransporte)then
		UPDATE ventas.tbl_unidadtransporte
		   SET 
			id_sucursal=_id_sucursal, 
			placa=_placa, 
			capacidad=_capacidad, 
			modelo=_modelo, 
		       marca=_marca, 
		       id_estado=_id_estado,
		       COLOR=_COLOR,
		       ruc=_ruc,
		       razon_social=_razon_social,
		       direccion=_direccion
		 WHERE id_unidadtransporte=_id_unidadtransporte;
		 res:=array['0',_ID_UNIDADTRANSPORTE::text];
	else
		res:=array['503','Seleccione correctamente el registro'];
	end if;
END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 
CREATE OR REPLACE FUNCTION almacen.spi_guia_ventas(
    op integer,
    _id_guia character varying,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _fecha text,
    _doc_referencia character varying,
    _id_motivo integer,
    _direc_partidad text,
    _direc_llegada text,
    _fec_initraslado text,
    _imp_bruto numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _glosa text,
    _id_sucursal integer,
    _imp_subtotal numeric,
    _id_direccioncli integer,
    _id_cliente character varying,
    _id_transportista character varying,
    _id_igv integer,
    _id_tipocambio integer,
    _id_tipoventa integer,
    _id_moneda integer,
    _imp_dscto numeric,
    _id_comprasventa text,
    _id_vendedor character varying,
    _placatransporte character varying,
    _nrocostinscrip character varying,
    _id_operacion integer,
    _id_facturacion integer,
    _id_sucursalfac integer,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _id_modalidad integer,
    _id_almacenorigen integer,
    _id_almacendestino integer,
    _ingreso boolean,
    _salida boolean,
    _responsable_recogo text,
    _id_cotizapreventa bigint
    )
  RETURNS text[] AS
$BODY$
  DECLARE 
	res text[];
	correl integer;
  BEGIN
if op=1 then
	if exists(select 1from VENTAS.TBL_DIRECCION  where id_direccion=_id_direccioncli and  id_persona=_id_cliente)then
		if exists( select *from COMMON.tbl_motivotraslado where ID_MOTIVO=_id_motivo)then
			select max(id_guia) into correl from VENTAS.TBL_GUIAREMISIONVENTA where id_sucursal=_id_sucursal;
			if correl is null then
				correl:=1;
			else
				correl=correl+1;
			end if;
			insert into VENTAS.TBL_GUIAREMISIONVENTA(
				id_guia,
				serie,
				numero,
				id_comprobante,
				--id_almorigen,
				id_tranzaccion,
				fecha,
				--hora ,
				documento_referencia,
				id_motivo ,
				direc_partida,
				direc_llegada ,
				fec_initraslado,
				imp_bruto,
				imp_igv,
				imp_total,
				glosa  ,
				id_sucursal,
				imp_subtotal,
				id_direccioncli,
				id_cliente,
				id_transportista,
				id_igv,
				id_tipocambio,
				id_tipoventa,
				id_moneda ,
				imp_dscto ,
				--id_comprasventa,
				id_vendedor ,
				placa_transporte,
				nro_constinscripcion,
				id_operacion,
				id_facturacion,
				id_sucursalfac,
				DNI_CLIENTE,
				NOMAPE_CLIENTE,
				DIRECCION_CLIENTE,
			--	concepto_id,
				id_modalidad,
				id_almacenorigen ,
				id_almacendestino ,
				ingreso ,
				salida ,
				responsable_recogo,
				id_cotizapreventa

			)values(
				correl,
				_serie,
				_numero,
				_id_comprobante,
				--_id_almorigen,
				_id_tranzaccion,
				to_timestamp(_fecha,'YYYY-MM-DD') ,
				--to_timestamp(_hora,'HH24:MI:SS.MS') ,
				_doc_referencia,
				_id_motivo::text ,
				_direc_partidad,
				_direc_llegada ,
				to_timestamp(_fec_initraslado,'YYYY-MM-DD HH24:MI:SS.MS') ,
				_imp_bruto,
				_imp_igv,
				_imp_total,
				_glosa  ,
				_id_sucursal,
				_imp_subtotal,
				_id_direccioncli,
				_id_cliente,
				_id_transportista,
				_id_igv,
				_id_tipocambio,
				_id_tipoventa,
				_id_moneda ,
				_imp_dscto ,
				--_id_comprasventa,
				_id_vendedor ,
				_placatransporte,
				_nrocostinscrip,
				_id_operacion,
				case when _id_facturacion=0 then null else _id_facturacion end,
				case when _id_sucursalfac=0 then null else _id_sucursalfac end,
				_DNI_CLIENTE,
				_NOMAPE_CLIENTE,
				_DIRECCION_CLIENTE,
				--_id_motivo,
				_id_modalidad,
				_id_almacenorigen ,
				_id_almacendestino ,
				_ingreso ,
				_salida,
				_responsable_recogo,
				case when _id_cotizapreventa=0 then null else _id_cotizapreventa end 

			) returning array['0',id_guia::text,id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar la guia de remision '];
			end if;
		else
			res:=array['503','Verifique que el motivo de la guia de remision este seleccionado correctamente '];
		end if;
	else
		res:=array['502','Verifique que los datos del distinatario esten ingresados correctamente'];
	end if;	
end if;
if op=2 then
	if exists(select 1from VENTAS.TBL_DIRECCION  where id_direccion=_id_direccioncli and  id_persona=_id_cliente)then
		if exists( select  1 from COMMON.tbl_motivotraslado where id_motivo=_id_motivo::integer)then
			if exists(select  1 from ventas.TBL_GUIAREMISIONVENTA where id_guia=_id_guia::integer and  id_sucursal=_id_sucursal) then
				update ventas.TBL_GUIAREMISIONVENTA set 
				serie=_serie,
				numero=_numero,
				id_comprobante=_id_comprobante,
				--id_almorigen=_id_almorigen,
				id_tranzaccion=_id_tranzaccion,
				fecha=to_timestamp(_fecha,'YYYY-MM-DD'),
				--hora=to_timestamp(_hora,'HH24:MI:SS.MS') ,
				documento_referencia=_doc_referencia,
				--concepto_id=_id_motivo::INTEGER ,
				direc_partida=_direc_partidad,
				direc_llegada =_direc_llegada ,
				fec_initraslado=to_timestamp(_fec_initraslado,'YYYY-MM-DD HH24:MI:SS.MS'),
				imp_bruto=_imp_bruto,
				imp_igv=_imp_igv,
				imp_total=_imp_total,
				glosa=_glosa  ,
				imp_subtotal=_imp_subtotal,
				id_direccioncli=_id_direccioncli,
				id_cliente=_id_cliente,
				id_transportista=_id_transportista,
				id_igv=_id_igv,
				id_tipocambio=_id_tipocambio,
				id_tipoventa=_id_tipoventa,
				id_moneda=_id_moneda ,
				imp_dscto=_imp_dscto ,
				--id_comprasventa=_id_comprasventa,
				id_vendedor=_id_vendedor,
				placa_transporte=_placatransporte,
				nro_constinscripcion=_nrocostinscrip,
				id_operacion=_id_operacion,
				id_facturacion=case when _id_facturacion=0 then null else _id_facturacion end,
				id_sucursalfac=case when _id_sucursalfac=0 then null else _id_sucursalfac end,
				DNI_CLIENTE=_DNI_CLIENTE,
				NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				id_modalidad=_id_modalidad,
				id_motivo=_id_motivo,
				id_almacenorigen =_id_almacenorigen ,
				id_almacendestino=_id_almacendestino ,
				ingreso=_ingreso ,
				salida=_salida,
				responsable_recogo=_responsable_recogo
				 where id_guia=_id_guia::integer and  id_sucursal=_id_sucursal;
				res:=array['0',_id_guia::text,_id_sucursal::text,'Actualizacion efectuada con exito'];
			else
				res:=array['504','Verefique que el registro este seleccionado correctamente'];
			end if;			
		else
			res:=array['503','Verifique que el motivo de la guia de remision este seleccionado correctamente '];
		end if;
	else
		res:=array['502','Verifique que los datos del distinatario esten ingresados correctamente'];
	end if;	
end if;
return res;
END;$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;


CREATE OR REPLACE FUNCTION caja.spi_licadacaja(
    _id_movimcaja integer,
    _id_sucursal integer,
    _id_turno integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _fecha_mov text,
    _fec_liquidacion text,
    _id_liquidacion text)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
begin
if exists (select 1 from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal ) then
	if exists (select 1 from PLANILLAS.TBL_TURNOCOLABORADOR  where liquidacion_id=_id_liquidacion::bigint and id_estado=1) then 
		select max(case when id_liquidacion is null then 0 else id_liquidacion::integer end) into correl from caja.tbl_movcaja where  id_sucursal=_id_sucursal;
		/*if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;*/
		update caja.tbl_movcaja set 
			fec_liquidacion=now()
		where  liquidacion_id=_id_liquidacion::bigint;
		res:=array['0','Proceso efectuado con exito'];
	else
		res:=array['0','El turno ya ha sido liquidado en su totalidad'];
	end if;
else
	res:=array['504','No exite ningun registro'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select * from CAJA.SPI_MOVCAJAAPERTURA(1,0,0,1,NULL,1,0,'0001','0002396','2019-11-14 14:01:06.995','FALSE','0.00'::numeric,'200'::numeric,'0.00'::numeric,'0.00'::numeric,'Apertura de caja',6,1,1,1,'1','',1,'20',1,'TRUE','1','1412')


CREATE OR REPLACE FUNCTION caja.spi_movcajaapertura(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _apertura boolean,
    _id_prersonaingdiv varchar(15),
    _id_concepto varchar(4),
    _liquidacion_id bigint,
    _fecha_liquidacion text
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
	valida_apertura boolean;
	data_apertura record;
	num_apertura integer;--almacena el numero de aperturas de caja que existe
	data_turnos record;
	num_turnos integer;
BEGIN
if op=1 then
num_apertura:=0;
num_turnos:=0;
	if  exists(select *from caja.tbl_cajabanco where id_cajabanco=_id_caja_destino) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		for data_apertura in select *from CAJA.TBL_MOVCAJA  where apertura=true and id_turno=_id_turno and id_caja_destino=_id_caja_destino and fecha_mov::date=cast(_fecha_mov as date) loop
			num_apertura:=num_apertura+1;
			RAISE NOTICE 'i is %', num_apertura;
		end loop;
		for data_turnos in select *from planillas.tbl_turnocolaborador where id_caja=_id_caja_destino and id_turno=_id_turno and id_colaborador=_id_persona and fecha::date=_fecha_mov::date and id_estado=1 and liquidado=false loop
			num_turnos:=num_turnos+1;
		end loop;
		RAISE NOTICE 'i is %', num_apertura;
		RAISE NOTICE '_id_caja_destino is %', _id_caja_destino;
		RAISE NOTICE '_id_turno is %', _id_turno;
		RAISE NOTICE '_id_persona is %', _id_persona;
		RAISE NOTICE '_fecha_mov is %', _fecha_mov::date;
			if num_apertura<=0 then
				if num_turnos=1 then
					insert into CAJA.TBL_MOVCAJA(
						id_movimcaja,
						id_facturacion,
						id_caja_destino,
						id_persona,
						id_sucursal_fac,
						serie,
						numero,
						fecha_mov,
						descargo ,
						imp_mora ,
						imp_movimiento,
						imp_recibido  ,
						imp_vuelto    ,
						glosa         ,
						id_comprobante,
						id_moneda     ,
						id_tipocambio ,
						id_sucursal   ,
						id_usuario    ,
						doc_referencia,
						id_estado,
						id_tranzaccion,
						id_turno,
						apertura,
						id_personaingdiv,
						id_concepto,
						liquidacion_id,
						fecha_liquidacion
					)values(
						correl,
						case when _id_facturacion =0 then null else _id_facturacion end ,
						_id_caja_destino,
						_id_persona,
						case when _id_sucursal_fac=0 then null else _id_sucursal_fac end,
						_serie,
						_numero,
						to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
						_descargo ,
						_imp_mora ,
						_imp_movimiento,
						_imp_recibido  ,
						_imp_vuelto    ,
						_glosa         ,
						_id_comprobante,
						_id_moneda     ,
						_id_tipocambio ,
						_id_sucursal   ,
						_id_usuario    ,
						_doc_referencia,
						_id_estado,
						_id_tranzaccion,
						_id_turno,
						_apertura,
						_id_prersonaingdiv,
						_id_concepto,
						_liquidacion_id,
						_fecha_liquidacion::date
					) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
					update planillas.tbl_turnocolaborador set movimiento_id=res[2]::bigint,movisucursal_id=_id_sucursal where liquidacion_id=_liquidacion_id;
					if not found then
						res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
					end if;
				else
					res:=array['No tiene ningun turno programado para la fecha' || num_turnos::text];
				end if;
		else
			res:=array['404','La caja ya ha sido aperturada'];
		end if;
	else
		res:=array['504','Verefique que la caja este ingresado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION public.message(
    IN p_status character varying,
    IN p_message character varying,
    IN p_code character varying,
    IN p_sql character varying)
  RETURNS TABLE(status character varying, message character varying, code character varying, sql character varying) AS
$BODY$
declare
	id bigint;
	response text;
begin
	
	return query select p_status as status,p_message as message,p_code as code,p_sql as sql;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
  
CREATE OR REPLACE FUNCTION seguridad.authorizeUser(
    _camp1 character varying,
    _camp2 character varying
    )
  RETURNS text AS
$BODY$
DECLARE
cadena text;
codigo character(10);
_id_persona text;
BEGIN   
    codigo=NULL;
    
    SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2);

    IF codigo IS NOT NULL  THEN	
        cadena:=to_json(message('success','Usuario Correcto','0',''))::text;  
        codigo:=NULL;
        SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1;

	IF codigo IS NOT NULL THEN	
		 cadena:=to_json(message('success','Usuario Correcto','0',''))::text;  
		 
		codigo:=NULL;		
		SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1 and id_estado=1;
		SELECT id_persona into _id_persona FROM seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1 and id_estado=1;
			IF codigo IS NOT NULL THEN
				 cadena:=to_json(message('success','Usuario y Clave Correctos y usuario esta activo',_id_persona::text,''))::text;  				 				 
				--SELECT id_usuario into codigo FROM seguridad.tbl_usuario where camp2=lower(_camp2) and camp1=_camp1 and id_estado=1 and online=false ;
				IF codigo IS NOT NULL THEN
					cadena:=to_json(message('success','Usuario y Clave Correctos y usuario no esta en linea y ademas esta activo',_id_persona::text,''))::text;  						 
				ELSE
					 cadena:=to_json(message('error','Ya tiene una sesion activa','0',''))::text;  
					 
				END IF;
				 
			ELSE
				 cadena:=to_json(message('error','Usuario se encuentra Inactivo','0',''))::text;  
				cadena:=array['Usuario se encuentra Inactivo'];
			END IF;
		
	ELSE
		 cadena:=to_json(message('error','Contraseña Inorrecta','0',''))::text;  
		 
	END IF;
    ELSE
	 cadena:=to_json(message('error','Usuario Incorrecto','0',''))::text;  
	 
    END IF;
    
    RETURN cadena;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION caja.spi_movcaja(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _puntos numeric,
    _id_cuenta integer,
    _id_concepto character varying,
    _id_centrocostos integer,
    _dni_cliente text,
    _nomape_cliente text,
    _id_personaingdiv character varying,
    _pronto_pago boolean,
    _liquidacion_id bigint,
    _fecha_liquidacion text,
    _id_usuarioautoriza char(5)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
	id_movreturn integer;
	id_sucusalmov integer;
BEGIN
if op=1 then
	if  exists(select 1 from VENTAS.TBL_FACTURACION 
		where id_facturacion=_id_facturacion AND  id_sucursal=_id_sucursal_fac) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA( --select *from CAJA.TBL_MOVCAJA limit 50
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			puntos,
			id_cuenta,
			id_concepto,
			id_centrocostos,
			dni_cliente,
			nomape_cliente,
			Id_personaingdiv,
			liquidacion_id,
			fecha_liquidacion
		)values(
			correl,
			_id_facturacion,
			_id_caja_destino,
			_id_persona,
			_id_sucursal_fac,
			_serie,
			_numero,
			case when _fecha_mov is null then now() else to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS')  end ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_puntos,
			_id_cuenta,
			_id_concepto,
			_id_centrocostos,
			_dni_cliente,
			_nomape_cliente,
			_Id_personaingdiv,
			_liquidacion_id,
			_fecha_liquidacion::date
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','El registro en el movimiento de caja no existe'];
	end if;
end if;	
if op=2 then
	if  exists(select 1 from VENTAS.TBL_FACTURACION 
		where id_facturacion=_id_facturacion AND  id_sucursal=_id_sucursal_fac) then

/*
		delete from caja.tbl_detmovpago dm where exists(select 1 from caja.tbl_movcaja mc where  mc.id_movimcaja=dm.id_movimcaja and 
			mc.id_sucursal=dm.id_sucursal and mc.id_facturacion=_id_facturacion and mc.id_sucursal_fac=_id_sucursal_fac );

		delete from CAJA.TBL_MOVCAJA where id_facturacion=_id_facturacion and id_sucursal_fac=_id_sucursal_fac;

*/


			update caja.tbl_detmovpago set id_estado=7 where exists(select 1 from caja.tbl_movcaja mc where  mc.id_movimcaja=tbl_detmovpago.id_movimcaja and 
			mc.id_sucursal=tbl_detmovpago.id_sucursal and mc.id_facturacion=_id_facturacion and mc.id_sucursal_fac=_id_sucursal_fac );

			update CAJA.TBL_MOVCAJA set id_estado=7 ,glosa='anulado por actualizacion del comprobante' || now()::text 
			where id_facturacion=_id_facturacion and id_sucursal_fac=_id_sucursal_fac;
			select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
			
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			puntos,
			id_cuenta,
			id_concepto,
			id_centrocostos,
			dni_cliente,
			nomape_cliente,
			Id_personaingdiv,
			liquidacion_id,
			fecha_liquidacion
		)values(
			correl,
			_id_facturacion,
			_id_caja_destino,
			_id_persona,
			_id_sucursal_fac,
			_serie,
			_numero,
			case when _fecha_mov is null then now() else to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS')  end ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_puntos,
			_id_cuenta,
			_id_concepto,
			_id_centrocostos,
			_dni_cliente,
			_nomape_cliente,
			_Id_personaingdiv,
			_liquidacion_id,
			_fecha_liquidacion::date
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','El registro en el movimiento de caja no existe'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from CAJA.TBL_MOVCAJA


CREATE OR REPLACE FUNCTION caja.spi_movcajacuota(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _puntos numeric,
    _id_cuenta integer,
    _id_concepto character varying,
    _id_centrocostos integer,
    _dni_cliente character,
    _nomape_cliente text,
    _id_personaingdiv character varying,
    _pronto_pago boolean,
    _liquidacion_id bigint,
    _fecha_liquidacion text,
    _id_usuario_autoriza varchar(5)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from caja.tbl_cajabanco where id_cajabanco=_id_caja_destino) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			id_cuenta,
			id_concepto,
			id_centrocostos,
			dni_cliente ,
			nomape_cliente  ,
			id_personaingdiv ,
			pronto_pago,
			liquidacion_id,
			fecha_liquidacion,
			id_usuario_autoriza
		)values(
			correl,
			case when _id_facturacion =0 then null else _id_facturacion end ,
			_id_caja_destino,
			_id_persona,
			case when _id_sucursal_fac=0 then null else _id_sucursal_fac end,
			_serie,
			_numero,
			to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_id_cuenta,
			_id_concepto,
			_id_centrocostos,
			_dni_cliente ,
			_nomape_cliente  ,
			_id_personaingdiv ,
			_pronto_pago,
			_liquidacion_id,
			_fecha_liquidacion::date,
			_id_usuario_autoriza
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','Verefique que la caja este ingresado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;





CREATE OR REPLACE FUNCTION caja.spi_result_movcajacuota(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _puntos numeric,
    _id_cuenta integer,
    _id_concepto character varying,
    _id_centrocostos integer,
    _dni_cliente character,
    _nomape_cliente text,
    _id_personaingdiv character varying,
    _pronto_pago boolean,
    _liquidacion_id bigint,
    _fecha_liquidacion text,
    _id_usuario_autoriza varchar(5)
    )
  RETURNS table(Code text,message text, id bigint,sucursal_id integer) AS
$BODY$
DECLARE
	correl integer;
	movimientoId integer;
	sucursalId integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from caja.tbl_cajabanco where id_cajabanco=_id_caja_destino) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			id_cuenta,
			id_concepto,
			id_centrocostos,
			dni_cliente ,
			nomape_cliente  ,
			id_personaingdiv ,
			pronto_pago,
			liquidacion_id,
			fecha_liquidacion,
			id_usuario_autoriza
		)values(
			correl,
			case when _id_facturacion =0 then null else _id_facturacion end ,
			_id_caja_destino,
			_id_persona,
			case when _id_sucursal_fac=0 then null else _id_sucursal_fac end,
			_serie,
			_numero,
			to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_id_cuenta,
			_id_concepto,
			_id_centrocostos,
			_dni_cliente ,
			_nomape_cliente  ,
			_id_personaingdiv ,
			_pronto_pago,
			_liquidacion_id,
			_fecha_liquidacion::date,
			_id_usuario_autoriza
		) returning TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal into movimientoId,sucursalId;
			return query select '504' as Code,'Inconsistencia inesperada al registrar el movimiento de caja' as message,0 as movimientoId,0 as sucursalId;
		if not found then
		return query select '504' as Code,'Inconsistencia inesperada al registrar el movimiento de caja' as message,0 as movimientoId,0 as sucursalId;
			--res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
		
	else
		return query select '504' as Code,'Verefique que la caja este ingresado correctamente' as message,0 as movimientoId,0 as sucursalId;
		--res:=array['504','Verefique que la caja este ingresado correctamente'];
	end if;
end if;	
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 


CREATE OR REPLACE FUNCTION almacen.fn_elminar_serie_producto(_idserie bigint)
  RETURNS text[] AS
$BODY$
declare
 res text[];
begin
  if exists(select * from almacen.tbl_serieproducto where id_estado<>18 and id_serie=_idserie ) then
	if  exists(select *from almacen.tbl_serieproducto where id_serie=_idserie and id_estado=1) then
		update  almacen.tbl_serieproducto set id_estado=7 where id_serie=_idserie and id_estado=1;
		res:=array['0','Registro inactivo'];
		if not found then
			res:=array['504','Inconsistencia inesperada no se realizo ningun proceso'];
		end if;
	else
		res:=array['502','Verifique que el registro este activo y no este facturado'];
	end if;
  else
	res:=array['503','El Nro. Serie esta facturado'];
  end if;
  return res;
end ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  
select *from ALMACEN.PRODUCT_ATTRIBUTES

CREATE OR REPLACE FUNCTION ALMACEN.fn_attributes_products(
    op integer,
    _id bigint  ,
    _uuid varchar(36)  ,
    _status boolean  ,
    _isvariation boolean  ,
    _attribute_id bigint  ,
    _product_Id varchar(20)
)
returns text[] as $$
declare
	 res text[];
begin
if op=1 then
	if exists(select 1 from almacen.attributes where id=_attribute_id) then
		if exists(select 1 from almacen.tbl_producto where id_producto=_product_Id) then
			if not exists(select * from ALMACEN.PRODUCT_ATTRIBUTES where attribute_id=_attribute_id and product_Id=_product_Id) then 
				SELECT MAX(ID) into _id from ALMACEN.PRODUCT_ATTRIBUTES ;
				if _id is null  then
					_id:=1;
				else
					_id:=_id+1;
				end if;
				insert into ALMACEN.PRODUCT_ATTRIBUTES(
					id   ,
					status,
					isvariation,
					attribute_id,
					product_Id 
				)VALUES(
					_id   ,
					TRUE,
					FALSE,
					_attribute_id,
					_product_Id 
				) returning array['0',PRODUCT_ATTRIBUTES.id] into res;
				if not found then 
					res:=array['504','Inconsistencia inesperada la registrar los attibutos'];
				end if;
			else
				select id into _id from ALMACEN.PRODUCT_ATTRIBUTES where attribute_id=_attribute_id and product_Id=_product_Id and status=true;
				res:= array['0',_id::text];
			end if;
		else
			res:=array['503','Verifique que los datos del producto esten ingresados correctamente'];
		end if;
	else
		res:=array['504','Verifique que los datos del atributo esten ingresados correctamente'];
	end if;
end if;
if op=2 then
	if exists(select 1 from ALMACEN.PRODUCT_ATTRIBUTES where id=_id) then
		update ALMACEN.PRODUCT_ATTRIBUTES set status=_status where id=_id;
		res:=array['0',_id::text,'Registro actualizado'];
	else
		res:=array['504','Verifique el registro exista'];
	end if;
end if;
return res;
end;$$
language 'plpgsql';

SELECT *FROM ALMACEN.PRODUCT_ATTRIBUTE_VALUES


CREATE OR REPLACE FUNCTION ALMACEN.FN_ATTRIBUTE_PRODUCT_VALUES(
    _op  integer,
    _id bigint  ,
    _uuid varchar(36) ,
    _custom boolean,
    _barcode varchar(60),
    _printable boolean,
    _status boolean ,
    _visible_web boolean,
    _product_attribute_id bigint,
    _attribute_value_id bigint,
    _id_estado integer
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
if _op=1then
	if exists(select *from ALMACEN.PRODUCT_ATTRIBUTES where id=_product_attribute_id) then
		if exists(select * from ALMACEN.ATTRIBUTE_VALUES where id=_attribute_value_id) then
			select max(id) into _id from ALMACEN.PRODUCT_ATTRIBUTE_VALUES;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			insert into ALMACEN.PRODUCT_ATTRIBUTE_VALUES(
				id,
				custom,
				printable,
				status,
				visible_web,
				product_attribute_id,
				attribute_value_id,
				barcode,
				id_estado
			)
			values(
				_id,
				_custom,
				_printable,
				_status,
				_visible_web,
				_product_attribute_id,
				_attribute_value_id,
				'',
				_id_estado
				
			) returning array['0','Procesado realizado conexito'] into res;
			if not found then
			end if;
		else
			res:=array['503','verifique que existe el valor del atributo'];
		end if;
	else
		res:=array['504','verifique que el attribute este asignado al producto seleccionado'];
	end if;
end if;
if _op=2 then
	if exists(select 1 from ALMACEN.PRODUCT_ATTRIBUTE_VALUES where id=_id)then
		update ALMACEN.PRODUCT_ATTRIBUTE_VALUES set status=_status,printable=_printable,custom=_custom,id_estado=_id_estado where id=_id;
		res:=array['0','Registro actualizado'];
	else
		res:=array['504','verifique que exista el registro seleccionado'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION almacen.FN_GETSERIESVENTAS(
    _id_facturacion bigint,
    _id_sucursal integer,
    _id_producto varchar(30),
    _id_unimed integer)
  RETURNS text AS
$BODY$
DECLARE 
SERIE text;
registro record;
BEGIN 
serie=E'\n SERIE: ';
FOR registro in select * from almacen.tbl_serieventa sv
inner join almacen.tbl_serieproducto ser on (ser.id_serie=sv.id_serie)
where sv.id_facturacion=_id_facturacion and sv.id_sucursal=_id_sucursal  and TRIM(ser.id_producto)=TRIM(_id_producto) and ser.id_unidadventa=_id_unimed  loop
SERIE:= SERIE || E'\n'|| COALESCE(registro.nro_serie,'');  --||
 
end loop;
return SERIE;
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.FN_GETSERIESGUIA(
    _id_facturacion bigint,
    _id_sucursal integer,
    _id_producto varchar(30),
    _id_unimed integer)
  RETURNS text AS
$BODY$
DECLARE 
SERIE text;
registro record;
BEGIN 
serie=E'\n SERIE: ';
FOR registro in select * from almacen.tbl_serieguia sv
inner join almacen.tbl_serieproducto ser on (ser.id_serie=sv.id_serie)
where sv.id_guia=_id_facturacion and sv.id_sucursal=_id_sucursal  and TRIM(ser.id_producto)=TRIM(_id_producto) and ser.id_unidadventa=_id_unimed  loop
SERIE:= SERIE || E'\n'|| COALESCE(registro.nro_serie,'');  --||
 
end loop;
return SERIE;
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ventas.v_serie_notacredito   where id_facturacion=21 and id_sucursal=1

CREATE OR REPLACE FUNCTION almacen.FN_GETSERIESVENTAS_nc(
    _id_facturacion bigint,
    _id_sucursal integer,
    _id_producto varchar(30),
    _id_unimed integer)
  RETURNS text AS
$BODY$
DECLARE 
SERIE text;
registro record;
BEGIN 
serie='';
FOR registro in select * from almacen.tbl_serieventa sv
inner join ventas.tbl_facturacion  f on f.id_facturacion=sv.id_facturacion and f.id_sucursal=sv.id_sucursal
inner join almacen.tbl_serieproducto ser on (ser.id_serie=sv.id_serie)
where f.nota_credito=true and sv.id_facturacion=_id_facturacion and sv.id_sucursal=_id_sucursal  and TRIM(ser.id_producto)=TRIM(_id_producto) and ser.id_unidadventa=_id_unimed  loop
SERIE:= E'S/N :' || COALESCE(registro.nro_serie,'');  --||
 
end loop;
return SERIE;
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from common.V_CONFIGSERIES  where id_sucursal=1 and id_comprobante =5 and serie='0001' and  id_estado =1

select *from almacen.fn_attributes_ventas('4418')

CREATE OR REPLACE FUNCTION almacen.fn_attributes_ventas(
    _id_producto varchar(30)
)
  RETURNS text AS
$BODY$
DECLARE 
SERIE text;
registro record;
BEGIN 
serie='';
FOR registro in select * from almacen.v_products_attributes_values  where TRIM(product_id)=TRIM(_id_producto) and printable=true  loop
SERIE:= SERIE || E'\n' || registro. atribute|| COALESCE(registro.value_atribute,'');  --||
 
end loop;
return SERIE;
END ;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from almacen.FN_GETSERIESVENTAS(2,1,'487',1)

CREATE OR REPLACE FUNCTION ventas.v_resumenboletasv21(
    IN _fecha text,
    IN _id_empresa integer,
    IN _id_comprobante integer)
  RETURNS TABLE(
  serienumero text, 
  codigosunat text, 
  docidentidad character varying, 
  tipodocidentidad character, 
  serienumero_ref text, 
  tipodoc_ref text, 
  regimenpercep text, 
  tasapercep text, 
  montopercep numeric, 
  montototalcobrado numeric, 
  basepercep numeric, 
  estadoitem text, 
  impgravada numeric, 
  impexonerado numeric, 
  impinafecto numeric, 
  otroscagos numeric, 
  imp_isc numeric, 
  impigv numeric, 
  total_percep numeric, 
  otros_tributos numeric, 
  imp_total numeric, 
  nro_fila integer, 
  identificador text, 
  issuedate text, 
  referencedate text, 
  prefix text,
  serie text,
  numero char(7)
  ) AS
$BODY$
declare
begin
 return query SELECT 'B'||right(f.serie_facturacion::text,3) || '-' || f.numdoc_facturacion AS serieNumero,
    cp.codigosunat,
    cli.doc_persona as docidentidad, 
    cast(case when length(coalesce(TRIM(cli.doc_persona),'-'))=8 then '1' else '6' end as char(1)) as tipodocIdentadad, 
    '-' serieNumeroRef, 
    '-' TipoDocRef,
    '01' as RegimenPercep,
    '01' as TasaPercep,
    0.00 as MontoPercep,
    0.00 as MontoTotalCobrado,
    0.00 as BasePercep,
    '1' as EstadoItem,
        CASE
            WHEN f.id_operacion = 1 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    f.imp_igv AS impigv,
    f.imp_total AS total_percep,
    f.imp_percepcion AS otros_tributos,
    f.imp_neto AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix,
     'B'||right(f.serie_facturacion::text,3) as serie,
     f.numdoc_facturacion AS numero
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = f.id_cliente::text
     left join planillas.tbl_tipdocidentidad tdoc on tdoc.id_tipdocidentidad=cli.id_tipdocidentidad 
     inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
      left join ( 
     select  
	docref.id_facturacion,
	docref.id_sucursal ,
	'B'||right(docref.serie_facturacion::text,3) || '-' || docref.numdoc_facturacion AS serieNumeroRef,
	cpr.codigosunat as TipoDocRef
	from ventas.tbl_facturacion docref 
     INNER JOIN common.tbl_comprobante cpr ON cpr.id_comprobante = docref.id_comprobante
     WHERE docref.nota_credito=true
     ) dref on F.id_facturacionref=dref.id_facturacion AND F.id_sucursalref=dref.ID_SUCURSAL
     
  WHERE cp.id_comprobante IN(2) and f.fecha_venta::Date=_fecha::date and s.id_empresa=_id_empresa and f.id_comprobante=_id_comprobante 
  --GROUP BY f.serie_facturacion, (f.fecha_venta::date), cp.codigosunat, f.id_operacion
  UNION ALL
  SELECT 'B'||right(f.serie_facturacion::text,3) || '-' || f.numdoc_facturacion AS serieNumero,
    cp.codigosunat,
    cli.doc_persona as docidentidad, 
    cast(case when length(coalesce(TRIM(cli.doc_persona),'-'))=8 then '1' else '6' end as char(1)) as tipodocIdentadad,      
    'B'||right(nc.serie_facturacion::text,3) || '-' || nc.numdoc_facturacion as serieNumeroRef, 
    cpr.codigosunat as TipoDocRef,
    '01' as RegimenPercep,
    '01' as TasaPercep,
    0.00 as MontoPercep,
    0.00 as MontoTotalCobrado,
    0.00 as BasePercep,
    '1' as EstadoItem,
        CASE
            WHEN f.id_operacion = 1 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    f.imp_igv AS impigv,
    f.imp_total AS total_percep,
    f.imp_percepcion AS otros_tributos,
    f.imp_neto AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix,
    'B'||right(f.serie_facturacion::text,3) as serie,
     f.numdoc_facturacion AS numero
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante   
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = f.id_cliente::text
     left join planillas.tbl_tipdocidentidad tdoc on tdoc.id_tipdocidentidad=cli.id_tipdocidentidad 
     INNER JOIN VENTAS.TBL_FACTURACION NC ON NC.ID_FACTURACION=F.ID_FACTURACIONREF and nc.id_sucursal=f.id_sucursalref AND NC.id_comprobante=2
     INNER JOIN common.tbl_comprobante cpr ON cpr.id_comprobante = NC.id_comprobante
     inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
    
  WHERE cp.id_comprobante IN(19) and f.fecha_venta::Date=_fecha::date and s.id_empresa=_id_empresa  and f.id_comprobante=_id_comprobante
UNION ALL
SELECT 'B'||right(f.serie_facturacion::text,3) || '-' || f.numdoc_facturacion AS serieNumero,
    cp.codigosunat,
    cli.doc_persona as docidentidad, 
    cast(case when length(coalesce(TRIM(cli.doc_persona),'-'))=8 then '1' else '6' end as char(1)) as tipodocIdentadad, 
    '-' serieNumeroRef, 
    '-' TipoDocRef,
    '01' as RegimenPercep,
    '01' as TasaPercep,
    0.00 as MontoPercep,
    0.00 as MontoTotalCobrado,
    0.00 as BasePercep,
    '1' as EstadoItem,
        CASE
            WHEN f.id_operacion = 1 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN f.valor_venta
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    f.imp_igv AS impigv,
    f.imp_total AS total_percep,
    f.imp_percepcion AS otros_tributos,
    f.imp_neto AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix,
     'B'||right(f.serie_facturacion::text,3) as serie,
     f.numdoc_facturacion AS numero
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = f.id_cliente::text
     left join planillas.tbl_tipdocidentidad tdoc on tdoc.id_tipdocidentidad=cli.id_tipdocidentidad 
     inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
      left join ( 
     select  
	docref.id_facturacion,
	docref.id_sucursal ,
	'B'||right(docref.serie_facturacion::text,3) || '-' || docref.numdoc_facturacion AS serieNumeroRef,
	cpr.codigosunat as TipoDocRef
	from ventas.tbl_facturacion docref 
     INNER JOIN common.tbl_comprobante cpr ON cpr.id_comprobante = docref.id_comprobante
     WHERE docref.nota_credito=true
     ) dref on F.id_facturacionref=dref.id_facturacion AND F.id_sucursalref=dref.ID_SUCURSAL
     
  WHERE cp.id_comprobante IN(2) AND f.id_estado<>1 and f.fecha_venta::Date=_fecha::date and s.id_empresa=_id_empresa  and f.id_comprobante=_id_comprobante 
  ;
  --GROUP BY f.serie_facturacion, (f.fecha_venta::date), cp.codigosunat, f.id_operacion;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;




CREATE OR REPLACE FUNCTION ventas.v_resumenboletas(
    IN _fecha text,
    IN _id_empresa integer,
    IN _id_comprobante integer)
  RETURNS TABLE(serie text, codigo text, inicio integer, fin integer, impgravada numeric, impexonerado numeric, impinafecto numeric, otroscagos numeric, imp_isc numeric, impigv numeric, total_percep numeric, otros_tributos numeric, imp_total numeric, nro_fila integer, identificador text, issuedate text, referencedate text, prefix text) AS
$BODY$

declare
begin
 return query SELECT 'B'||right(f.serie_facturacion::text,3) AS serie,
    cp.codigosunat,
    min(f.numdoc_facturacion::integer) AS startdocument,
    max(f.numdoc_facturacion::integer) AS enddocument,
        CASE
            WHEN f.id_operacion = 1 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    sum(f.imp_igv) AS impigv,
    sum(f.imp_total) AS total_percep,
    sum(f.imp_percepcion) AS otros_tributos,
    sum(f.imp_neto) AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = f.id_cliente::text
     inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
  WHERE cp.id_comprobante IN(2) and f.fecha_venta::Date=_fecha::date and s.id_empresa=_id_empresa  and f.id_comprobante=_id_comprobante  
  GROUP BY f.serie_facturacion, (f.fecha_venta::date), cp.codigosunat, f.id_operacion
  UNION
  SELECT 'B'||right(f.serie_facturacion::text,3) AS serie,
    cp.codigosunat,
    min(f.numdoc_facturacion::integer) AS startdocument,
    max(f.numdoc_facturacion::integer) AS enddocument,
        CASE
            WHEN f.id_operacion = 1 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    sum(f.imp_igv) AS impigv,
    sum(f.imp_total) AS total_percep,
    sum(f.imp_percepcion) AS otros_tributos,
    sum(f.imp_neto) AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante    
     INNER JOIN VENTAS.TBL_FACTURACION NC ON NC.ID_FACTURACION=F.ID_FACTURACIONREF  and nc.id_sucursal=f.id_sucursalref AND NC.id_comprobante=2
    inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
  WHERE cp.id_comprobante IN(19) and f.fecha_venta::Date=_fecha::date and s.id_empresa=_id_empresa   and f.id_comprobante=_id_comprobante
  GROUP BY f.serie_facturacion, (f.fecha_venta::date), cp.codigosunat, f.id_operacion;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;




CREATE OR REPLACE  FUNCTION restaurant.v_ranking_producto()
    RETURNS TABLE(orden bigint, codigo character varying, producto character varying, _cantidad numeric, precio numeric) 
    LANGUAGE 'plpgsql'
AS $BODY$

DECLARE
BEGIN
return query select *from (SELECT row_number() OVER(order  BY CANTIDAD desc) as order,* FROM (SELECT 
	TRIM(P.CODIGO)::VARCHAR(30) AS CODIGO,
	P.DESCRIPCION_LARGA AS PRODUCTO,
	SUM(DF.CANTIDAD) AS CANTIDAD,
	DF.PRECIO 
FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
GROUP BY P.CODIGO,
	P.DESCRIPCION_LARGA,	
	DF.PRECIO 
)	Z
ORDER BY CANTIDAD desc
) Y					;
END;
$BODY$;


SELECT *FROM restaurant.FN_IMP_MESA('03/05/2018','03/05/2018')

CREATE OR REPLACE FUNCTION restaurant.FN_LIQUIDACION_X_MESA(
	_fecha_init text,
	_fecha_fin text
)
RETURNS TABLE(
	id_mesa integer,
	mesa varchar(50),
	importe numeric(20,4)
)
AS $$
DECLARE
BEGIN
	return query 
select m.id_mesa,m.nro_mesa as mesa,sum(cp.imp_total) as importe from ventas.tbl_cotizacionpreventa  cp
inner join restaurant.tbl_comandamesa mc on mc.id_cotizapreventa=cp.id_cotizapreventa
inner join restaurant.tbl_mesa m on m.id_mesa=mc.id_mesa
where mc.id_estado=1 and cp.id_estado=1 and cp.fecha::Date between _fecha_init::DATE and _fecha_fin::DATE
group by m.id_mesa,m.nro_mesa
order by m.id_mesa;
END;$$
LANGUAGE 'plpgsql';



select * from almacen.isp_serieventa(1,1,1,332,1,2,0,'2018-04-22 00:14:06.786','1    ',18,'')

delete from almacen.tbl_serieventa

select *from almacen.tbl_serieventa


SELECT P.DESCRIPCION_LARGA AS PRODUCTO,UND.DESC_LARGA AS UND,DF.CANTIDAD,TV.DESCRIPCION_CORTA AS TIPOVENTA,DF.IMPORTE FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN common.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO =DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
WHERE DF.ID_ESTADO=1 AND F.ID_ESTADO=1 and df.id_producto='004945'

SELECT * FROM crosstab('SELECT P.DESCRIPCION_LARGA AS PRODUCTO,UND.DESC_LARGA AS UND,DF.CANTIDAD,LOWER(TV.DESCRIPCION_CORTA) AS TIPOVENTA,DF.IMPORTE FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN common.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO =DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
WHERE DF.ID_ESTADO=1 AND F.ID_ESTADO=1','SELECT m FROM generate_series(1,2) m ') 
AS RESULT( PRODUCTO VARCHAR(250),UNIDAD VARCHAR(50),CANTIDAD NUMERIC(20,2),CONTADO NUMERIC(20,2),CREDITO NUMERIC(20,2));


_id_producto   varchar(15) ,
	_id_unidadventa integer,

SELECT *FROM creditos.fn_cuenta_corriente_clientes();
select *from creditos.v_cuenta_corriente_clientes



CREATE OR REPLACE FUNCTION ventas.fn_impdocumenventas(
    IN __id_facturacion integer,
    IN __id_sucursal integer)
  RETURNS TABLE(
  numdoc_facturacion character,
   serie_facturacion character, 
   id_comprobante integer,
    id_direccion bigint, id_cliente character varying, id_sucursal integer, documento text, cliente text, direccion text, fecha_venta timestamp without time zone,
 nro_documento text, tot_letras text, valor_venta numeric, imp_igv numeric, imp_total numeric, cantidad numeric, precio numeric,
 producto text, tot_detalle numeric, unidad character varying, moneda character varying, id_facturacion integer, id_producto character varying, 
id_almacen integer, id_unidadventa integer, id_listaprecio integer, id_manguera character varying, id_lado integer, id_isla integer, 
id_estado integer, imp_dscto numeric, imp_igvdetalle numeric, item integer, impuesto numeric, servicio boolean, coste numeric, val_unidad numeric, 
val_minimo_venta numeric, id_caja integer, imp_recibido numeric, imp_vuelto numeric, id_vendedor character varying, vale text, nom_comprobante character varying, 
mensaje text, puntos numeric, tot_puntos numeric, id_turno integer, tipoventa character varying, vendedor text, ancho numeric, largo numeric, fec_larga text, 
tienda character varying, dir_cliente text, ubigeo text, fec_vencimiento timestamp without time zone, imp_percepcion numeric, precio_percep_l numeric, 
total_percep_l numeric, valorventa_percep numeric, impigv_percep numeric, total_percep numeric, impprecep_percep numeric, vend_fuerzaventas text, 
imp_neto numeric, direccion_suc character varying, telefono character varying, celular character varying, ruc character, prefix text, codigosunat text, 
tipo_docliente integer, fechaemision text, valor_unitario numeric, valor_venta_item numeric, tipoprecio text, imp_detiten numeric, fecha_reg timestamp without time zone, 
formapago text,_mesa varchar(50)) AS
$BODY$
DECLARE
	consumo boolean;
BEGIN

select f.porconsumo into consumo from ventas.tbl_facturacion f WHERE f.id_facturacion=__id_facturacion and   f.id_sucursal=__id_sucursal;
if consumo =false then

return query select 
	_numdoc_facturacion::char(7) as  numdoc_facturacion,
	_serie_facturacion _serie_facturacion  ,
	_id_comprobante _id_comprobante  ,
	_id_direccion _id_direccion  ,
	_id_cliente _id_cliente  ,
	_id_sucursal  ,
	_documento  ,
	_cliente  ,
	_direccion  ,
	_fecha_venta  ,
	_nro_documento  ,
	_tot_letras  ,
	_valor_venta,
	_imp_igv ,
	_imp_total,
	_cantidad ,
	_precio  ,
	_producto  ,
	_tot_detalle  ,
	_unidad  ,
	_moneda  ,
	_id_facturacion  ,
	_id_producto  ,
	_id_almacen  ,
	_id_unidadventa  ,
	_id_listaprecio  ,
	_id_manguera  ,
	_id_lado  ,
	_id_isla  ,
	_id_estado  ,
	_imp_dscto  ,
	_imp_igvdetalle ,
	_item  ,
	_impuesto  ,
	_servicio  ,
	_coste  ,
	_val_unidad  ,
	_val_minimo_venta ,
	_id_caja ,
	_imp_recibido,
	_imp_vuelto ,
	_id_vendedor ,
	_vale,
	_nom_comprobante,
	_mensaje,
	_puntos ,
	_tot_puntos,
	_id_turno,
	_tipoventa,
	_vendedor,--
	_ancho,
	_largo,
	_fec_larga,
	_tienda,
	_dir_cliente,
	_ubigeo,
	_fec_vencimiento,
	_imp_percepcion,
	_precio_percep_l,
	_total_percep_l ,
	_valorventa_percep ,
	_impigv_percep ,
	_total_percep ,
	_impprecep_percep  ,
	_vend_fuerzaventas ,
	_imp_neto ,
	_direccion_suc ,
	_telefono  ,
	_celular  ,
	_ruc,
	_prefix,
	_codigosunat,
	_tipo_docliente,
	_FechaEmision,
	_valor_unitario,
	_valor_venta_item ,
	_tipoPrecio ,
	_imp_detIten,
	_fecha_reg,
	_formapago,
	mesa
	from ventas.v_imprimirventas  f
	where f._id_facturacion=__id_facturacion and   f._id_sucursal=__id_sucursal;
end if;
if consumo=true then
return query	select 
	_numdoc_facturacion::char(7) as  numdoc_facturacion,
	_serie_facturacion _serie_facturacion  ,
	_id_comprobante _id_comprobante  ,
	_id_direccion _id_direccion  ,
	_id_cliente _id_cliente  ,
	_id_sucursal  ,
	_documento  ,
	_cliente  ,
	_direccion  ,
	_fecha_venta  ,
	_nro_documento  ,
	_tot_letras  ,
	_valor_venta,
	_imp_igv ,
	_imp_total,
	1::numeric(20,4) as _cantidad ,
	null::numeric(20,4) _precio  ,
	'POR CONSUMO '::text _producto  ,
	_imp_neto::numeric(20,4) _tot_detalle  ,
	''::varchar(20)_unidad  ,
	_moneda  ,
	_id_facturacion  ,
	_id_producto  ,
	_id_almacen  ,
	_id_unidadventa  ,
	_id_listaprecio  ,
	_id_manguera  ,
	_id_lado  ,
	_id_isla  ,
	_id_estado  ,
	_imp_dscto  ,
	_imp_igvdetalle ,
	_item  ,
	_impuesto  ,
	_servicio  ,
	_coste  ,
	_val_unidad  ,
	_val_minimo_venta ,
	_id_caja ,
	_imp_recibido,
	_imp_vuelto ,
	_id_vendedor ,
	_vale,
	_nom_comprobante,
	_mensaje,
	_puntos ,
	_tot_puntos,
	_id_turno,
	_tipoventa,
	_vendedor,--
	_ancho,
	_largo,
	_fec_larga,
	_tienda,
	_dir_cliente,
	_ubigeo,
	_fec_vencimiento,
	_imp_percepcion,
	_precio_percep_l,
	_total_percep_l ,
	_valorventa_percep ,
	_impigv_percep ,
	_total_percep ,
	_impprecep_percep  ,
	_vend_fuerzaventas ,
	_imp_neto ,
	_direccion_suc ,
	_telefono  ,
	_celular  ,
	_ruc,
	_prefix,
	_codigosunat,
	_tipo_docliente,
	_FechaEmision,
	_valor_unitario,
	_valor_venta_item ,
	_tipoPrecio ,
	_imp_detIten,
	_fecha_reg,
	_formapago,
	mesa
	from ventas.v_imprimirventas  f
	where f._id_facturacion=__id_facturacion and   f._id_sucursal=__id_sucursal
	LIMIT 1
	;
end if;

END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
  


select *from resta


CREATE OR REPLACE FUNCTION creditos.fn_cuenta_corriente_clientes()
returns table(
	documento text,
	fec_credito timestamp,
	cliente varchar(250),
	fecvencimiento date,
	moneda varchar(5),
	imp_credito numeric(20,2),
	imp_interes numeric(20,2),
	importe_nc numeric(20,2),
	pagos numeric(20,2),
	imp_saldo numeric(20,2),
	total_venta numeric(20,2),
	tipo_venta text,
	id_facturacion integer,
	id_sucursal integer,
	id_cliente varchar(15),
	id_direccion bigint,
	id_credito integer,
	id_sucursal_credito integer,
	comprobante char(3),
	serie char(4),
	numero char(7),
	doc_cliente varchar(12),
	id_empresa integer,
	dias_credito text,
	dias_atrazados integer
) AS $$
declare
begin
	return query SELECT
        CASE
            WHEN fac.id_unidad IS NULL THEN ((((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie_facturacion::text) || '-'::text) || fac.numdoc_facturacion::text)::character varying
            ELSE ( SELECT prod.descripcion_larga
               FROM almacen.tbl_producto prod
              WHERE prod.id_producto::text = fac.id_unidad::text)
        END::text AS documento,
    cred.fec_emision AS FecCredito,
    cli.nombre_razon AS cliente,
    cc.ultima_fecha AS fecvencimiento, 
    tbl_moneda.simbolo AS moneda,
          imp_cc.imp_cuota-COALESCE(nc.importe_nc,0) as imp_credito,
          COALESCE(imp_cc.imp_interes, 0.00) as imp_interes,
          COALESCE(nc.importe_nc,0) as importe_nc,
    COALESCE(mov.imp_mov, 0::numeric) AS pagos,
    COALESCE(imp_cc.imp_cuota, 0::numeric)-COALESCE(nc.importe_nc,0) - COALESCE(mov.imp_mov, 0::numeric) AS imp_saldo,
    fac.imp_neto + COALESCE(imp_cc.imp_interes, 0.00) AS total_venta,
    tbl_tipoventa.descripcion_larga::text AS tipo_venta,
    fac.id_facturacion,
    fac.id_sucursal,
    fac.id_cliente,
    fac.id_direccion,
    cred.id_credito,
    cred.id_sucursal_credito,
    tbl_comprobante.descripcion_corta AS comprobante,
    fac.serie_facturacion,
    fac.numdoc_facturacion,
    cli.doc_persona AS dni,
    suc.id_empresa,
    cc.ultima_fecha- cred.fec_emision::date || ' DIAS' AS dias_credito,
    now()::date-cc.ultima_fecha as dias_atrazados
   FROM ventas.tbl_facturacion fac
     JOIN creditos.tbl_ventacredito vc ON fac.id_sucursal = vc.id_sucursal AND vc.id_facturacion = fac.id_facturacion AND fac.id_tipoventa = 2
     JOIN creditos.tbl_credito cred ON cred.id_credito = vc.id_credito AND cred.id_sucursal_credito = vc.id_sucursal_credito
     JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
     JOIN common.tbl_moneda ON fac.id_moneda = tbl_moneda.id_moneda
     JOIN ventas.tbl_direccion dir ON dir.id_persona::text = fac.id_cliente::text AND dir.id_direccion = fac.id_direccion
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = dir.id_persona::text
     JOIN common.tbl_tipoventa ON tbl_tipoventa.id_tipoventa = fac.id_tipoventa
     JOIN common.tbl_sucursal suc ON suc.id_sucursal = fac.id_sucursal
     inner join  (
	select C.id_credito,C.id_sucursal_credito,sum(imp_cuota) as imp_cuota,sum(c.imp_mora) as imp_mora,sum(c.imp_interes) as imp_interes from creditos.tbl_cuota c
	group by C.ID_CREDITO,C.id_sucursal_credito
     ) imp_cc on cred.id_credito = imp_cc.id_credito AND cred.id_sucursal_credito = imp_cc.id_sucursal_credito 
     LEFT JOIN (
	select NC.ID_CREDITO,NC.id_sucursal_cred, sum(COALESCE(NC.imp_dscto,0)) AS importe_nc  
	from creditos.tbl_cuota_notacredito NC 
	where nc.id_estado=1
	GROUP BY NC.ID_CREDITO,NC.id_sucursal_cred
	) nc on  cred.ID_CREDITO=NC.ID_CREDITO AND cred.ID_SUCURSAL_CREDITO=NC.id_sucursal_cred 
    LEFT JOIN  (SELECT  cc.id_credito,cc.id_sucursal_credito,max(cc.fec_vencimiento::date) as ultima_fecha FROM  creditos.tbl_cuota cc
		group by cc.id_credito,cc.id_sucursal_credito
		--order by cc.nro_cuota--- desc limit 1
	) cc on cred.id_credito = cc.id_credito AND cred.id_sucursal_credito = cc.id_sucursal_credito
    LEFT JOIN (
	   SELECT c.id_sucursal_credito,c.id_credito,sum(mov.imp_movimiento) AS imp_mov
           FROM creditos.tbl_cuota c
             JOIN creditos.tbl_detpagocuota cmov ON c.id_cuotas = cmov.id_cuotas AND c.id_credito = cmov.id_credito AND c.id_sucursal_credito = cmov.id_sucursal_credito
             JOIN caja.tbl_movcaja mov ON mov.id_movimcaja = cmov.id_movimcaja AND mov.id_sucursal = cmov.id_sucursal
             group by c.id_sucursal_credito,c.id_credito
    ) MOV on cred.id_credito = mov.id_credito AND cred.id_sucursal_credito = mov.id_sucursal_credito
    where fac.id_estado=1;
end;$$
language 'plpgsql';


CREATE OR REPLACE VIEW creditos.v_cuenta_corriente_clientes
 AS 
 SELECT
        CASE
            WHEN fac.id_unidad IS NULL THEN ((((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie_facturacion::text) || '-'::text) || fac.numdoc_facturacion::text)::character varying
            ELSE ( SELECT prod.descripcion_larga
               FROM almacen.tbl_producto prod
              WHERE prod.id_producto::text = fac.id_unidad::text)
        END::text AS documento,
    cred.fec_emision AS FecCredito,
    cli.nombre_razon AS cliente,
    cc.ultima_fecha AS fecvencimiento, 
    tbl_moneda.simbolo AS moneda,
          imp_cc.imp_cuota-COALESCE(nc.importe_nc,0) as imp_credito,
          COALESCE(imp_cc.imp_interes, 0.00) as imp_interes,
          COALESCE(nc.importe_nc,0) as importe_nc,
    COALESCE(mov.imp_mov, 0::numeric) AS pagos,
    COALESCE(imp_cc.imp_cuota, 0::numeric)-COALESCE(nc.importe_nc,0) - COALESCE(mov.imp_mov, 0::numeric) AS imp_saldo,
    fac.imp_neto + COALESCE(imp_cc.imp_interes, 0.00) AS total_venta,
    tbl_tipoventa.descripcion_larga::text AS tipo_venta,
    fac.id_facturacion,
    fac.id_sucursal,
    fac.id_cliente,
    fac.id_direccion,
    cred.id_credito,
    cred.id_sucursal_credito,
    tbl_comprobante.descripcion_corta AS comprobante,
    fac.serie_facturacion,
    fac.numdoc_facturacion,
    cli.doc_persona AS dni,
    suc.id_empresa,
    cc.ultima_fecha- cred.fec_emision::date || ' DIAS' AS dias_credito,
    now()::date-cc.ultima_fecha as dias_atrazados
   FROM ventas.tbl_facturacion fac
     JOIN creditos.tbl_ventacredito vc ON fac.id_sucursal = vc.id_sucursal AND vc.id_facturacion = fac.id_facturacion AND fac.id_tipoventa = 2
     JOIN creditos.tbl_credito cred ON cred.id_credito = vc.id_credito AND cred.id_sucursal_credito = vc.id_sucursal_credito
     JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
     JOIN common.tbl_moneda ON fac.id_moneda = tbl_moneda.id_moneda
     JOIN ventas.tbl_direccion dir ON dir.id_persona::text = fac.id_cliente::text AND dir.id_direccion = fac.id_direccion
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = dir.id_persona::text
     JOIN common.tbl_tipoventa ON tbl_tipoventa.id_tipoventa = fac.id_tipoventa
     JOIN common.tbl_sucursal suc ON suc.id_sucursal = fac.id_sucursal
     inner join  (
	select C.id_credito,C.id_sucursal_credito,sum(imp_cuota) as imp_cuota,sum(c.imp_mora) as imp_mora,sum(c.imp_interes) as imp_interes from creditos.tbl_cuota c
	group by C.ID_CREDITO,C.id_sucursal_credito
     ) imp_cc on cred.id_credito = imp_cc.id_credito AND cred.id_sucursal_credito = imp_cc.id_sucursal_credito 
     LEFT JOIN (
	select NC.ID_CREDITO,NC.id_sucursal_cred, sum(COALESCE(NC.imp_dscto,0)) AS importe_nc  
	from creditos.tbl_cuota_notacredito NC 
	where nc.id_estado=1
	GROUP BY NC.ID_CREDITO,NC.id_sucursal_cred
	) nc on  cred.ID_CREDITO=NC.ID_CREDITO AND cred.ID_SUCURSAL_CREDITO=NC.id_sucursal_cred 
    LEFT JOIN  (SELECT  cc.id_credito,cc.id_sucursal_credito,max(cc.fec_vencimiento::date) as ultima_fecha FROM  creditos.tbl_cuota cc
		group by cc.id_credito,cc.id_sucursal_credito
		--order by cc.nro_cuota--- desc limit 1
	) cc on cred.id_credito = cc.id_credito AND cred.id_sucursal_credito = cc.id_sucursal_credito
    LEFT JOIN (
	   SELECT c.id_sucursal_credito,c.id_credito,sum(mov.imp_movimiento) AS imp_mov
           FROM creditos.tbl_cuota c
             JOIN creditos.tbl_detpagocuota cmov ON c.id_cuotas = cmov.id_cuotas AND c.id_credito = cmov.id_credito AND c.id_sucursal_credito = cmov.id_sucursal_credito
             JOIN caja.tbl_movcaja mov ON mov.id_movimcaja = cmov.id_movimcaja AND mov.id_sucursal = cmov.id_sucursal
             group by c.id_sucursal_credito,c.id_credito
    ) MOV on cred.id_credito = mov.id_credito AND cred.id_sucursal_credito = mov.id_sucursal_credito
    where fac.id_estado=1

UNION ALL
 SELECT (((c.descripcion_corta::text || '/'::text) || mv.serie::text) || '-'::text) || mv.numero::text AS documento,
    mv.fecha_mov AS fec_credito,
    pr.nombre_razon AS cliente,
    mv.fecha_mov AS fec_vencimiento,
    mn.simbolo AS moneda,
    COALESCE(( SELECT sum(c_1.imp_cuota) AS sum
           FROM creditos.tbl_cuota c_1
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0::numeric) AS credito,
    0 AS pagos,
    COALESCE(( SELECT sum(c_1.imp_cuota) AS sum
           FROM creditos.tbl_cuota c_1
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0::numeric) - COALESCE(( SELECT sum(mov.imp_movimiento) AS sum
           FROM creditos.tbl_cuota c_1
             JOIN creditos.tbl_detpagocuota cmov ON c_1.id_cuotas = cmov.id_cuotas AND c_1.id_credito = cmov.id_credito AND c_1.id_sucursal_credito = cmov.id_sucursal_credito
             JOIN caja.tbl_movcaja mov ON mov.id_movimcaja = cmov.id_movimcaja AND mov.id_sucursal = cmov.id_sucursal
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0::numeric) AS saldo,
    mv.imp_movimiento + COALESCE(( SELECT sum(c_1.imp_interes) AS sum
           FROM creditos.tbl_cuota c_1
          WHERE cred.id_credito = c_1.id_credito AND cred.id_sucursal_credito = c_1.id_sucursal_credito), 0.00) AS total_venta,
    'Anticipo'::text AS tipo_venta,
    mv.id_movimcaja AS id_facturacion,
    mv.id_sucursal,
    mv.id_personaingdiv AS id_cliente,
    0 AS id_direccion,
    cred.id_credito,
    cred.id_sucursal_credito,
    c.descripcion_corta AS comprobante,
    mv.serie AS serie_facturacion,
    mv.numero AS numdoc_facturacion,
    pr.doc_persona AS dni,
    suc.id_empresa
   FROM caja.tbl_movcaja mv
     JOIN creditos.tbl_credito cred ON cred.id_credito = mv.id_credito AND cred.id_sucursal_credito = mv.id_sucursal_credito
     JOIN common.tbl_comprobante c ON c.id_comprobante = mv.id_comprobante
     JOIN planillas.tbl_persona pr ON pr.id_persona::text = mv.id_personaingdiv::text
     JOIN common.tbl_moneda mn ON mn.id_moneda = mv.id_moneda
     JOIN common.tbl_sucursal suc ON suc.id_sucursal = mv.id_sucursal
  WHERE mv.anticipo_base IS TRUE
  ORDER BY 2;


SELECT *FROM creditos.tbl_credito
	

SELECT *FROM VENTAS.FN__RESUMEN__VENTAS__ARTICULO(1,'','',1,1);

CREATE OR REPLACE FUNCTION VENTAS.FN__RESUMEN__VENTAS__ARTICULO(
	op integer,
	_fecha_ini text,
	_fecha_fin text,
	_id_empresa integer,
	_id_sucursal integer
)
RETURNS TABLE (
	codigo varchar(16),
	producto varchar(250),
	unidad varchar(20),
	cant numeric(20,2),
	contado numeric(20,2),
	credito numeric(20,2),
	importe numeric(20,2)
) AS $$
DECLARE
BEGIN

RETURN QUERY SELECT CAST(TRIM(P.CODIGO) AS VARCHAR(30)) ,P.DESCRIPCION_LARGA AS PRODUCTO,UND.DESC_CORTA AS UND,SUM(COALESCE(CANTIDAD,0)) AS CANT,SUM(COALESCE("1",0)) AS CONTADO,SUM(COALESCE("2",0)) AS CREDITO, (SUM(COALESCE("1",0)) +SUM(COALESCE("2",0))) AS IMPORTE FROM (
SELECT * FROM crosstab('SELECT  DF.ID_PRODUCTO AS PRODUCTO,sum(DF.CANTIDAD) as cantidad,DF.ID_UNIDADVENTA,F.ID_TIPOVENTA AS TIPOVENTA,sum(DF.IMPORTE) as importe FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON F.ID_FACTURACION=DF.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
INNER JOIN common.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO =DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=DF.ID_UNIDADVENTA
WHERE DF.ID_ESTADO=1 AND F.ID_ESTADO=1
group by DF.ID_UNIDADVENTA, DF.ID_PRODUCTO,f.id_tipoventa','SELECT m FROM generate_series(1,2) m ') 
AS RESULT( ID_PRODUCTO VARCHAR(30),CANTIDAD NUMERIC(20,2) ,ID_UNIDADVENTA INTEGER,"1" NUMERIC(20,2),"2" NUMERIC(20,2))
) AS Z 
INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=Z.ID_PRODUCTO 
INNER JOIN ALMACEN.TBL_UNIDAD UND ON UND.ID_UNIDADVENTA=Z.ID_UNIDADVENTA
--where p.id_producto='004358'
GROUP BY P.CODIGO ,P.DESCRIPCION_LARGA,UND.DESC_CORTA ;
END;$$
LANGUAGE 'plpgsql';

SELECT ID_TIPOVENTA,LOWER(DESCRIPCION_CORTA), *FROM COMMON.TBL_TIPOVENTA


CREATE OR REPLACE FUNCTION creditos.isp__descuento_notacredito(
    op integer,
    __id_notacredito integer,
    __id_sucursalnc integer,
    __id_cuota integer,
    __id_credito integer,
    __id_sucursal_cred integer,
    __imp_dscto numeric,
    __fecha character varying,
    __id_usuario character,
    __id_estado integer,
    __glosa character varying)
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
BEGIN

IF OP=1 THEN
DELETE FROM creditos.tbl_cuota_notacredito 
		WHERE id_notacredito=__id_notacredito AND  id_sucursalnc=__id_sucursalnc  AND  id_cuota=__id_cuota AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred;
	IF EXISTS(SELECT *FROM VENTAS.TBL_FACTURACION F WHERE F.ID_FACTURACION=__ID_NOTACREDITO AND F.ID_SUCURSAL=__ID_SUCURSALNC)THEN
		IF EXISTS(SELECT *FROM CREDITOS.TBL_CUOTA WHERE ID_CREDITO=__ID_CREDITO AND ID_CUOTAS=__ID_CUOTA AND id_sucursal_credito=__ID_SUCURSAL_CRED)THEN
			INSERT INTO creditos.tbl_cuota_notacredito(
				    id_notacredito, 
				    id_sucursalnc, 
				    id_cuota, 
				    id_credito, 
				    id_sucursal_cred, 
				    imp_dscto, 
				    fecha_reg, 
				    id_usuario_reg, 
				    id_estado, 
				    glosa
				   )
			    VALUES ( 
				    __id_notacredito, 
				    __id_sucursalnc, 
				    __id_cuota, 
				    __id_credito, 
				    __id_sucursal_cred, 
				    __imp_dscto, 
				    NOW(), 
				    __id_usuario, 
				    __id_estado, 
				    __glosa
				)RETURNING ARRAY['0','PROCESO EFECTUADO CON EXITO'] INTO RES;
				IF NOT FOUND THEN
					RES:=ARRAY['504','Ocurrio un error al generar el descuento por nota de credito'];
				END IF;
		ELSE
			RES:=ARRAY['503','Verefique que exista la cuota que afecta la nota de credito'];
		END IF;
	ELSE
			RES:=ARRAY['502','Verefique que exista la nota de credito'];
	END IF;
END IF;
/*
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM creditos.tbl_cuota_notacredito 
		WHERE id_notacredito=__id_notacredito AND  id_sucursalnc=__id_sucursalnc  AND  id_cuota=__id_cuota AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred) THEN
		
	END IF;
END IF;*/
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE

 



select * from CREDITOS.isp__descuento_notacredito_compra(1,164,1,4060,4059,1,'120'::numeric,NULL,'1',1,NULL)

select * from CREDITOS.isp__descuento_notacredito_compra(2,103,1,2484,2483,1,'210.4600'::numeric,NULL,'1',1,NULL)

SELECT * FROM creditos.tbl_cuota_notacredito 
		WHERE   id_cuota=2484 AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred and id__compra=__id_notacredito  and id_sucursalnc=__id_sucursalnc

select * from CREDITOS.v__cuotas__x__cobrar__nc__compras   where id_facturacion='111'

CREATE OR REPLACE FUNCTION creditos.isp__descuento_notacredito_compra(
    op integer,
    __id_notacredito bigint,
    __id_sucursalnc integer,
    __id_cuota integer,
    __id_credito integer,
    __id_sucursal_cred integer,
    __imp_dscto numeric,
    __fecha character varying,
    __id_usuario character,
    __id_estado integer,
    __glosa character varying)
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
BEGIN

IF OP=1 THEN
DELETE FROM creditos.tbl_cuota_notacredito 
		WHERE   id_cuota=__id_cuota AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred and id__compra=__id_notacredito  and id_sucursalnc=__id_sucursalnc;
	IF EXISTS(SELECT *FROM COMPRAS.TBL_COMPRA F WHERE F.ID__COMPRA=__ID_NOTACREDITO AND F.id_sucursalcompra=__ID_SUCURSALNC)THEN
		IF EXISTS(SELECT *FROM CREDITOS.TBL_CUOTA WHERE ID_CREDITO=__ID_CREDITO AND ID_CUOTAS=__ID_CUOTA AND id_sucursal_credito=__ID_SUCURSAL_CRED)THEN
			INSERT INTO creditos.tbl_cuota_notacredito(
				    id__compra, 
				    id_sucursalnc, 
				    id_cuota, 
				    id_credito, 
				    id_sucursal_cred, 
				    imp_dscto, 
				    fecha_reg, 
				    id_usuario_reg, 
				    id_estado, 
				    glosa
				   )
			    VALUES ( 
				    __id_notacredito, 
				    __id_sucursalnc, 
				    __id_cuota, 
				    __id_credito, 
				    __id_sucursal_cred, 
				    __imp_dscto, 
				    NOW(), 
				    __id_usuario, 
				    1, 
				    __glosa
				)RETURNING ARRAY['0','PROCESO EFECTUADO CON EXITO'] INTO RES;
				IF NOT FOUND THEN
					RES:=ARRAY['504','Ocurrio un error al generar el descuento por nota de credito'];
				END IF;
		ELSE
			RES:=ARRAY['503','Verefique que exista la cuota que afecta la nota de credito'];
		END IF;
	ELSE
		RES:=ARRAY['502','Verefique que exista la nota de credito'];
	END IF;
END IF;

IF OP=2 THEN
	IF EXISTS(SELECT * FROM creditos.tbl_cuota_notacredito 
		WHERE   id_cuota=__id_cuota AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred and id__compra=__id_notacredito  and id_sucursalnc=__id_sucursalnc) THEN
		UPDATE  creditos.tbl_cuota_notacredito SET IMP_DSCTO=__imp_dscto WHERE id_notacredito=__id_notacredito AND  id_sucursalnc=__id_sucursalnc  AND  id_cuota=__id_cuota AND  id_credito=__id_credito AND 
				    id_sucursal_cred=__id_sucursal_cred and id__compra=__id_notacredito  and id_sucursalnc=__id_sucursalnc;
		RES:=ARRAY['0','Registro procesado con exito'];
	else
		RES:=ARRAY['504','Verifique que exista el registro'];
	END IF;
END IF;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE

select *from compras.tbl_compra where id__compra=40
CREATE OR REPLACE FUNCTION caja.spi_movanticipos(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _id_concepto character varying,
    _signo integer,
    _id_personaingdiv character varying,
    _id_credito integer,
    _id_sucursal_credito integer,
    _anticipo_base boolean)
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from COMMON.TBL_CONCEPTO
		where id::text=_id_concepto) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			id_concepto,
			signo,
			id_personaingdiv,
			id_credito,
			id_sucursal_credito,
			anticipo_base
		)values(
			correl,
			case when _id_facturacion=0 then null else _id_facturacion end ,
			_id_caja_destino,
			_id_persona,
			case when _id_sucursal_fac =0 then null else _id_sucursal_fac end ,
			_serie,
			_numero,
			case when _fecha_mov is null then now() else  to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS')  end ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_id_concepto,
			_signo,
			_id_personaingdiv,
			_id_credito,
			_id_sucursal_credito,
			_anticipo_base
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','Verefique que este seleccionado el motivo del movimiento de caja'];
	end if;
end if;
if op=2 then
	if exists (select *from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
		update CAJA.TBL_MOVCAJA set 
			id_caja_destino=_id_caja_destino,
			id_persona=_id_persona,
			id_sucursal_fac=_id_sucursal_fac,
			serie=_serie,
			numero=_numero,
			fecha_mov=to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			imp_movimiento=_imp_movimiento,
			imp_recibido =_imp_recibido  ,
			imp_vuelto  =_imp_vuelto    ,
			glosa      =_glosa         ,
			id_comprobante=_id_comprobante,
			id_moneda=_id_moneda     ,
			id_tipocambio=_id_tipocambio ,
			id_usuario=_id_usuario    ,
			doc_referencia=_doc_referencia,
			id_estado=_id_estado,
			id_tranzaccion=_id_tranzaccion,
			id_turno=_id_turno,
			id_concepto=_id_concepto,
			signo=_signo,
			id_personaingdiv=_id_personaingdiv ,
			id_credito=_id_credito,
			id_sucursal_credito=_id_sucursal_credito,
			anticipo_base=_anticipo_base
			where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal;
			res:=array['0',_id_movimcaja::text,_id_sucursal::text,'Proceso efectuado con exito'];
	else
		res:=array['504','Verefique que el registro editado seleccionado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.isp__metasventas(
    op integer,
    _id_objetivo bigint,
    _importe_obj numeric,
    _porcent_part_anterior numeric,
    _cant_anterior numeric,
    _id_periodo integer,
    _id_tipoobjetivo integer,
    _id_mes integer,
    _id_estado integer,
    _id_persona character varying,
    _id_usuario character,
    _id_mesinicial integer,
    _id_mesfinal integer)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_correl bigint;
BEGIN
if op=1 then
	if _id_mes>_id_mesinicial and _id_mes>_id_mesfinal then
		if not exists(select *from VENTAS.TBL_OBJETIVOVENTA where id_periodo=_id_periodo and  Id_tipoObjetivo=_Id_tipoObjetivo and id_mes=_id_mes AND ID_PERSONA=_ID_PERSONA)then
		select max(id_objetivo) into _correl from ventas.tbl_objetivoventa;
		if _correl is null then
			_correl:=1;
		else
			_correl:=_correl+1;
		end if;
			INSERT INTO ventas.tbl_objetivoventa(
				    id_objetivo, 
				    importe_obj, 
				    id_periodo, 
				    id_tipoobjetivo, 
				    id_tipoventa, 
				    id_mes, 
				    id_persona, 
				    id_estado, 
				    id_usuarior, 
				    fecha_reg, 
				    fecha_act,
				    PORCENT_PART_ANTERIOR,
				    CANTIDAD_ANTERIOR,
				    id_mesinicial,
				    id_mesfinal
				)
			  VALUES (
				    _correl, 
				    _importe_obj, 
				    _id_periodo, 
				    _id_tipoobjetivo, 
				    1,--_id_tipoventa, 
				    _id_mes, 
				    _id_persona, 
				    _id_estado, 
				    _id_usuario, 
				    now(), 
				    now(),
				    _porcent_part_anterior,
				    _cant_anterior,
				     _id_mesinicial,
				    _id_mesfinal
				) returning array['0',id_objetivo::text] into res;
			if not found then
				res:=array['503','Inconsistencia inesperada al genrerar el Objetivo'];
			end if;
		else
			res:=array['502','Ya existe un registro con los mismo datos para el vendedor seleccionado'];
		end if;
	else
		res:=array['504','El mes objetivo esta fuera de rango no puede ser menor que el mes inicial y el mes final'];
	end if;
	
end if;
if op=2 then
	if exists(select *from ventas.tbl_objetivoventa where id_objetivo=_id_objetivo)then
		UPDATE ventas.tbl_objetivoventa
		SET  importe_obj=_importe_obj,
		       id_periodo=_id_periodo,
			id_tipoobjetivo=_id_tipoobjetivo, 
			--id_tipoventa=_id_tipoventa, 
			id_mes=_id_mes, 
			id_persona=_id_persona, 
			id_estado=_id_estado, 
			id_usuarioa=id_usuario, 
			fecha_act=now(),
			PORCENT_PART_ANTERIOR=_porcent_part_anterior,
			CANTIDAD_ANTERIOR=_cant_anterior,
			id_mesinicial=_id_mesinicial,
			id_mesfinal=_id_mesfinal
		WHERE id_objetivo=_id_objetivo;
		res:=array['0','Registro actualizado'];
	else
		res:=Array['503','Verefique que exista el registro que desea actualizar'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.rec_objetivos__ventas(
    refcursor,
    _id_mesinicial integer,
    id_mesfinal integer,
    id_mesobjetivo integer,
    porcentincremento numeric,
    text)
  RETURNS refcursor AS
$BODY$
 DECLARE
	datVentas record  ;
	Cant_Total numeric(20,4);
	porcentParticip numeric(20,4);
 BEGIN
	create temp table Cuotas(
		id_vendedor varchar(15),
		vendedor varchar(100),
		cantidad numeric(20,4),
		porcentaje numeric(20,4),
		cuota numeric(20,4),
		id_mes integer
	)ON COMMIT DROP;

	select sum(dfac.cantidad)  into Cant_Total  from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion dfac on (f.id_facturacion=dfac.id_facturacion)
	where date_part('month',f.fecha_venta)>=_id_mesinicial and date_part('month',f.fecha_venta)<=id_mesfinal and f.id_Estado=1 and dfac.id_estado=1;

	

	open $1 for select 
		vend.id_persona,
		COALESCE(vend.apell_paterno || ' ' || vend.apell_materno || ', ' || vend.nombres,vend.nombre_razon) as vendedor, 
		sum(dfac.cantidad) as cantidad,
		trunc((sum(dfac.cantidad)/Cant_Total)*100::numeric(20,4),3) as porcent,
		((sum(dfac.cantidad)/Cant_Total)*(Cant_Total*(1+(porcentIncremento/100))))::numeric(20,4) as cuota,id_mesObjetivo as mes
	from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion dfac on (f.id_facturacion=dfac.id_facturacion)
	inner join planillas.tbl_persona per on (per.id_persona=f.id_cliente)
	inner join planillas.tbl_persona vend on (vend.id_persona=per.id_vendtitular)
	where date_part('month',f.fecha_venta)>=_id_mesinicial and date_part('month',f.fecha_venta)<=id_mesfinal and f.id_Estado=1 and dfac.id_estado=1
	group by vend.id_persona;
	
	return $1;
 END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from ventas.tbl_objetivoventa
select *from ventas.PIVOT_OBJETIVOS_VENTAS(1,2019);
select *from ventas.TBL_TIPOOBJETIVO


CREATE OR REPLACE   FUNCTION ventas.pivot_objetivos_ventas(
_tipo integer,
_anio integer
)
  RETURNS table(
	id_objetivo bigint,
	vendedor varchar(200), 
	tipo varchar(200), 
	Ene numeric(20,4), 
	Feb numeric(20,4), 
	Mar numeric(20,4), 
	Abr numeric(20,4), 
	May numeric(20,4) , 
	Jun numeric(20,4), 
	Jul numeric(20,4), 
	Ago numeric(20,4), 
	Sep numeric(20,4), 
	Oct numeric(20,4),
	Nov numeric(20,4), 
	dic numeric(20,4),
	anio varchar(50),
	id_persona varchar(15),
	id_tipoobjetivo integer
	) AS
$BODY$
declare
	--__tipo integer;
BEGIN

create temporary table temp_data(
	_id_objetivo bigint ,
	_vendedor varchar(200),
	_tipo varchar(200),
	_ene numeric(20,4),
	_feb numeric(20,4),
	_mar numeric(20,4),
	_abr numeric(20,4),
	_may numeric(20,4),
	_jun numeric(20,4),
	_jul numeric(20,4),
	_ago numeric(20,4),
	_sep numeric(20,4),
	_oct numeric(20,4),
	_nov numeric(20,4),
	_dic numeric(20,4) 
) on commit drop;
/*
 insert into temp_data(
_id_objetivo  ,
_vendedor ,
_tipo ,
_ene ,
_feb ,
_mar ,
_abr ,
_may ,
_jun ,
_jul ,
_ago ,
_sep ,
_oct ,
_nov ,
_dic   )
SELECT 
	__id_objetivo, 
	__vendedor,
	__tipo,
	COALESCE(__ene,0) as ene,
	COALESCE(__feb,0) as feb,
	COALESCE(__mar,0) as mar,
	COALESCE(__abr,0) as abr,
	COALESCE(__may,0) as may,
	COALESCE(__jun,0) as jun,
	COALESCE(__jul,0) as jul,
	COALESCE(__ago,0) as ago,
	COALESCE(__sep,0) as sep,
	COALESCE(__oct,0) as oct,
	COALESCE(__nov,0) as nov,
	COALESCE(__dic,0) as dic
		 FROM crosstab(

   'SELECT 
	ob.id_objetivo,
        per.nombre_razon,
	tb.descripcion, 	
	id_mes, 
	importe_obj	 
	FROM ventas.tbl_objetivoventa ob 
	inner join ventas.TBL_TIPOOBJETIVO tb on (tb.id_tipoobjetivo=ob.id_tipoobjetivo)
	inner join planillas.tbl_persona per on (per.id_persona=ob.id_persona)
	where tb.id_tipoobjetivo='''|| _tipo ||'''
	ORDER BY ob.id_tipoobjetivo ',
  ' SELECT m FROM generate_series(1,12) m '
	) AS (
        __id_objetivo bigint,
	__vendedor varchar(200), 
	__tipo varchar(200), 
	__Ene numeric(20,4), 
	__Feb numeric(20,4), 
	__Mar numeric(20,4), 
	__Abr numeric(20,4), 
	__May numeric(20,4) , 
	__Jun numeric(20,4), 
	__Jul numeric(20,4), 
	__Ago numeric(20,4), 
	__Sep numeric(20,4), 
	__Oct numeric(20,4),
	__Nov numeric(20,4), 
	__dic numeric(20,4)
	);
*/
return query 
	select 
		t.id_objetivo  ,
		v.nombre_razon as  vendedor ,
		tb.descripcion tipo ,
		t.enero ,
		t.febrero ,
		t.marzo ,
		t.abril ,
		t.mayo ,
		t.junio ,
		t.julio ,
		t.agosto ,
		t.septiembre ,
		t.octubre ,
		t.noviembre ,
		t.diciembre,
		pc.descripcion as anio,
		t.id_persona,
		t.id_tipoobjetivo
	from   ventas.tbl_objetivoventa t  
	inner join planillas.tbl_persona v on v.id_persona=t.id_persona
	inner join ventas.TBL_TIPOOBJETIVO tb on (tb.id_tipoobjetivo=t.id_tipoobjetivo)
	inner join contabilidad.tbl_procesocontable pc on pc.id_proceso=t.id_periodo
	where tb.id_tipoobjetivo=_tipo 
	order by t.id_objetivo;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from ventas.TBL_TIPOOBJETIVO

select *from ventas.tbl_periodo

select *from planillas.tbl_persona

select *from ventas.tbl_objetivoventa

select * from ventas.PIVOT_OBJETIVOS_VENTAS(1,2019)
 SELECT 
	id_objetivo, 
	vendedor,
	tipo,
	COALESCE(ene,0) as ene,
	COALESCE(feb,0) as feb,
	COALESCE(mar,0) as mar,
	COALESCE(abr,0) as abr,
	COALESCE(may,0) as may,
	COALESCE(jun,0) as jun,
	COALESCE(jul,0) as jul,
	COALESCE(ago,0) as ago,
	COALESCE(sep,0) as sep,
	COALESCE(oct,0) as oct,
	COALESCE(nov,0) as nov,
	COALESCE(dic,0) as dic
		 FROM crosstab(

   'SELECT 
	ob.id_objetivo,
        per.nombre_razon,
	tb.descripcion, 	
	id_mes, 
	importe_obj	 
	FROM ventas.tbl_objetivoventa ob 
	inner join ventas.TBL_TIPOOBJETIVO tb on (tb.id_tipoobjetivo=ob.id_tipoobjetivo)
	inner join planillas.tbl_persona per on (per.id_persona=ob.id_persona)
	where tb.id_tipoobjetivo='''|| 1 ||'''
	ORDER BY ob.id_tipoobjetivo ',
  ' SELECT m FROM generate_series(1,12) m '
	) AS (
	_id_objetivo bigint,
	_vendedor varchar(200), 
	_tipo varchar(200), 
	_Ene numeric(20,4), 
	_Feb numeric(20,4), 
	_Mar numeric(20,4), 
	_Abr numeric(20,4), 
	_May numeric(20,4) , 
	_Jun numeric(20,4), 
	_Jul numeric(20,4), 
	_Ago numeric(20,4), 
	_Sep numeric(20,4), 
	_Oct numeric(20,4),
	_Nov numeric(20,4), 
	_dic numeric(20,4)
	);


CREATE OR REPLACE FUNCTION ventas.isp__fijarobjetivosventas(
    op integer,
    _id_objetivo bigint,
    _importe_obj numeric,
    _id_periodo integer,
    _id_tipoobjetivo integer,
    _id_tipoventa integer,
    _id_mes integer,
    _id_estado integer,
    _id_persona character varying,
    _id_usuario character)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_correl bigint;
BEGIN
if op=1 then
	if not exists(select *from VENTAS.TBL_OBJETIVOVENTA 
		where id_periodo=_id_periodo and  Id_tipoObjetivo=_Id_tipoObjetivo and 
			id_tipoventa=_id_tipoventa and id_mes=_id_mes AND ID_PERSONA=_ID_PERSONA)then
		select max(id_objetivo) into _correl from ventas.tbl_objetivoventa;
		if _correl is null then
			_correl:=1;
		else
			_correl:=_correl+1;
		end if;
		INSERT INTO ventas.tbl_objetivoventa(
			id_objetivo, 
			importe_obj, 
			id_periodo, 
			id_tipoobjetivo, 
			id_tipoventa, 
			id_mes, 
			id_persona, 
			id_estado, 
			id_usuarior, 
			fecha_reg, 
			fecha_act,
			enero,
			febrero,
			marzo,
			abril,
			mayo,
			junio,
			julio,
			agosto,
			septiembre,
			octubre,
			noviembre,
			diciembre
			)
		  VALUES (
			_correl, 
			_importe_obj, 
			_id_periodo, 
			_id_tipoobjetivo, 
			_id_tipoventa, 
			_id_mes, 
			_id_persona, 
			_id_estado, 
			_id_usuario, 
			now(), 
			now(),
			case when _id_mes=1 then _importe_obj else 0 end,
			case when _id_mes=2 then _importe_obj else 0 end ,
			case when _id_mes=3 then _importe_obj else 0 end ,
			case when _id_mes=4 then _importe_obj else 0 end ,
			case when _id_mes=5 then _importe_obj else 0 end ,
			case when _id_mes=6 then _importe_obj else 0 end ,
			case when _id_mes=7 then _importe_obj else 0 end ,
			case when _id_mes=8 then _importe_obj else 0 end ,
			case when _id_mes=9 then _importe_obj else 0 end ,
			case when _id_mes=10 then _importe_obj else 0 end ,
			case when _id_mes=11 then _importe_obj else 0 end ,
			case when _id_mes=12 then _importe_obj else 0 end 
			) returning array['0',id_objetivo::text] into res;
		if not found then
			res:=array['503','Inconsistencia inesperada al genrerar el Objetivo'];
		end if;
	else
		res:=array['502','Ya existe un registro con los mismo datos para el vendedor seleccionado'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_objetivoventa where id_objetivo=_id_objetivo)then
		UPDATE ventas.tbl_objetivoventa
		SET  importe_obj=_importe_obj,
		       id_periodo=_id_periodo,
			id_tipoobjetivo=_id_tipoobjetivo, 
			id_tipoventa=_id_tipoventa, 
			id_mes=_id_mes, 
			id_persona=_id_persona, 
			id_estado=_id_estado, 
			id_usuarioa=_id_usuario, 
			fecha_act=now(),
			enero=case when _id_mes=1 then _importe_obj else 0 end,
			febrero=case when _id_mes=2 then _importe_obj else 0 end,
			marzo=case when _id_mes=3 then _importe_obj else 0 end,
			abril=case when _id_mes=4 then _importe_obj else 0 end,
			mayo=case when _id_mes=5 then _importe_obj else 0 end,
			junio=case when _id_mes=6 then _importe_obj else 0 end,
			julio=case when _id_mes=7 then _importe_obj else 0 end,
			agosto=case when _id_mes=8 then _importe_obj else 0 end,
			septiembre=case when _id_mes=9 then _importe_obj else 0 end,
			octubre=case when _id_mes=10 then _importe_obj else 0 end,
			noviembre=case when _id_mes=11 then _importe_obj else 0 end,
			diciembre=case when _id_mes=12 then _importe_obj else 0 end
		WHERE id_objetivo=_id_objetivo;
		res:=array['0','Registro actualizado'];
	else
		res:=Array['503','Verefique que exista el registro que desea actualizar'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION servicios.isp_detservicios(
    _op integer,
    _id_servicio bigint,
    _id_sucursal integer,
    _item integer,
    _id_detservicio bigint,
    _cantidad numeric,
    _imp_precio numeric,
    _imp_igv numeric,
    _porcent_igv numeric,
    _imp_dscto numeric,
    _imp_venta numeric,
    _imp_total numeric,
    _id_estado integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _imp_bruto numeric,
    _id_almacen integer,
    _r boolean,
    _a boolean,
    _l boolean,
    _s boolean,
    _lista integer,
    _observacion text,
    _descripcion_linea text,
    _id_usuario character)
  RETURNS text[] AS
$BODY$
DECLARE
	__id__detservicio bigint;
	__item integer; 
	_res text[];
BEGIN
if _op =1 then
	if exists(select 1 from SERVICIOS.TBL_SERVICIO where id_servicio=_id_servicio and  id_sucursal=_id_sucursal)then
		if exists( select 1  from  ALMACEN.TBL_PRECIO where id_producto=_id_producto and  id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
			select max(item) into __item from SERVICIOS.TBL_DETSERVICIO where id_servicio=_id_servicio and  id_sucursal=_id_sucursal;
			if __item is null then
				__item:=1;
			else
				__item:=__item+1;
			end if;
			select max(id_detservicio) into __id__detservicio from SERVICIOS.TBL_DETSERVICIO;
			if __id__detservicio is null then
				__id__detservicio:=1;
			else
				__id__detservicio:=__id__detservicio+1;
			end if;
			--RAISE NOTICE '', 'Ingresando';
			INSERT INTO servicios.tbl_detservicio(
				id_servicio, 
				id_sucursal, 
				item, 
				id_detservicio, 
				cantidad, 
				imp_precio, 
				imp_igv, 
				porcent_igv, 
				imp_dscto, 
				imp_venta, 
				imp_total, 
				id_estado, 
				id_producto, 
				id_unidadventa, 
				id_listaprecio, 
				imp_bruto, 
				id_almacen, 
				r, 
				a, 
				l, 
				s, 
				lista, 
				observacion, 
				descripcion_linea, 
				id_usuario_reg, 
				fecha_reg
			)
		    VALUES (				
				_id_servicio, 
				_id_sucursal, 
				__item, 
				__id__detservicio, 
				_cantidad, 
				_imp_precio, 
				_imp_igv, 
				_porcent_igv, 
				_imp_dscto, 
				_imp_venta, 
				_imp_total, 
				_id_estado, 
				_id_producto, 
				_id_unidadventa, 
				_id_listaprecio, 
				_imp_bruto, 
				_id_almacen, 
				_r, 
				_a, 
				_l, 
				_s, 
				_lista, 
				_observacion, 
				_descripcion_linea, 
				_id_usuario, 
				now()
			)returning array['0','Proceso efectuado con exito']into _res;
			IF NOT FOUND THEN
				_Res=array['505','Inconsistencia inesperada as registrar el detalle'];
			END IF;
		else
			_Res=array['504','Verefique que exista el producto seleccionado'];
		end if;
	else
		_res:=array['504','Verefique que exista la cabecera del servicio' || _id_servicio::text || '-' || _id_sucursal::text];
	end if;
end if;
if _op=2 then
	 RAISE NOTICE 'id_servicio %', _id_servicio;
	 RAISE NOTICE 'id_sucursal %', _id_sucursal;
	 RAISE NOTICE 'item  %', _item;
	 RAISE NOTICE 'id_detservicio  %', _id_detservicio;
	 RAISE NOTICE 'id_producto %', _id_producto;
	 RAISE NOTICE 'id_unidadventa %', _id_unidadventa;
	 RAISE NOTICE 'id_listaprecio %', _id_listaprecio;
	 
	if exists(select 1 from servicios.tbl_detservicio where id_servicio=_id_servicio and  
				id_sucursal=_id_sucursal and 
				item=_item and 
				id_detservicio=_id_detservicio and 
				id_producto=_id_producto and 
				id_unidadventa=_id_unidadventa and 
				id_listaprecio=_id_listaprecio)then
			if exists(select 1 from SERVICIOS.TBL_SERVICIO where id_servicio=_id_servicio and  id_sucursal=_id_sucursal)then
			if exists( select 1  from  ALMACEN.TBL_PRECIO where id_producto=_id_producto and  id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
				UPDATE servicios.tbl_detservicio
					SET 
						cantidad=_cantidad, 
						imp_precio=_imp_precio, 
						imp_igv=_imp_igv, 
						porcent_igv=_porcent_igv, 
						imp_dscto=_imp_dscto, 
						imp_venta=_imp_venta, 
						imp_total=_imp_total, 
						id_estado=_id_estado, 
						imp_bruto=_imp_bruto, 
						id_almacen=_id_almacen, 
						r=_r, 
						a=_a, 
						l=_l, 
						s=_s, 
						lista=_lista, 
						observacion=_observacion, 
						descripcion_linea=_descripcion_linea, 
						id_usuario_act=_id_usuario,  
						fecha_act=now()
				WHERE 	id_servicio=_id_servicio and  
					id_sucursal=_id_sucursal and 
					item=_item and 
					id_detservicio=_id_detservicio and 
					id_producto=_id_producto and 
					id_unidadventa=_id_unidadventa and 
					id_listaprecio=_id_listaprecio;
				_res:=array['0','Proceso efectuado con exito'];
			else
				_Res=array['504','Verefique que exista el producto seleccionado'];
			end if;
		else
			_res:=array['504','Verefique que exista la cabecera del servicio'];
		end if;
	else
		_res:=array['505','Verefique que exista el detalle del servicio'];
	end if;
	
end if;
return _res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from servicios.isp_grabar_servicios(1,0,1,'0001','0000001','2018-04-22 07:32:24.822',NULL,'2018-04-22 07:32:24.822','6:30','1',237,'0000000076',1,1,4,39,1,'1    ','',0,'3',1,0,0,'0.00','0.00','0.00','0.00','80.00',1,1,'1-1-1','','','111111',2013,0,1,0,NULL,0,'','',1,0,0,1)

CREATE OR REPLACE FUNCTION servicios.isp_grabar_servicios(
    op integer,
    _id_servicio bigint,
    _id_sucursal integer,
    _serie character,
    _numero character varying,
    _fec_servicio text,
    _fec_entrada text,
    _fec_tentativa_entrega text,
    _hora_tentativa_entrega character varying,
    _nro_ficha character,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_estacion integer,
    _id_prioridad integer,
    _id_tipo_servicio integer,
    _id_comprobante integer,
    _id_tipventa integer,
    _id_usuario character,
    _requerimiento text,
    _id_estado integer,
    _id_tecnico character varying,
    _id_operacion integer,
    _id_cita bigint,
    _id_sucursal_cita integer,
    _repuestos numeric,
    _accesorios numeric,
    _lubricantes numeric,
    _mano_obra numeric,
    _total numeric,
    _id_moneda integer,
    _id_igv integer,
    _id_usuario_servicio character,
    _informe text,
    _nro_serie character varying,
    _nro_chasis character varying,
    _anio_faricacion integer,
    _anio_modelo integer,
    _id_almacen integer,
    _id_serie bigint,
    _id_producto character varying,
    _id_unidadventa integer,
    _nro_placa character varying,
    _km text,
    _id_color integer,
    _id_modelo bigint,
    _id_srvserie bigint,
    _id_estadosrv integer)
  RETURNS text[] AS
$BODY$
DECLARE
	correl_serv numeric;
	res text[];
	__id__producto varchar(20);
	__id__unidad integer;
	__id__srvserie bigint;
	__id__servicio bigint;
	__id__sucursal integer;
	__id__serie bigint;
	_ressrv text[];
	__id__contacto bigint;
	__id__contacto__persona varchar(15);
	
BEGIN
	if op=1  then
		select max(id_servicio::numeric) into correl_serv from servicios.tbl_servicio;-- where id_tienda=_id_tienda AND ISNUMERIC(id_servicio);
		if correl_serv is null then
			correl_serv='1';
		else
			correl_serv:=correl_serv::numeric+1;
		end if;
		if not exists(select * from VENTAS.v_contactopersona cc where id_contacto =_id_usuario_servicio)then
			select max(id_contacpersona::bigint) into __id__contacto from ventas.tbl_contacpersona where isnumeric(id_contacpersona);
			if __id__contacto is null then
				__id__contacto:=1;
			else
				__id__contacto:=__id__contacto+1;
			end if;
			INSERT INTO ventas.tbl_contacpersona(
				id_contacpersona, 
				id_contacto, 
				id_persona, 
				tipo_contacto, 
				observaciones, 
				id_estado
			)
			VALUES (
				__id__contacto::text, 
				_id_usuario_servicio, 
				_id_cliente, 
				1, 
				'', 
				1
			) returning id_contacpersona into __id__contacto__persona;
		else
			__id__contacto__persona:=(select id_contacpersona from VENTAS.v_contactopersona cc where  id_contacto =_id_usuario_servicio limit 1);
		end if;
		if exists(select 1 from ventas.tbl_direccion where id_direccion=_id_direccion and id_persona=_id_cliente) then
			if exists (select *from planillas.tbl_persona where id_persona=_ID_TECNICO) then
				insert into servicios.tbl_servicio(
					id_servicio,
					id_sucursal,
					serie,
					numero,
					fecha_servicio,
					fecha_entrada,
					fecha_tentativa_entrega,
					hora_tentativa_entrega,
					nro_ficha,
					id_direccion,
					id_cliente,
					id_estacion_sucursal,
					id_prioridad,
					id_tipo_servicio,
					id_comprobante,
					id_tipoventa,
					fecha_act,
					id_usuario_reg,
					id_usuario_act,
					requerimiento,
					id_estado,
					ID_TECNICO,					
					id_operacion,
					id_cita,
					id_sucursal_cita,
					imp_REPUESTOS,
					imp_ACCESORIOS,
					imp_LUBRICANTES,
					imp_servicios,
					imp_total,
					id_moneda,
					id_igv,
					ID_USUARIO_SERVICIO,
					
					informe,
					id_estadosrv
				)values(
					correl_serv,
					_id_sucursal,
					_serie,
					_numero,
					to_timestamp(_fec_servicio,'YYYY-MM-DD HH24:MI:SS.MS'),
					to_timestamp(_fec_servicio,'YYYY-MM-DD HH24:MI:SS.MS'),--_fec_entrada
					to_timestamp(_fec_tentativa_entrega,'YYYY-MM-DD HH24:MI:SS.MS'),
					_hora_tentativa_entrega,
					_nro_ficha,
					_id_direccion,
					_id_cliente,
					_id_estacion,
					_id_prioridad::integer,
					_id_tipo_servicio,
					_id_comprobante,
					_id_tipventa,
					now(),
					_id_usuario,
					_id_usuario,
					_requerimiento,
					_id_estado,
					_ID_TECNICO,					
					_id_operacion,
					case when _id_cita=0 then null else _id_cita end ,
					_id_sucursal_cita,
					_REPUESTOS,
					_ACCESORIOS,
					_LUBRICANTES,
					_MANO_OBRA,
					_total,
					_id_moneda,
					_id_igv,
					__id__contacto__persona,
					_informe,
					_id_estadosrv
				) returning array['0',id_servicio::text,id_sucursal::text] into res;
				__id__servicio:=res[2]::bigint;
				__id__sucursal:=res[3]::integer;
				if  not found then
					res:=array['504','NO SE REALIZO NINGUNA OPERACION'];
				end if;
				if res[1]='0' then
					if exists(select 1 from servicios.tbl_servicio where id_servicio=res[2]::bigint and id_sucursal=res[3]::integer)then
						__id__producto:=(select dp.id_producto from almacen.tbl_detproducto dp
									inner join almacen.tbl_producto p on (p.id_producto=dp.id_producto)
									where id_color=_id_color and  id_modelo=_id_modelo limit 1);
						__id__unidad:=(select dp.id_unidadventa from almacen.tbl_detproducto dp
									inner join almacen.tbl_producto p on (p.id_producto=dp.id_producto)
									where id_color=_id_color and  id_modelo=_id_modelo limit 1);

						--if exists(select 1 from almacen.tbl_detproducto where id_producto=__id__producto and id_unidadventa=__id__unidad)then
							select max(id_serie) into __id__serie from almacen.tbl_serieproducto;
							if __id__serie is null then
								__id__Serie:=1;
							else
								__id__serie:=__id__serie+1;
							end if;	
							
							INSERT INTO almacen.tbl_serieproducto(
								nro_serie, 
								nro_chasis, 
								anio_faricacion, 
								anio_modelo, 
								id_almacen, 
								id_estado, 
								fecha_registro, 
								id_usuario_r, 
								id_serie, 
								id_producto, 
								id_unidadventa, 
								nro_placa
							)
							VALUES (
								_nro_serie, 
								_nro_chasis, 
								_anio_faricacion, 
								_anio_modelo, 
								_id_almacen, 
								_id_estado, 
								now(), 
								_id_usuario, 
								__id__serie, 
								__id__producto, 
								__id__unidad, 
								_nro_placa
							) returning array['0',id_serie::text] into res;
							if res[1]='0' then
								if exists (select 1 from almacen.tbl_color where id_color=_id_color)then
									if exists(select 1 from almacen.tbl_modelo where id_modelo=_id_modelo)then
										--RAISE NOTICE 'id_servicio %', res[2];
										--RAISE NOTICE 'id_sucursal %', i;
										if exists(select 1 from servicios.tbl_servicio where id_servicio=__id__servicio and id_sucursal=__id__sucursal)then
											select max(id_srvserie) into __id__srvserie from servicios.tbl_servicio_serie;
											if __id__srvserie is null then
												__id__srvserie:=1;
											else
												__id__srvserie:=__id__srvserie+1;
											end if;
											INSERT INTO servicios.tbl_servicio_serie(
												id_servicio, 
												id_sucursal, 
												id_serie, 
												id_srvserie, 
												fecha_reg, 
												id_usuario_reg, 
												km, 
												observacion, 
												id_color, 
												id_modelo
												)
											VALUES (
												__id__servicio, 
												__id__sucursal, 
												__id__serie, 
												__id__srvserie, 
												now(), 
												_id_usuario, 
												_km, 
												'',--_observacion, 
												_id_color, 
												_id_modelo
											) returning array['0',__id__servicio::text,__id__sucursal::text] into res;
										else
											res:=array['504','Verefique que exista el servicio'];
										end if;
									else
										res:=array['505','Verefique que exista el modelo'];
									end if;
								else
									res:=array['506','Verefique que exista el color'];
								end if;
							else
								res:=array['506','Verefique que los datos de la serie este ingresado correctamente'];
							end if;
						--else
						--	res:=array['506','Verefique que exista un producto asociado al modelo y marca del producto'];
						--end if;
					else
						res:=array['507','Verefique que los datos del servicio esten ingresados corretamente'];
					end if;
				else
					res:=array['508','Inconsistencia Inesperada al registrar el servicio'];
				end if;
			ELSE
				res:=array['505','NO HA SELECCIONADO NINGUN TECNICO PARA EL SERVICIO'];
			end if;
		ELSE
			res:=array['506','SELECCIONE CORRECTAMENTE EL CLIENTE'];
		end if;		
	end if;
	IF OP=2 THEN
		IF EXISTS(SELECT * FROM servicios.tbl_servicio WHERE id_servicio=_id_servicio and id_sucursal=_id_sucursal) THEN
			if not exists(select * from VENTAS.v_contactopersona cc where  id_contacto =TRIM(_id_usuario_servicio))then
				select max(id_contacpersona::bigint) into __id__contacto from ventas.tbl_contacpersona where isnumeric(id_contacpersona);
				if __id__contacto is null then
					__id__contacto:=1;
				else
					__id__contacto:=__id__contacto+1;
				end if;
				INSERT INTO ventas.tbl_contacpersona(
					id_contacpersona, 
					id_contacto, 
					id_persona, 
					tipo_contacto, 
					observaciones, 
					id_estado
				)
				VALUES (
					__id__contacto::text, 
					TRIM(_id_usuario_servicio), 
					_id_cliente, 
					1, 
					'', 
					1
				) returning id_contacpersona into __id__contacto__persona;
			else
				__id__contacto__persona:=(select id_contacpersona from VENTAS.v_contactopersona cc where  id_contacto =TRIM(_id_usuario_servicio) limit 1);
			end if;
			
			UPDATE servicios.tbl_servicio SET 
					serie=_serie,
					numero=_numero,
					fecha_servicio=to_timestamp(_fec_servicio,'YYYY-MM-DD HH24:MI:SS.MS'),
					fecha_entrada=to_timestamp(_fec_servicio,'YYYY-MM-DD HH24:MI:SS.MS'),--_fec_entrada
					fecha_tentativa_entrega=to_timestamp(_fec_tentativa_entrega,'YYYY-MM-DD HH24:MI:SS.MS'),
					hora_tentativa_entrega=_hora_tentativa_entrega,
					nro_ficha=_nro_ficha,
					id_direccion=_id_direccion,
					id_cliente=_id_cliente,
					id_estacion_sucursal=_id_estacion,
					id_prioridad=_id_prioridad::integer,
					id_tipo_servicio=_id_tipo_servicio,
					id_comprobante=_id_comprobante,
					id_tipoventa=_id_tipventa,
					fecha_act=NOW(),
					id_usuario_act=_id_usuario,
					requerimiento=_requerimiento,
					id_estado=_id_estado,
					ID_TECNICO=_ID_TECNICO,
					id_operacion=_id_operacion,
					id_cita=case when _id_cita=0 then null else _id_cita end,
					id_sucursal_cita=case when _id_sucursal_cita=0 then null else _id_sucursal_cita end,
					imp_REPUESTOS=_REPUESTOS,
					imp_ACCESORIOS=_ACCESORIOS,
					imp_LUBRICANTES=_LUBRICANTES,
					imp_servicios=_mano_obra,
					imp_total=_total,
					id_moneda=_id_moneda,
					id_igv=_id_igv,
					ID_USUARIO_SERVICIO=TRIM(__id__contacto__persona),--_ID_USUARIO_SERVICIO,
					informe=_informe
					WHERE id_servicio=_id_servicio AND id_sucursal=_id_sucursal returning array['0',id_servicio::text,id_sucursal::text] into res;
					__id__servicio:=res[2]::bigint;
					__id__sucursal:=res[3]::integer;
					if res[1]='0' then
						if exists(select 1 from servicios.tbl_servicio where id_servicio=__id__servicio and id_sucursal=__id__sucursal)then
							__id__producto:=(select dp.id_producto from almacen.tbl_detproducto dp
										inner join almacen.tbl_producto p on (p.id_producto=dp.id_producto)
										where id_color=_id_color and  id_modelo=_id_modelo limit 1);
							__id__unidad:=(select dp.id_unidadventa from almacen.tbl_detproducto dp
										inner join almacen.tbl_producto p on (p.id_producto=dp.id_producto)
										where id_color=_id_color and  id_modelo=_id_modelo limit 1);
								UPDATE almacen.tbl_serieproducto SET
									nro_serie=_nro_serie, 
									nro_chasis=_nro_chasis, 
									anio_faricacion=_anio_faricacion, 
									anio_modelo=_anio_modelo, 
									id_almacen=_id_almacen, 
									id_estado=_id_estado, 
									fecha_actualiza=now(), 
									id_usuario_a=_id_usuario, 
									id_producto=__id__producto, 
									id_unidadventa=__id__unidad, 
									nro_placa=_nro_placa
								where id_serie=_id_serie returning array['0',id_serie::text] into _ressrv;
								__id__serie:=_id_serie;
								 RAISE NOTICE 'id_serie %', __id__serie;
								if _ressrv[1]='0' then
									if exists (select 1 from almacen.tbl_color where id_color=_id_color)then
										if exists(select 1 from almacen.tbl_modelo where id_modelo=_id_modelo)then
											if exists(select 1 from servicios.tbl_servicio where id_servicio=__id__servicio and id_sucursal=__id__sucursal)then
												delete from servicios.tbl_servicio_serie where id_servicio=__id__servicio and id_sucursal=__id__sucursal and id_serie=__id__serie;
												
												select max(id_srvserie) into __id__srvserie from servicios.tbl_servicio_serie;
												if __id__srvserie is null then
													__id__srvserie:=1;
												else
													__id__srvserie:=__id__srvserie+1;
												end if;
												INSERT INTO servicios.tbl_servicio_serie(
													id_servicio, 
													id_sucursal, 
													id_serie, 
													id_srvserie, 
													fecha_reg, 
													id_usuario_reg, 
													km, 
													observacion, 
													id_color, 
													id_modelo
													)
												VALUES (
													__id__servicio, 
													__id__sucursal, 
													__id__serie, 
													__id__srvserie, 
													now(), 
													_id_usuario, 
													_km, 
													'',--_observacion, 
													_id_color, 
													_id_modelo
												) returning array['0',__id__serie::text,__id__sucursal::text] into res;
											else
												res:=array['504','Verefique que exista el servicio'];
											end if;
										else
											res:=array['505','Verefique que exista el modelo'];
										end if;
									else
										res:=array['506','Verefique que exista el color'];
									end if;
								else
									res:=array['506','Verefique que los datos de la serie este ingresado correctamente'];
								end if;
							--else
							--	res:=array['506','Verefique que exista un producto asociado al modelo y marca del producto'];
							--end if;
						else
							res:=array['507','Verefique que los datos del servicio esten ingresados corretamente'];
						end if;
					else
						res:=array['508','Inconsistencia Inesperada al registrar el servicio'];
					end if;
					--RES:=ARRAY['0',_id_servicio::text,_id_sucursal::text];
					/*IF NOT FOUND THEN
						RES:=ARRAY['504','INCONSISTENCIA INESPERADO AL ACTULIZAR SERVICIOS'];
					END IF;*/
		ELSE
			RES:=ARRAY['505','SELECCIONE CORRECTAMENTE EL SERVICIO QUE ESTA ACTUALIZANDO'];
		END IF;
	END IF;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION almacen.isp_serieventa(
    op integer,
    __id_serieventa bigint,
    __id_sucursal integer,
    __id_facturacion bigint,
    __id_almacen integer,
    __id_serie bigint,
    __item integer,
    __fecha_venta text,
    __id_usuario character,
    __id_estado integer,
    __observacion text)
  RETURNS text[] AS
$BODY$
declare
	__res text[];
	__id bigint;
begin
if op=1 then
	if exists(select 1 from almacen.tbl_serieproducto where id_serie=__id_serie)then
		if exists(select 1 from ventas.tbl_facturacion f  where f.id_facturacion=__id_facturacion and id_sucursal=__id_sucursal)then
			
			select max(id_serieventa) into __id from almacen.tbl_serieventa;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			INSERT INTO almacen.tbl_serieventa(
				fecha_venta, 
				fecha_reg, 
				id_usuario_r, 
				id_estado, 
				id_sucursal, 
				id_facturacion, 
				id_almacen, 
				id_serie, 
				item, 
				observacion, 
				id_serieventa
			)
			VALUES (
				__fecha_venta::timestamp, 
				now(), 
				__id_usuario, 
				__id_estado, 
				__id_sucursal, 
				__id_facturacion, 
				__id_almacen, 
				__id_serie, 
				__item, 
				__observacion, 
				__id
			)returning array['0',id_serie::text] into __res;
			if not found then
				__res=array['504','Inconsistencia inesperad al asociar la venta con serie'];
			end if;
			update almacen.tbl_serieproducto set id_estado=__id_estado where id_serie=__id_serie;
		else
			__res:=array['503','Verefique que exista el documento de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.tbl_serieventa where id_serieventa=__id_serieventa)then
		update almacen.tbl_serieventa set id_estado=__id_estado where id_serieventa=__id_serieventa;
		update almacen.tbl_serieproducto set id_estado=case when __id_estado<>18 then 1 else 18 end where id_serie=__id_serie;
		__res:=array['0',__id_serie::text];
	else
		__res:=almacen.isp_serieventa(
			1,
			__id_serieventa,
			__id_sucursal,
			__id_facturacion,
			__id_almacen ,
			__id_serie,
			__item,
			__fecha_venta,
			__id_usuario,
			__id_estado,	
			__observacion
			);
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  



CREATE OR REPLACE FUNCTION almacen.isp_serienotasalida(
    op integer,
    __id_serieventa bigint,
    __id_sucursal integer,
    __id_facturacion bigint,
    __id_almacen integer,
    __id_serie bigint,
    __item integer,
    __fecha_venta text,
    __id_usuario character,
    __id_estado integer,
    __observacion text)
  RETURNS text[] AS
$BODY$
declare
	__res text[];
	__id bigint;
begin
if op=1 then
	if exists(select 1 from almacen.tbl_serieproducto where id_serie=__id_serie)then
		if exists(select 1 from almacen.tbl_cabmovalm f  where f.id_movimiento=__id_facturacion )then
			
			select max(id_serieventa) into __id from almacen.tbl_serieventa;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			INSERT INTO almacen.tbl_serienotasalida(
				fecha_venta, 
				fecha_reg, 
				id_usuario_r, 
				id_estado, 
				id_sucursal, 
				id_notasalida, 
				id_almacen, 
				id_serie, 
				item, 
				observacion, 
				id_serieventa
			)
			VALUES (
				__fecha_venta::timestamp, 
				now(), 
				__id_usuario, 
				__id_estado, 
				__id_sucursal, 
				__id_facturacion, 
				__id_almacen, 
				__id_serie, 
				__item, 
				__observacion, 
				__id
			)returning array['0',id_serie::text] into __res;
			if not found then
				__res=array['504','Inconsistencia inesperad al asociar la venta con serie'];
			end if;
			update almacen.tbl_serieproducto set id_estado=__id_estado where id_serie=__id_serie;
		else
			__res:=array['503','Verefique que exista el documento de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.tbl_serienotasalida where id_serieventa=__id_serieventa)then
		update almacen.tbl_serienotasalida set id_estado=__id_estado where id_serieventa=__id_serieventa;
		update almacen.tbl_serieproducto set id_estado=case when __id_estado<>18 then 1 else 18 end where id_serie=__id_serie;
		__res:=array['0',__id_serie::text];
	else
		__res:=almacen.isp_serienotasalida(
			1,
			__id_serieventa,
			__id_sucursal,
			__id_facturacion,
			__id_almacen ,
			__id_serie,
			__item,
			__fecha_venta,
			__id_usuario,
			__id_estado,	
			__observacion
			);
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  


CREATE OR REPLACE FUNCTION almacen.isp_serieguia(
    op integer,
    __id_serieguia bigint,
    __id_sucursal integer,
    __id_guia bigint,
    __id_almacen integer,
    __id_almacendestino integer,
    __id_serie bigint,
    __item integer,
    __fecha_venta text,
    __id_usuario character,
    __id_estado integer,
    __observacion text)
  RETURNS text[] AS
$BODY$
declare
	__res text[];
	__id bigint;
begin
if op=1 then
	if exists(select 1 from almacen.tbl_serieproducto where id_serie=__id_serie)then
		if exists(select * from ventas.tbl_guiaremisionventa f  where f.id_guia=__id_guia and id_sucursal=__id_sucursal)then
			
			--select *from almacen.tbl_serieguia 
			INSERT INTO almacen.tbl_serieguia(
				fecha_venta, 
				fecha_reg, 
				id_usuario_r, 
				id_estado, 
				id_sucursal, 
				id_guia, 
				id_almacen, 
				id_serie, 
				item, 
				observacion,
				id_almacendestino
			)
			VALUES (
				__fecha_venta::timestamp, 
				now(), 
				__id_usuario, 
				__id_estado, 
				__id_sucursal, 
				__id_guia, 
				__id_almacen, 
				__id_serie, 
				__item, 
				__observacion,
				__id_almacendestino
			)returning array['0',id_serie::text] into __res;
			UPDATE almacen.tbl_Serieproducto set id_almacen=CASE WHEN __id_almacendestino=0 THEN __id_almacen ELSE __id_almacendestino END   where id_serie=__id_serie;
			if not found then
				__res=array['504','Inconsistencia inesperad al asociar la venta con serie'];
			end if;
			---if (exists)
			--update almacen.tbl_serieproducto set id_estado=__id_estado where id_serie=__id_serie;
		else
			__res:=array['503','Verefique que exista el documento de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.tbl_serieguia where id_serieguia=__id_serieguia)then
		update almacen.tbl_serieguia set id_estado=__id_estado where id_serieguia=__id_serieguia;
		--update almacen.tbl_serieproducto set id_estado=case when __id_estado<>18 then 1 else 18 end where id_serie=__id_serie;
		__res:=array['0',__id_serie::text];
	else
		__res:=almacen.isp_serieguia(
			1,
			__id_serieguia,
			__id_sucursal,
			__id_guia,
			__id_almacen ,
			__id_serie,
			__item,
			__fecha_venta,
			__id_usuario,
			__id_estado,	
			__observacion,
			__id_almacendestino
			);
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  


CREATE OR REPLACE FUNCTION almacen.isp_serieventa_nc(
    op integer,
    __id_serieventa bigint,
    __id_sucursal integer,
    __id_facturacion bigint,
    __id_almacen integer,
    __id_serie bigint,
    __item integer,
    __fecha_venta text,
    __id_usuario character,
    __id_estado integer,
    __observacion text,
    __id_motivo char(2)
    )
  RETURNS text[] AS
$BODY$
declare
	__res text[];
	__id bigint;
begin
if op=1 then
	if exists(select 1 from almacen.tbl_serieproducto where id_serie=__id_serie)then
		if exists(select 1 from ventas.tbl_facturacion f  where f.id_facturacion=__id_facturacion and id_sucursal=__id_sucursal)then
			
			select max(id_serieventa) into __id from almacen.tbl_serieventa;
			if __id is null then
				__id:=1;
			else
				__id:=__id+1;
			end if;
			if exists( select *from common.tbl_motivonotacredito where id_motivonotacredito in('01','02','03','06','07') and id_motivonotacredito=__id_motivo) then
				update almacen.tbl_serieproducto set id_estado= 1  where id_serie=__id_serie;
			end if;
			INSERT INTO almacen.tbl_serieventa(
				fecha_venta, 
				fecha_reg, 
				id_usuario_r, 
				id_estado, 
				id_sucursal, 
				id_facturacion, 
				id_almacen, 
				id_serie, 
				item, 
				observacion, 
				id_serieventa
			)
			VALUES (
				__fecha_venta::timestamp, 
				now(), 
				__id_usuario, 
				__id_estado, 
				__id_sucursal, 
				__id_facturacion, 
				__id_almacen, 
				__id_serie, 
				__item, 
				__observacion, 
				__id
			)returning array['0',id_serie::text] into __res;
			if not found then
				__res=array['504','Inconsistencia inesperad al asociar la venta con serie'];
			end if;
			--update almacen.tbl_serieproducto set id_estado=__id_estado where id_serie=__id_serie;
		else
			__res:=array['503','Verefique que exista el documento de venta'];
		end if;
	else
		__res:=array['504','Verefique que exista el Nro.serie'];
	end if;
end if;
if op=2 then
	if exists(select 1 from almacen.tbl_serieventa where id_serieventa=__id_serieventa)then
		update almacen.tbl_serieventa set id_estado=__id_estado,fecha_act=now(),id_usuario_a=__id_usuario where id_serieventa=__id_serieventa;
		--update almacen.tbl_serieproducto set id_estado=case when __id_estado<>18 then 1 else 18 end where id_serie=__id_serie;
		__res:=array['0',__id_serie::text];
	else
		/*__res:=almacen.isp_serieventa(
			1,
			__id_serieventa,
			__id_sucursal,
			__id_facturacion,
			__id_almacen ,
			__id_serie,
			__item,
			__fecha_venta,
			__id_usuario,
			__id_estado,	
			__observacion
			);*/
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  
select *from almacen.tbl_serieventa  
select *from common.tbl_motivonotacredito

CREATE OR REPLACE FUNCTION ventas.spi_facunidadvehicular(
    op integer,
    _id_facturacion integer,
    _numdoc_facturacion character,
    _id_detatencion character,
    _id_tipoventa integer,
    _id_tipocambio integer,
    _id_igv integer,
    _id_direccion bigint,
    _id_pedido character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _serie_facturacion character,
    _fecha_venta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _imp_neto numeric,
    _imp_igv numeric,
    _imp_redondeo numeric,
    _imp_total numeric,
    _tasa_persepcion numeric,
    _valor_venta numeric,
    _id_moneda integer,
    _id_estado integer,
    _id_cliente character varying,
    _id_operacion integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_sucursalpreventa integer,
    _id_vendedor character varying,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _id_unidad character varying,
    _modelo text,
    _placa text,
    _color text,
    _marca text,
    _imp_xdia numeric)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
        dat record;
        res_mov boolean;
	rec_item record;
begin
if op=1 then
	if not exists(select *from ventas.tbl_facturacion where 
				numdoc_facturacion=_numdoc_facturacion and 
				serie_facturacion=_serie_facturacion and  id_comprobante=_id_comprobante ) then
		if exists(select *from planillas.tbl_persona where id_persona=_id_vendedor) then
			select max(id_facturacion) into correl from ventas.tbl_facturacion where id_sucursal=_id_sucursal;
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
				end if;
				insert into ventas.tbl_facturacion(
						id_facturacion,
						numdoc_facturacion,
						id_detatencion,
						id_tipoventa,
						id_tipocambio,
						id_igv,
						id_direccion,
						id_pedido   ,
						id_comprobante ,
						id_tranzaccion ,
						serie_facturacion,
						fecha_venta      ,
						imp_bruto        ,
						imp_dscto        ,
						imp_neto         ,
						imp_igv          ,
						imp_redondeo     ,
						imp_total        ,
						tasa_persepcion  ,
						valor_venta  ,
						id_moneda        ,
						id_estado        ,
						id_cliente       ,
						id_operacion     ,
						id_sucursal,
						id_cotizapreventa ,
						id_sucursalpreventa ,
						id_vendedor,
						DNI_CLIENTE ,
						NOMAPE_CLIENTE,
						DIRECCION_CLIENTE,
						ID_UNIDAD,
						MODELO,
						PLACA,
						COLOR,
						MARCA,
						imp_xdia
						
				)values(
						correl,
						_numdoc_facturacion,
						_id_detatencion,
						_id_tipoventa,
						_id_tipocambio,
						_id_igv,
						_id_direccion,
						_id_pedido   ,
						_id_comprobante ,
						_id_tranzaccion ,
						_serie_facturacion,
						to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS')      ,
						_imp_bruto        ,
						_imp_dscto        ,
						_imp_neto         ,
						_imp_igv          ,
						_imp_redondeo     ,
						_imp_total        ,
						_tasa_persepcion  ,
						_valor_venta ,
						_id_moneda        ,
						_id_estado        ,
						_id_cliente       ,
						_id_operacion     ,
						_id_sucursal,
						case when _id_cotizapreventa=0 then null else _id_cotizapreventa end  ,
						case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end,
						_id_vendedor,
						_DNI_CLIENTE ,
						_NOMAPE_CLIENTE,
						_DIRECCION_CLIENTE,
						_ID_UNIDAD,
						_MODELO,
						_PLACA,
						_COLOR,
						_MARCA,
						_imp_xdia
				) returning array['0',tbl_facturacion.id_facturacion::text, 
						tbl_facturacion.id_sucursal::text
						]into res;
					
				if not found then
					res:=array['504','Ocurrio un error al registar el documento de venta\n verefique que los datos esten ingresados correctamente'];
				end if;
				update ventas.tbl_items set id_facturacion=cast(res[2] as integer), id_sucursalfac=cast(res[3] as integer) 
					where id_cotizapreventa=_id_cotizapreventa;
			else
				res:=array['501','Seleccione correctamente el cliente'];
			end if;
		else
			res:=array['502','Seleccione correctamente el vendedor'];
			--exit;
		end if;
	else
		res:=array['504','El documento con serie ' || _serie_facturacion ||' Nro : ' || _numdoc_facturacion || ' ya se encuentran registrados'];
		--exit;
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		
			update ventas.tbl_facturacion set 
						numdoc_facturacion=_numdoc_facturacion,
						id_detatencion=_id_detatencion,
						id_tipoventa=_id_tipoventa,
						id_tipocambio=_id_tipocambio,
						id_igv=_id_igv,
						id_direccion=_id_direccion,
						id_pedido=_id_pedido,
						id_comprobante=_id_comprobante ,
						id_tranzaccion=_id_tranzaccion ,
						serie_facturacion=_serie_facturacion,
						fecha_venta=to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
						imp_bruto=_imp_bruto,
						imp_dscto=_imp_dscto,
						imp_neto=_imp_neto,
						imp_igv=_imp_igv,
						imp_redondeo=_imp_redondeo,
						imp_total=_imp_total,
						tasa_persepcion=_tasa_persepcion,
						valor_venta=_valor_venta,
						id_moneda=_id_moneda,
						id_estado=_id_estado,
						id_cliente=_id_cliente,
						id_operacion=_id_operacion,
						id_cotizapreventa=case when _id_cotizapreventa=0 then null else _id_cotizapreventa end ,
						id_sucursalpreventa=case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end ,
						id_vendedor=_id_vendedor,
						DNI_CLIENTE=_DNI_CLIENTE ,
						NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
						DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
						ID_UNIDAD=_ID_UNIDAD,
						MODELO=_MODELO,
						PLACA=_PLACA,
						COLOR=_COLOR,
						MARCA=_MARCA,
						imp_xdia=_imp_xdia
						where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						res:=array['0',_id_facturacion::text,_id_sucursal::text];
			if _id_tipoventa=2 then
				for dat in select *from  creditos.tbl_ventacredito where id_facturacion=_id_facturacion loop
					if exists(select *from creditos.tbl_detpagocuota dpc 
						where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito and id_estado=1) then
						res_mov=true;
					else
						res_mov=false;						
					end if;
					if res_mov=false then
						delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
						delete from creditos.tbl_cuota cc where cc.id_credito=dat.id_credito and  cc.id_sucursal_credito=dat.id_sucursal_credito;
						delete from creditos.tbl_credito c where c.id_credito=dat.id_credito and  c.id_sucursal_credito=dat.id_sucursal_credito;
					end if;
				end loop;
				if res_mov=true then
					res:=Array['506','Existe movimientos de caja, en cuentas por cobrar \n primero anule los movimientos de caja y luego realice este proceso'];		
				end if;
				/*if res=false then
					delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
				end if;	*/			
			end if;
		
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
RETURN RES;
end;$BODY$
  LANGUAGE plpgsql VOLATILE



CREATE OR REPLACE FUNCTION ventas.isp__unidad__vehicular(
    _op integer,
    _id_unidadtransporte integer,
    _id_sucursal integer,
    _placa character varying,
    _capacidad numeric,
    _modelo character varying,
    _marca character varying,
    _id_estado integer,
    _color character varying,
    _id_producto varchar(20)
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
	CORREL INTEGER;
BEGIN
IF _OP=1 THEN
	IF NOT EXISTS(SELECT 1 FROM VENTAS.TBL_UNIDADTRANSPORTE WHERE PLACA=_PLACA) THEN
		SELECT MAX(ID_UNIDADTRANSPORTE) INTO CORREL FROM VENTAS.TBL_UNIDADTRANSPORTE;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		INSERT INTO ventas.tbl_unidadtransporte(
			    id_unidadtransporte, 
			    id_sucursal, 
			    placa, 
			    capacidad, 
			    modelo, 
			    marca, 
			    id_estado,
			    COLOR,
			    id_producto
			    )
		    VALUES (
			    correl, 
			    _id_sucursal, 
			    _placa, 
			    _capacidad, 
			    _modelo, 
			    _marca, 
			    _id_estado,
			    _COLOR,
			    _id_producto
		    ) returning array['0',id_unidadtransporte::text] into res;
		    if not found then
			res:=array['503','Inconsitencia inesperada la registrar'];
		    end if;
	ELSE
		RES:=ARRAY['504','Ya existe un registro con el numero de placa ingresado'];
	END IF;
END IF;
IF _OP=2 THEN
	if exists(select *from ventas.tbl_unidadtransporte where id_unidadtransporte=_id_unidadtransporte)then
		UPDATE ventas.tbl_unidadtransporte
		   SET 
			id_sucursal=_id_sucursal, 
			placa=_placa, 
			capacidad=_capacidad, 
			modelo=_modelo, 
		       marca=_marca, 
		       id_estado=_id_estado,
		       COLOR=_COLOR,
		       id_producto=_id_producto
		 WHERE id_unidadtransporte=_id_unidadtransporte;
		 res:=array['0',_ID_UNIDADTRANSPORTE::text];
	else
		res:=array['503','Seleccione correctamente el registro'];
	end if;
END IF;
return res;
END;$BODY$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION VENTAS.fn_rentabilidad_x_cliente(
	 op integer,
	 _id_empresa integer,
	 _f_desde varchar(50),
	 _f_hasta varchar(50)
)
returns table(
	cliente varchar(100) ,	
	imp_venta numeric(20,4),	
	imp_costo numeric(14,4),
	utilidad numeric(14,4),
	porcent_rent numeric(20,2)
)
as  $$
declare 
BEGIN
return query SELECT 
CLI.NOMBRE_RAZON AS CLIENTE,
SUM(TOTAL_VENTA)::numeric(20,4) AS IMP_VENTA,
SUM(TOTAL_COMPRA)::numeric(20,4) AS IMP_COSTO,
(SUM(TOTAL_VENTA)-SUM(TOTAL_COMPRA))::numeric(20,4) as utilidad,
(((SUM(TOTAL_VENTA)-SUM(TOTAL_COMPRA))*100)/CASE WHEN SUM(TOTAL_COMPRA)>0 THEN SUM(TOTAL_COMPRA) ELSE 1 END )::numeric(20,2) AS porcen_utilidad
 FROM (SELECT 
P.ID_PRODUCTO,
P.DESCRIPCION_LARGA AS PRODUCTO,
FA.DESCRIPCION_LARGA AS FAMILIA,
M.DESCRIPCION_LARGA AS MARCA,
U.DESC_LARGA AS UNIDAD,
DP.VAL_UNIDAD AS VALOR,
SUM(DF.CANTIDAD) AS CANTIDAD,
AVG(DF.PRECIO) AS PRECIO,
AVG(DF.PRECIO)*SUM(DF.CANTIDAD) AS TOTAL_VENTA,
dp.coste AS precio_compra,
dp.coste*SUM(DF.CANTIDAD) as total_compra,
f.id_cliente
FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL  
where f.id_estado=1 and df.id_estado=1 AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE BETWEEN _f_desde::DATE AND _f_hasta::DATE
GROUP BY P.ID_PRODUCTO,
P.DESCRIPCION_LARGA ,
Fa.DESCRIPCION_LARGA ,
M.DESCRIPCION_LARGA ,
U.DESC_LARGA ,
DP.VAL_UNIDAD,
dp.id_producto,
dp.id_unidadventa,
dp.coste,
f.id_cliente
ORDER BY Fa.DESCRIPCION_LARGA
) X
INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=X.ID_CLIENTE
GROUP BY CLI.NOMBRE_RAZON;
END;$$
LANGUAGE 'plpgsql';


select *from  ventas.fn_rentabilidad_x_vendedor(1,1,'01/01/2019','01/12/2020');


CREATE OR REPLACE FUNCTION ventas.fn_rentabilidad_x_vendedor(
	 op integer,
	 _id_empresa integer,
	 _f_desde varchar(50),
	 _f_hasta varchar(50)
)
returns table(
	cliente varchar(100) ,	
	imp_venta numeric(20,4),	
	imp_costo numeric(14,4),
	utilidad numeric(14,4),
	porcent_rent numeric(20,2)
)
as  $$
declare 
BEGIN
return query SELECT 
CLI.NOMBRE_RAZON AS CLIENTE,
SUM(TOTAL_VENTA)::numeric(20,4) AS IMP_VENTA,
SUM(TOTAL_COMPRA)::numeric(20,4) AS IMP_COSTO,
(SUM(TOTAL_VENTA)-SUM(TOTAL_COMPRA))::numeric(20,4) as utilidad,
(((SUM(TOTAL_VENTA)-SUM(TOTAL_COMPRA))*100)/CASE WHEN SUM(TOTAL_COMPRA)>0 THEN SUM(TOTAL_COMPRA) ELSE 1 END )::numeric(20,2) AS porcen_utilidad
 FROM (SELECT 
P.ID_PRODUCTO,
P.DESCRIPCION_LARGA AS PRODUCTO,
FA.DESCRIPCION_LARGA AS FAMILIA,
M.DESCRIPCION_LARGA AS MARCA,
U.DESC_LARGA AS UNIDAD,
DP.VAL_UNIDAD AS VALOR,
SUM(DF.CANTIDAD) AS CANTIDAD,
AVG(DF.PRECIO) AS PRECIO,
AVG(DF.PRECIO)*SUM(DF.CANTIDAD) AS TOTAL_VENTA,
dp.coste AS precio_compra,
dp.coste*SUM(DF.CANTIDAD) as total_compra,
f.id_cliente,
f.id_vendedor
FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL  
where f.id_estado=1 and df.id_estado=1 AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE BETWEEN _f_desde::DATE AND _f_hasta::DATE
GROUP BY P.ID_PRODUCTO,
P.DESCRIPCION_LARGA ,
Fa.DESCRIPCION_LARGA ,
M.DESCRIPCION_LARGA ,
U.DESC_LARGA ,
DP.VAL_UNIDAD,
dp.id_producto,
dp.id_unidadventa,
dp.coste,
f.id_cliente,
f.id_vendedor
ORDER BY Fa.DESCRIPCION_LARGA
) X
INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=X.id_vendedor
GROUP BY CLI.NOMBRE_RAZON;
END;$$
LANGUAGE 'plpgsql';


select * from ventas.fn_rentabilidad_x_producto(1,1,'01/10/2018','31/10/2018','001  ')
select *from almacen.tbl_detproducto

select * from ventas.fn_rentabilidad_x_producto(1,1,'29/05/2017','29/05/2020','172  ')



CREATE OR REPLACE FUNCTION VENTAS.fn_rentabilidad_x_producto(
	 op integer,
	 _id_empresa integer,
	 _f_desde varchar(50),
	 _f_hasta varchar(50),
	 _id_familia varchar(5)
)
returns table(
	id_producto varchar(20),
	producto varchar(200),
	familia varchar(100),
	marca varchar(100),
	unidad varchar(60),
	valor numeric(14,6),
	cantidad numeric(20,4),
	precio numeric(20,4),
	total_venta numeric(20,4),
	precio_compra numeric(14,4),
	total_compra numeric(14,4),
	codigo text,
	cod_barra text
)
  as $$
  declare
  begin
  if op=1 then
	return query SELECT 
		P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		M.DESCRIPCION_LARGA AS MARCA,
		U.DESC_LARGA AS UNIDAD,
		DP.VAL_UNIDAD AS VALOR,
		SUM(x.cantidad)-COALESCE(Z.CANTIDAD,0) AS CANTIDAD,
		sum(df.importe)/sum((CASE
                                    WHEN (x.cantidad > (0)::numeric) THEN x.cantidad
                                    ELSE (1)::numeric
                                END)) AS PRECIO,
		SUM(DF.importe)-COALESCE(Z.IMPORTE,0) AS TOTAL_VENTA,
		dp.coste AS precio_compra,
		dp.coste*SUM(x.cantidad) as total_compra,
		p.codigo::text as codigo,
		DDP.codigo_barra::text as codigo_barra
		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
		INNER JOIN ALMACEN.TBL_DETPRODUCTO DDP ON(DDP.ID_PRODUCTO=DF.ID_PRODUCTO and ddp.unidad_inventario=true)
		JOIN LATERAL almacen.fn_stock(df.id_producto, df.id_unidadventa, df.id_almacen, df.cantidad) x(product_id, unit_id, val_unit, stock, cantidad) ON (((x.product_id)::text = (ddp.id_producto)::text))
		inner join ALMACEN.TBL_PRECIO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=X.UNIT_ID
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
		INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
		INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
		JOIN almacen.tbl_unidad u ON ((u.id_unidadventa = x.unit_id))
		INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL
		LEFT JOIN (SELECT 
				FF.ID_FACTURACIONREF AS ID_FACTURACION,
				FF.ID_SUCURSALREF AS ID_SUCURSAL,
				DFF.ID_PRODUCTO,DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO AS _ID_PRODUCTO ,
				SUM(DFF.CANTIDAD) AS CANTIDAD,
				SUM(DFF.importe)  AS IMPORTE				
			FROM VENTAS.TBL_FACTURACION FF 
			INNER JOIN VENTAS.TBL_DETFACTURACION DFF ON FF.ID_FACTURACION =DFF.ID_FACTURACION AND FF.ID_SUCURSAL=DFF.ID_SUCURSAL
			WHERE FF.NOTA_CREDITO=TRUE
			GROUP BY 
			        FF.ID_FACTURACIONREF,
				FF.ID_SUCURSALREF,
				DFF.ID_PRODUCTO,
				DFF.ID_UNIDADVENTA,
				DFF.ID_PRODUCTO 
			) Z ON Z.ID_FACTURACION=F.ID_FACTURACION AND Z.ID_SUCURSAL=F.ID_SUCURSAL AND DF.ID_PRODUCTO=Z._ID_PRODUCTO AND Z.ID_UNIDADVENTA=DF.ID_UNIDADVENTA	 
		where f.id_estado=1 and df.id_estado=1 
		AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE>=_f_desde::DATE AND F.FECHA_VENTA::DATE<=_f_hasta::DATE AND F.NOTA_CREDITO=FALSE
		--AND F.ID_FACTURACION::TEXT || F.ID_SUCURSAL::TEXT NOT IN (SELECT FF.ID_FACTURACIONREF::TEXT || FF.ID_SUCURSALREF::TEXT FROM VENTAS.TBL_FACTURACION FF WHERE FF.NOTA_CREDITO=TRUE and ff.id_estado=1 )
		GROUP BY P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA ,
		Fa.DESCRIPCION_LARGA ,
		M.DESCRIPCION_LARGA ,
		U.DESC_LARGA ,
		DP.VAL_UNIDAD,
		dp.id_producto,
		dp.id_unidadventa,
		dp.coste,
		z.cantidad,z.importe,DDP.codigo_barra
		ORDER BY Fa.DESCRIPCION_LARGA;
end if;
if op=2 then
	return query SELECT 
		P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		M.DESCRIPCION_LARGA AS MARCA,
		U.DESC_LARGA AS UNIDAD,
		DP.VAL_UNIDAD AS VALOR,
		SUM(DF.CANTIDAD) AS CANTIDAD,
		AVG(DF.PRECIO) AS PRECIO,
		AVG(DF.PRECIO)*SUM(DF.CANTIDAD) AS TOTAL_VENTA,
		dp.coste AS precio_compra,
		dp.coste*SUM(DF.CANTIDAD) as total_compra,
		p.codigo::text as codigo,
		DDP.codigo_barra::text as codigo_barra
		FROM VENTAS.TBL_FACTURACION F
		INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION and f.id_sucursal=df.id_sucursal)
		INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
		INNER JOIN ALMACEN.TBL_DETPRODUCTO DDP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DDP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
		INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
		INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
		INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
		INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)  
		INNER JOIN COMMON.TBL_SUCURSAL SUC ON SUC.ID_SUCURSAL=F.ID_SUCURSAL
		where f.id_estado=1 and df.id_estado=1 and fa.id_familia=_id_familia AND SUC.ID_EMPRESA=_ID_EMPRESA AND F.FECHA_VENTA::DATE BETWEEN _f_desde::DATE AND _f_hasta::DATE
		GROUP BY P.ID_PRODUCTO,
		P.DESCRIPCION_LARGA ,
		Fa.DESCRIPCION_LARGA ,
		M.DESCRIPCION_LARGA ,
		U.DESC_LARGA ,
		DP.VAL_UNIDAD,
		dp.id_producto,
		dp.id_unidadventa,
		dp.coste,DDP.codigo_barra
		ORDER BY Fa.DESCRIPCION_LARGA;
end if;
  end;$$
  language 'plpgsql';



select *

CREATE OR REPLACE FUNCTION ventas.cur_utiliadesproducto(
    refcursor,
    condiventas text,
    condicompra text,
    text)
  RETURNS refcursor AS
$BODY$
declare
cad text;
begin
  cad='
SELECT 
P.ID_PRODUCTO,
P.DESCRIPCION_LARGA AS PRODUCTO,
FA.DESCRIPCION_LARGA AS FAMILIA,
M.DESCRIPCION_LARGA AS MARCA,
U.DESC_LARGA AS UNIDAD,
DP.VAL_UNIDAD AS VALOR,
SUM(DF.CANTIDAD) AS CANTIDAD,
AVG(DF.PRECIO) AS PRECIO,
AVG(DF.PRECIO)*SUM(DF.CANTIDAD) AS TOTAL_VENTA,
COALESCE((select avg(dc.precio)from COMPRAS.TBL_COMPRA C INNER JOIN  compras.tbl_detcompra dc ON(C.id_sucursalcompra=DC.id_sucursalcompra AND  C.anio=DC.anio AND  C.id_compra=DC.id_compra AND  C.id_mes=DC.id_mes)
where dp.id_producto =dc.id_producto and DP.ID_UNIDADVENTA=Dc.ID_UNIDADVENTA ' || condicompra ||'),0) as precio_compra,
COALESCE((select avg(dc.precio) from COMPRAS.TBL_COMPRA C INNER JOIN  compras.tbl_detcompra dc ON (C.id_sucursalcompra=DC.id_sucursalcompra AND  C.anio=DC.anio AND  C.id_compra=DC.id_compra AND  C.id_mes=DC.id_mes)
where dP.id_producto =dC.id_producto and dp.ID_UNIDADVENTA=DC.ID_UNIDADVENTA ' || condicompra ||'),0)*sum(df.cantidad) as total_compra
FROM VENTAS.TBL_FACTURACION F
INNER JOIN VENTAS.TBL_DETFACTURACION DF ON (F.ID_FACTURACION=DF.ID_FACTURACION)
INNER JOIN ALMACEN.TBL_PRECIO DP ON(DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)
INNER JOIN ALMACEN.TBL_PRODUCTO P ON(P.ID_PRODUCTO=DP.ID_PRODUCTO)
INNER JOIN ALMACEN.TBL_FAMILIA FA ON (FA.ID_FAMILIA=P.ID_FAMILIA)
INNER JOIN ALMACEN.TBL_MARCA M ON (M.ID_MARCA=P.ID_MARCA)
INNER JOIN ALMACEN.TBL_UNIDAD U ON (U.ID_UNIDADVENTA=DF.ID_UNIDADVENTA)  ' || condiventas ||'
GROUP BY P.ID_PRODUCTO,
P.DESCRIPCION_LARGA ,
Fa.DESCRIPCION_LARGA ,
M.DESCRIPCION_LARGA ,
U.DESC_LARGA ,
DP.VAL_UNIDAD,
dp.id_producto,
dp.id_unidadventa
ORDER BY Fa.DESCRIPCION_LARGA ';
open $1 for execute cad;
  return $1;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION contabilidad.list__subdiarioimpuesto(
    IN __id__empresa integer,
    IN __id__auxiliar integer)
  RETURNS TABLE(
	id bigint,
	auxiliar character varying, 
	subdiario varchar(150),
	impuesto character varying, 
	cta_debe text, 
	cta_haber text, 
	nrombre_debe text, 
	nombre_haber text, 
	id_debe bigint, 
	id_haber bigint,
	tipoimpuesto_id integer, 
	id_auxiliar integer, 
	id_estado integer, 
	op integer, 
	subdirio_id integer
) AS
$BODY$
BEGIN
    RETURN QUERY select 
		c.id,
		ax.descripcion as auxiliar,
		sub.name as subdiario,
		tin.descripcion as tipoimpuesto,
		debe.nro_cuenta as debe,
		haber.nro_cuenta as haber,
		debe.nombre_cuenta as nom_debe,
		haber.nombre_cuenta as nom_haber,
		c.PlanCuentaDebe_id,
		c.PlanCuentaHaber_id,
		c.TipoImpuesto_id,
		ax.id_auxiliar,
		c.status_id,
		2::integer as op,
		c.subdiario_id
     from 
	CONTABILIDAD.TBL_CONFIGIMPUESTO c
	inner join contabilidad.tbl_subdiario sub on sub.id=c.subdiario_id
	inner join contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sub.auxiliar_id)
	inner join contabilidad.tbl_plancuenta debe on (debe.id_plancuenta=c.PlanCuentaDebe_id)
	inner join contabilidad.tbl_plancuenta haber on (haber.id_plancuenta=c.PlanCuentaHaber_id)
	inner join common.tbl_tipoimpuesto tin on tin.id_tipoimpuesto=c.TipoImpuesto_id
	--inner join common.tbl_igv i on (i.id_igv=c.id_igv)
	where c.enterprise_id=__id__empresa and ax.id_auxiliar=__id__auxiliar
	;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;


CREATE OR REPLACE FUNCTION contabilidad.isp__impuestoaSubDiario(
    op integer,
    __id__configuracicon bigint,
    __id__cuentadebe bigint,
    __id__cuentahaber bigint,
    __id__subdiario integer,
    __id__empresa integer,
    __TipoImpuesto_id integer,
    __id__estado integer,
    __id__usuario character
    )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	_id bigint;
begin
if op =1 then
	if not exists(select 1 from CONTABILIDAD.TBL_CONFIGIMPUESTO
				where PlanCuentaDebe_id=__id__cuentadebe and subdiario_id=__id__subdiario and enterprise_id=__id__empresa) then
		if not exists(select 1 from CONTABILIDAD.TBL_CONFIGIMPUESTO
				where PlanCuentaHaber_id=__id__cuentahaber and subdiario_id=__id__subdiario and enterprise_id=__id__empresa) then
			select max(id) into _id from CONTABILIDAD.TBL_CONFIGIMPUESTO;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO CONTABILIDAD.TBL_CONFIGIMPUESTO
			(
				id, 
				subdiario_id ,
				PlanCuentaDebe_id,
				PlanCuentaHaber_id,
				enterprise_id,
				status_id          ,
				userinserted       ,
				TipoImpuesto_id 
				
			)
		        VALUES (
				_id, 
				__id__subdiario,
				__id__cuentadebe, 
				__id__cuentahaber, 
				__id__empresa, 
				__id__estado, 
				__id__usuario::integer, 
				__TipoImpuesto_id

		        ) returning array['0','Registro efecutado con exito'] into res;
			if not found then
				res:=array['504','Inconcistencia inesperada verefique que los datos esten ingresados correctamente'];
			end if;
		else
			res:=array['502','El nro de cuenta del haber ya esta configurada con el mismo item '];
		end if;
	else
		res:=array['503','El nro de cuenta del debe ya esta configurada con el mismo item'];
	end if;
end if;
if op=2 then
	if exists(select * from CONTABILIDAD.TBL_CONFIGIMPUESTO where id=__id__configuracicon )then
		UPDATE contabilidad.tbl_auxiliarimpuesto
		   SET 
			PlanCuentaDebe_id=__id__cuentadebe, 
			PlanCuentaHaber_id=__id__cuentahaber, 
		        subdiario_id=__id__auxiliar, 
		        enterprise_id=__id__empresa, 
			TipoImpuesto_id=__TipoImpuesto_id,
		        status_id=__id__estado, 
		        userupdated=__id__usuario::integer, 
		        dateupdate=now()
		 WHERE id=__id__configuracicon;
		 res:=array['0','Registro acutalizado con exito'];
	else
		res:=array['502','Verefique que exita el registro que esta actualizando'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE


CREATE OR REPLACE FUNCTION contabilidad.list_configuracioncuenta(
    IN _id_empresa integer,
    IN _id_producto character varying)
  RETURNS TABLE(
	auxiliar character varying, 
	cta_debe text, 
	cta_haber text, 
	nrombre_debe text, 
	nombre_haber text, 
	id_debe bigint, 
	id_haber bigint, 
	id_configuracion bigint, 
	id_auxiliar integer, 
	id_estado integer, 
	op integer,
	subdiario varchar(100),
	subdiario_id integer
	) AS
$BODY$
BEGIN
    RETURN QUERY select 
		ax.descripcion as auxiliar,
		debe.nro_cuenta as debe,
		haber.nro_cuenta as haber,
		debe.nombre_cuenta as nom_debe,
		haber.nombre_cuenta as nom_haber,
		c.id_cuentadebe,
		c.id_cuentahaber,
		c.id_configuracicon,
		ax.id_auxiliar,		
		c.id_estado,
		2::integer as op,
		sb.name as subdiario,
		sb.id as subdiario_id
     from 
	contabilidad.tbl_configuracioncuenta c
	inner join contabilidad.tbl_subdiario sb on sb.id=c.subdiario_id
	inner join contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sb.auxiliar_id)
	inner join contabilidad.tbl_plancuenta debe on (debe.id_plancuenta=c.id_cuentadebe)
	inner join contabilidad.tbl_plancuenta haber on (haber.id_plancuenta=c.id_cuentahaber)
	where c.id_empresa=_id_empresa and c.id_producto=_id_producto
	;
END;
$BODY$
  LANGUAGE plpgsql ;

select *from contabilidad.tbl_subdiario

CREATE OR REPLACE FUNCTION contabilidad.list_configuracioncuentas(
    IN op integer,
    IN __id__empresa integer,
    IN __id__subdiario integer,
    IN __filtro text)
  RETURNS TABLE(
	id_config bigint, 
	_auxiliar character varying, 
	_subdiario varchar(200),
	_rubro text, 
	_cta_debe text, 
	_cta_haber text, 
	_id_producto character varying, 
	_nom_debe text, 
	_nom_haber text, 
	_id_auxiliar integer, 
	_codigo_debe bigint, 
	_codigo_haber bigint,
	_tabla varchar(50)
) AS
$BODY$
declare
begin
if op=1 then
	return query select 
		ccta.id_configuracicon,
		ax.descripcion as auxiliar,
		sb.name as subdiario,
		COALESCE(prod.descripcion_larga,'')::text AS RUBRO,
			  pd.nro_cuenta AS CTA_DEBE,      
			  ph.nro_cuenta AS CTA_HABER ,         
			  prod.id_producto,      
			  pd.nombre_cuenta as nom_debe,      
			  ph.nombre_cuenta as nom_haber,    
			  ax.id_auxiliar,      
			  pd.id_plancuenta as codigo_debe,      
			  ph.id_plancuenta as codigo_haber ,
			  ccta.tabla                     
		 from contabilidad.tbl_configuracioncuenta ccta
	inner join  contabilidad.tbl_plancuenta pd on (ccta.id_cuentadebe=pd.id_plancuenta)
	inner join  contabilidad.tbl_plancuenta ph on (ccta.id_cuentahaber=ph.id_plancuenta)
	inner join contabilidad.tbl_subdiario sb on sb.id=ccta.subdiario_id
	inner join  contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sb.auxiliar_id)
	inner join  almacen.tbl_producto prod on (prod.id_producto=ccta.id_producto)
	where 
		ccta.subdiario_id=__id__subdiario 
		and ccta.id_empresa=__id__empresa 
		and  (pd.nro_cuenta || ph.nro_cuenta ) ilike '%'|| __filtro ||'%'
	union
	select 
		ccta.id_configuracicon,
		ax.descripcion as auxiliar,
		sb.name as subdiario,
		COALESCE(prod.descripcion_larga,'')::text AS RUBRO,
			  pd.nro_cuenta AS CTA_DEBE,      
			  ph.nro_cuenta AS CTA_HABER ,         
			  prod.concepto_id::text as concepto_id,      
			  pd.nombre_cuenta as nom_debe,      
			  ph.nombre_cuenta as nom_haber,    
			  ax.id_auxiliar,      
			  pd.id_plancuenta as codigo_debe,      
			  ph.id_plancuenta as codigo_haber ,
			  ccta.tabla                     
		 from contabilidad.tbl_configuracioncuenta ccta
	inner join  contabilidad.tbl_plancuenta pd on (ccta.id_cuentadebe=pd.id_plancuenta)
	inner join  contabilidad.tbl_plancuenta ph on (ccta.id_cuentahaber=ph.id_plancuenta)
	inner join contabilidad.tbl_subdiario sb on sb.id=ccta.subdiario_id
	inner join  contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sb.auxiliar_id)
	inner join  common.tbl_concepto prod on (prod.id=ccta.concepto_id)
	where 
		ccta.subdiario_id=__id__subdiario 
		and ccta.id_empresa=__id__empresa 
		and  (pd.nro_cuenta || ph.nro_cuenta ) ilike '%'|| __filtro ||'%'
	;
end if;
if op=2 then
		return query select 
		ccta.id_configuracicon,
		ax.descripcion as auxiliar,
		sb.name as subdiario,
		COALESCE(prod.descripcion_larga,'')::text AS RUBRO,
			  pd.nro_cuenta AS CTA_DEBE,      
			  ph.nro_cuenta AS CTA_HABER ,         
			  prod.id_producto,      
			  pd.nombre_cuenta as nom_debe,      
			  ph.nombre_cuenta as nom_haber,    
			  ax.id_auxiliar,      
			  pd.id_plancuenta as codigo_debe,      
			  ph.id_plancuenta as codigo_haber ,
			  ccta.tabla                     
		 from contabilidad.tbl_configuracioncuenta ccta
	inner join  contabilidad.tbl_plancuenta pd on (ccta.id_cuentadebe=pd.id_plancuenta)
	inner join  contabilidad.tbl_plancuenta ph on (ccta.id_cuentahaber=ph.id_plancuenta)
	inner join contabilidad.tbl_subdiario sb on sb.id=ccta.subdiario_id
	inner join  contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sb.auxiliar_id)
	inner join  almacen.tbl_producto prod on (prod.id_producto=ccta.id_producto)
	where 
		ccta.subdiario_id=__id__subdiario 
		and ccta.id_empresa=__id__empresa 
		and  prod.descripcion_larga ilike '%'|| __filtro ||'%'
	union
	select 
		ccta.id_configuracicon,
		ax.descripcion as auxiliar,
		sb.name as subdiario,
		COALESCE(prod.descripcion_larga,'')::text AS RUBRO,
			  pd.nro_cuenta AS CTA_DEBE,      
			  ph.nro_cuenta AS CTA_HABER ,         
			  prod.id::text as concepto_id,      
			  pd.nombre_cuenta as nom_debe,      
			  ph.nombre_cuenta as nom_haber,    
			  ax.id_auxiliar,      
			  pd.id_plancuenta as codigo_debe,      
			  ph.id_plancuenta as codigo_haber ,
			  ccta.tabla                    
		 from contabilidad.tbl_configuracioncuenta ccta
	inner join  contabilidad.tbl_plancuenta pd on (ccta.id_cuentadebe=pd.id_plancuenta)
	inner join  contabilidad.tbl_plancuenta ph on (ccta.id_cuentahaber=ph.id_plancuenta)
	inner join contabilidad.tbl_subdiario sb on sb.id=ccta.subdiario_id
	inner join  contabilidad.tbl_auxiliar ax on (ax.id_auxiliar=sb.auxiliar_id)
	inner join  common.tbl_concepto prod on (prod.id=ccta.concepto_id)
	where ccta.subdiario_id=__id__subdiario 
		and ccta.id_empresa=__id__empresa 
		and  prod.descripcion_larga ilike '%'|| __filtro ||'%';
end if;
end$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


CREATE OR REPLACE FUNCTION contabilidad.isp_configuracioncuenta(
    op integer,
    _id_configuracicon bigint,
    _id_cuentadebe bigint,
    _id_cuentahaber bigint,
    _id_producto character varying,
    _subdiario_id integer,
    _id_empresa integer,
    _id_estado integer,
    _id_usuario character,
    _observaciones character varying,
    _table varchar(50)
    )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	_id integer;
	_auxiliar_id integer;
begin
select  auxiliar_id into _auxiliar_id from contabilidad.tbl_subdiario where id=_subdiario_id;
if op =1 then
	if not exists(select 1 from contabilidad.tbl_configuracioncuenta 
				where id_cuentadebe=_id_cuentadebe and subdiario_id=_subdiario_id and id_empresa=_id_empresa  and id_producto=_id_producto) then
		if not exists(select 1 from contabilidad.tbl_configuracioncuenta 
				where id_cuentahaber=_id_cuentahaber and subdiario_id=_subdiario_id and id_empresa=_id_empresa and id_producto=_id_producto) then
			select max(id_configuracicon) into _id from contabilidad.tbl_configuracioncuenta;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO contabilidad.tbl_configuracioncuenta
			(
				id_configuracicon, 
				id_cuentadebe, 
				id_cuentahaber, 
				id_producto, 
				subdiario_id, 
				id_empresa, 
				id_estado, 
				id_usuarior, 
				fecha_reg, 
				observaciones,
				concepto_id,
				tabla
			)
		        VALUES (
				_id, 
				_id_cuentadebe, 
				_id_cuentahaber, 
				case when _table='PRODUCTO' then  _id_producto else null end, 
				_subdiario_id, 
				_id_empresa, 
				_id_estado, 
				_id_usuario, 
				now(), 
				_observaciones,
				case when _table='CONCEPTO' then _id_producto::bigint else null end,
				_table
		        ) returning array['0','Registro efecutado con exito'] into res;
			if not found then
				res:=array['504','Inconcistencia inesperada verefique que los datos esten ingresados correctamente'];
			end if;
		else
			res:=array['502','El nro de cuenta del haber ya esta configurada con el mismo item '];
		end if;
	else
		res:=array['503','El nro de cuenta del debe ya esta configurada con el mismo item'];
	end if;
end if;
if op=2 then
	if exists(select * from contabilidad.tbl_configuracioncuenta where id_configuracicon=_id_configuracicon )then
		UPDATE contabilidad.tbl_configuracioncuenta
		   SET 
			id_cuentadebe=_id_cuentadebe, 
			id_cuentahaber=_id_cuentahaber, 
			id_producto=case when _table='PRODUCTO' then _id_producto else null end, 
		        subdiario_id=_subdiario_id, 
		        id_empresa=_id_empresa, 
		        id_estado=_id_estado, 
		        id_usuarioa=_id_usuario, 
		        fecha_act=now(), 
		        observaciones=_observaciones,
		        concepto_id=case when _table='CONCEPTO' then _id_producto::bigint else null end,
		        tabla=_table
		 WHERE id_configuracicon=_id_configuracicon;
		 res:=array['0','Registro acutalizado con exito'];
	else
		res:=array['502','Verefique que exita el registro que esta actualizando'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE 'plpgsql';



CREATE OR REPLACE FUNCTION common.spiu_concepto(
    op integer,
    _id bigint,
    _id_origen character varying,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _comentario text,
    _tipo_trans character,
    _presupuesto numeric,
    _presu_dias numeric,
    _ajustar boolean,
    _id_estado integer,
    _enterprise_id integer
    )
  RETURNS text[] AS
$BODY$
declare
   cadena character varying;
   item_id   integer;
   regs	     record;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_concepto where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id) INTO item_id FROM common.tbl_concepto;-- WHERE ISNUMERIC(id_concepto);
		IF item_id IS NULL THEN
		   item_id=1;
		ELSE
		  item_id = item_id+1;		   
		END IF;

		insert into common.tbl_concepto (
			id_concepto,
			id_origen,
			descripcion_larga, 
			id_estado,
			descripcion_corta,
			comentario,
			tipo_trans,
			presupuesto,
			presu_dias,
			ajustar,
			enterprise_id,
			id
			)
		values(
			item_id,
			_id_origen,
			_descripcion_larga, 
			_id_estado, 
			_descripcion_corta,
			_comentario,
			_tipo_trans,
			_presupuesto,
			_presu_dias,
			_ajustar,
			_enterprise_id,
			item_id
		) RETURNING array['0',tbl_concepto.id::text] INTO cadena;
		if not found then
			cadena:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		cadena:=array['1'];
	    end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_concepto where id=_id)) then
		update common.tbl_concepto 
		set 
			id_origen  = _id_origen,
			descripcion_larga   = _descripcion_larga, 
			id_estado  = _id_estado, 
			descripcion_corta  = _descripcion_corta,
			comentario  = _comentario,
			tipo_trans  = _tipo_trans,
			presupuesto  = _presupuesto,
			presu_dias  = _presu_dias,
			ajustar  = _ajustar,
			enterprise_id=_enterprise_id
		where id = _id;
		cadena:=array['0',_id::text];
	else
		cadena:=array['1'];
	end if;
end if;
return cadena;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  
select * from CONTABILIDAD.USP__SUBDIARIO(2,20,'GASTOS VARIOS','GASTOS VARIOS',2,1,1)

CREATE OR REPLACE FUNCTION CONTABILIDAD.USP__SUBDIARIO(
	op integer,
	_id integer,
	_name varchar(200),
	_shortname varchar(100),
	_auxiliar_id integer,
	_enterprise_id integer,
	_status_id integer
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
	--_correl integer;
BEGIN
	if op=1 then
		if not exists(select 1 from contabilidad.tbl_subdiario where upper(trim(name))=upper(trim(_name))) then
			select max(coalesce(id,0)) into _id from contabilidad.tbl_subdiario;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			insert into contabilidad.tbl_subdiario(
				id,
				name,
				shortname,
				auxiliar_id,
				enterprise_id,
				status_id
			)values(
				_id,
				_name,
				_shortname,
				_auxiliar_id,
				_enterprise_id,
				_status_id
			);
			res:=array['0','Registro procesado'];
		else
			res=array['502','ya existe un registro con los mismo datos ingresados'];
		end if;
	end if;
	if op=2 then
		if exists(select * from contabilidad.tbl_subdiario where id=_id) then
			update  
				contabilidad.tbl_subdiario 
					set  
					name=_name,
					shortname=_shortname,
					auxiliar_id=_auxiliar_id,
					enterprise_id=_enterprise_id, 
					status_id=_status_id 
			where id=_id;
			
			res:=array['0','Registro actualizado'];
		else
			res:=array['503','Verifique que el registro este seleccionado correctamente'];
		end if;
	end if;
return res;
END;$$
LANGUAGE 'plpgsql';



CREATE OR REPLACE FUNCTION CONTABILIDAD.SP__AUXILIARES(
	op integer,
	_id_auxiliar integer,
	_descripcion varchar(200),
	_abreviatura varchar(100),
	_id_estado integer
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
	id integer;
BEGIN
	if op=1 then
		if not exists(select 1 from contabilidad.tbl_auxiliar where upper(trim(descripcion))=_descripcion) then
			select max(coalesce(id_auxiliar,0)) into id from contabilidad.tbl_auxiliar;
			if id is null then
				id:=1;
			else
				id:=id+1;
			end if;
			insert into contabilidad.tbl_auxiliar(id_auxiliar,descripcion,abreviatura,id_estado)values(id,_descripcion,_abreviatura,_id_estado);
			res:=array['0','Registro procesado'];
		else
			res=array['502','ya existe un registro con los mismo datos ingresados'];
		end if;
	end if;
	if op=2 then
		if exists(select 1 from contabilidad.tbl_auxiliar where id_auxiliar=_id_auxiliar) then
			update  contabilidad.tbl_auxiliar  set  descripcion=_descripcion,abreviatura=_abreviatura,id_estado=_id_estado where id_auxiliar=_id_auxiliar;
			res:=array['0','Registro actualizado'];
		else
			res:=array['503','Verifique que el registro este seleccionado correctamente'];
		end if;
	end if;
return res;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION ALMACEN.FN_IMPORTAR_PRODUCTS(
	P_ID_PRODUCTO	varchar(20),
	P_PRODUCTO	varchar(200),
	P_ID_GRUPO CHAR(3),
	P_GRUPO	VARCHAR(200),
	P_ID_FAMILIA CHAR(5)	,
	P_FAMILIA	 varchar(100),
	P_ID_MARCA char(4),
	P_MARCA	varchar(100),
	P_ID_COLOR integer,
	P_COLOR	varchar(100),
	P_ID_MODELO	bigint,
	P_MODELO	varchar(100),	
	P_ID_UNIDAD	integer,
	P_UNIDAD	varchar(200),
	P_VAL_UNIDAD	INTEGER,
	P_ID_INVENTARIO	 integer,
	P_ID_ALMACEN	integer,
	P_STOCK	numeric(20,4),
	P_COSTO	numeric(20,4),
	P_P1	numeric(20,4),
	P_P2	numeric(20,4),
	P_P3 numeric(20,4),
	P_P4 numeric(20,4),
	P_P5 numeric(20,4),
	P_ppuu numeric(20,4),
	p_codigo varchar(36)	
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
	INSERT INTO almacen.tbl_import_producto(
            id_producto, producto, id_grupo, grupo, id_familia, familia, 
            id_marca, marca, id_color, color, id_modelo, modelo, id_unidad, 
            unidad, id_inventario, id_almacen, stock, costo, p1, p2, p3, 
            p4, p5, ppuu,VAL_UNIDAD,codigo)
	VALUES (p_id_producto, p_producto, p_id_grupo, p_grupo, p_id_familia, p_familia, 
            p_id_marca, p_marca, p_id_color, p_color, p_id_modelo, p_modelo, p_id_unidad, 
            p_unidad, p_id_inventario, p_id_almacen, p_stock, p_costo, p_p1, p_p2, p_p3, 
            p_p4, p_p5, p_ppuu,P_VAL_UNIDAD,p_codigo);
       res:=array['0','OK'];
       return res;
END;$$
LANGUAGE 'plpgsql';


select * from ALMACEN.FN_IMPORTAR_PRODUCTS('000403','PAPEL OFICIO CUADRICULADO','05','UTILES ESCOLARES','0076','PAPEL','596','0',2,'NINGUNO',0,'NINGUNO',16,'PLIEGO',1,1,1,'0.00','0.04','0.1','0.0','0.0','0.0','0.0','0.1')

CREATE OR REPLACE FUNCTION Ventas.fn_list_CantidadventasDiadriasProductos(
    op integer,
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(
  producto varchar(200),
  unidad   varchar(20),
  mes integer, 
  id_producto varchar(15), 
  id_unidadventa integer,
  "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, 
  "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, 
  "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$$
declare
begin
RETURN QUERY select p.descripcion_larga as producto,und.desc_corta as unidad, fn.*from Ventas.list_CantidadventasDiadriasProductos(op,anio_,sucursal) fn
inner join almacen.tbl_detproducto dp on dp.id_producto=fn.id_producto and dp.id_unidadventa=fn.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=dp.id_producto
inner join almacen.tbl_unidad und on und.id_unidadventa=dp.id_unidadventa;
end;$$
language 'plpgsql';

select *from Ventas.list_CantidadventasDiadriasProductos1(1,2018,1);

CREATE OR REPLACE FUNCTION Ventas.list_CantidadventasDiadriasProductos1(
     op integer,
     anio_ integer,
     mes integer,
     sucursal integer
    )
  RETURNS TABLE(--mes integer, 
  id_producto varchar(15), id_unidadventa integer,"1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
--_mes,
_id_producto,
_id_unidadventa,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",
COALESCE("_13",0)as "_13",
COALESCE("_14",0)as "_14",
COALESCE("_15",0)as "_15",
COALESCE("_16",0)as "_16",
COALESCE("_17",0)as "_17",
COALESCE("_18",0)as "_18",
COALESCE("_19",0)as "_19",
COALESCE("_20",0)as "_20",
COALESCE("_21",0)as "_21",
COALESCE("_22",0)as "_22",
COALESCE("_23",0)as "_23",
COALESCE("_24",0)as "_24",
COALESCE("_25",0)as "_25",
COALESCE("_26",0)as "_26",
COALESCE("_27",0)as "_27",
COALESCE("_28",0)as "_28",
COALESCE("_29",0)as "_29",
COALESCE("_30",0)as "_30",
COALESCE("_31",0)as "_31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0)
 as total
 FROM crosstab(
  ' SELECT 
	--date_part(''month'',f.fecha_venta) as mes, 
	p.id_producto , 
	df.id_unidadventa,		
	date_part(''day'',f.fecha_venta) as dia, 
	sum(COALESCE(df.cantidad,0))  as cantidad
	FROM  ventas.tbl_facturacion f inner join 
	ventas.tbl_detfacturacion df  on (f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal) 
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto	
	where  f.id_estado=1 and  date_part(''year'',f.fecha_venta)=''' || anio_ ||  ''' and  date_part(''month'',f.fecha_venta)=''' || mes ||  ''' 
and  f.id_sucursal=''' || sucursal ||''' and df.id_producto<>''TXT-01''
	group by 
		p.id_producto,	
		df.id_unidadventa,
		--date_part(''month'',f.fecha_venta),	
		date_part(''day'',f.fecha_venta) 
	ORDER BY 
		p.id_producto ,
		date_part(''month'',f.fecha_venta) 
		
		
  ',
  ' SELECT m FROM generate_series(1,33) m '
) AS 
(
	--_mes  integer,
	_id_producto   varchar(15) ,
	_id_unidadventa integer,	
	"_1" numeric(20,2), 
	"_2" numeric(20,2), 
	"_3" numeric(20,2), 
	"_4" numeric(20,2), 
	"_5" numeric(20,2), 
	"_6" numeric(20,2), 
	"_7" numeric(20,2), 
	"_8" numeric(20,2), 
	"_9" numeric(20,2), 
	"_10" numeric(20,2), 
	"_11" numeric(20,2), 
	"_12" numeric(20,2),
	"_13" numeric(20,2),
	"_14" numeric(20,2),
	"_15" numeric(20,2),
	"_16" numeric(20,2),
	"_17" numeric(20,2),
	"_18" numeric(20,2),
	"_19" numeric(20,2),
	"_20" numeric(20,2),
	"_21" numeric(20,2),
	"_22" numeric(20,2),
	"_23" numeric(20,2),
	"_24" numeric(20,2),
	"_25" numeric(20,2),
	"_26" numeric(20,2),
	"_27" numeric(20,2),
	"_28" numeric(20,2),
	"_29" numeric(20,2),
	"_30" numeric(20,2),
	"_31" numeric(20,2),
	"_32" numeric(20,2),
	"_33" numeric(20,2)
);
end;$BODY$
  LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION almacen.fn_list_IngresoProductosTerminadosProduccion(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(
  producto varchar(200),
  unidad   varchar(20),
  mes integer, 
  id_producto varchar(15), 
  id_unidadventa integer,
  "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$$
declare
begin
RETURN QUERY select p.descripcion_larga as producto,und.desc_corta as unidad, fn.*from almacen.list_IngresoProductosTerminadosProduccion(anio_,sucursal) fn
inner join almacen.tbl_detproducto dp on dp.id_producto=fn.id_producto and dp.id_unidadventa=fn.id_unidadventa
inner join almacen.tbl_producto p on p.id_producto=dp.id_producto
inner join almacen.tbl_unidad und on und.id_unidadventa=dp.id_unidadventa;
end;$$
language 'plpgsql';

 

CREATE OR REPLACE FUNCTION almacen.list_IngresoProductosTerminadosProduccion(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(mes integer, id_producto varchar(15), id_unidadventa integer,"1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_mes,
_id_producto,
_id_unidadventa,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",
COALESCE("_13",0)as "_13",
COALESCE("_14",0)as "_14",
COALESCE("_15",0)as "_15",
COALESCE("_16",0)as "_16",
COALESCE("_17",0)as "_17",
COALESCE("_18",0)as "_18",
COALESCE("_19",0)as "_19",
COALESCE("_20",0)as "_20",
COALESCE("_21",0)as "_21",
COALESCE("_22",0)as "_22",
COALESCE("_23",0)as "_23",
COALESCE("_24",0)as "_24",
COALESCE("_25",0)as "_25",
COALESCE("_26",0)as "_26",
COALESCE("_27",0)as "_27",
COALESCE("_28",0)as "_28",
COALESCE("_29",0)as "_29",
COALESCE("_30",0)as "_30",
COALESCE("_31",0)as "_31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0)
 as total
 FROM crosstab(
  ' SELECT 
	date_part(''month'',f.fecha) as mes, 
	p.id_producto , 
	df.id_unidadkardex,		
	date_part(''day'',f.fecha) as dia, 
	sum(COALESCE(df.cantidad,0))  as cantidad
	FROM  almacen.tbl_cabmovalm f inner join 
	almacen.tbl_detmovalm df  on (f.id_movimiento=df.id_movimiento) 
	inner join almacen.tbl_producto p on p.id_producto=df.id_producto	
	where  f.id_estado=1 and f.id_tranzaccion=''34'' and f.ingreso=true and  date_part(''year'',f.fecha)=''' || anio_ ||  ''' 
and  f.id_sucursal=''' || sucursal ||'''
	group by 
		p.id_producto,	
		df.id_unidadkardex,
		date_part(''month'',f.fecha),	
		date_part(''day'',f.fecha)
	ORDER BY 
		p.id_producto ,
		date_part(''month'',f.fecha) 
		
		
  ',
  ' SELECT m FROM generate_series(1,33) m '
) AS 
(
	_mes  integer,
	_id_producto   varchar(15) ,
	_id_unidadventa integer,	
	"_1" numeric(20,2), 
	"_2" numeric(20,2), 
	"_3" numeric(20,2), 
	"_4" numeric(20,2), 
	"_5" numeric(20,2), 
	"_6" numeric(20,2), 
	"_7" numeric(20,2), 
	"_8" numeric(20,2), 
	"_9" numeric(20,2), 
	"_10" numeric(20,2), 
	"_11" numeric(20,2), 
	"_12" numeric(20,2),
	"_13" numeric(20,2),
	"_14" numeric(20,2),
	"_15" numeric(20,2),
	"_16" numeric(20,2),
	"_17" numeric(20,2),
	"_18" numeric(20,2),
	"_19" numeric(20,2),
	"_20" numeric(20,2),
	"_21" numeric(20,2),
	"_22" numeric(20,2),
	"_23" numeric(20,2),
	"_24" numeric(20,2),
	"_25" numeric(20,2),
	"_26" numeric(20,2),
	"_27" numeric(20,2),
	"_28" numeric(20,2),
	"_29" numeric(20,2),
	"_30" numeric(20,2),
	"_31" numeric(20,2),
	"_32" numeric(20,2),
	"_33" numeric(20,2)
);
end;$BODY$
  LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION COMPRAS.fn_list_HistoricoPrecioscomprasProductomensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(producto varchar(16),id_producto varchar(250), anio integer, "1" numeric(20,4), "2" numeric(20,4), "3" numeric(20,4), "4" numeric(20,4), "5" numeric(20,4), "6" numeric(20,4), "7" numeric(20,4), "8" numeric(20,4), "9" numeric(20,4), "10" numeric(20,4), "11" numeric(20,4), "12" numeric(20,4),
  total numeric(14,6)
  ) AS
$$
declare
begin
return query select p.descripcion_larga as _producto,fn.*from compras.list_HistoricoPrecioscomprasProductomensual(anio_,sucursal) fn
		inner join almacen.tbl_producto p on p.id_producto=fn.id_producto;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION compras.list_HistoricoPrecioscomprasProductomensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(id_producto varchar(16), anio integer, "1" numeric(20,4), "2" numeric(20,4), "3" numeric(20,4), "4" numeric(20,4), "5" numeric(20,4), "6" numeric(20,4), "7" numeric(20,4), "8" numeric(20,4), "9" numeric(20,4), "10" numeric(20,4), "11" numeric(20,4), "12" numeric(20,4),
  total numeric(14,6)
  ) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_id_producto,
_anio,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",


COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) 
 as total
 FROM crosstab(
  ' SELECT 
	
	df.id_producto, 
	date_part(''year'',fec_documento) as anio, 		
	date_part(''month'',fec_documento) as mes, 
	COALESCE(df.precio,0) as cantidad
	FROM compras.tbl_compra f inner join 
	compras.tbl_detcompra df  on (f.id__compra=df.id__compra and f.id_sucursalcompra=df.id_sucursalcompra) 	
	 
	where  f.id_estado=1 and f.nota__credito=false and date_part(''year'',f.fec_documento)=''' || anio_ ||  ''' 
and  f.id_sucursalcompra=''' || sucursal ||'''	and df.id_estado=1 and f.id_estado=1
		
	ORDER BY 
		date_part(''year'',fec_documento) ,
		 df.id_producto,	
		date_part(''month'',fec_documento) 
  ',
  ' SELECT m FROM generate_series(1,14) m '
) AS 
(
	_id_producto  varchar(16),
	_anio   integer ,	
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"Total" numeric(20,4)
	 
);
end;$BODY$
  LANGUAGE plpgsql ;



CREATE OR REPLACE FUNCTION compras.list_CantidadcomprasProductomensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(id_producto varchar(16), anio integer, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric,total numeric(14,6)
  ) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_id_producto,
_anio,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",


COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) 
 as total
 FROM crosstab(
  ' SELECT 
	
	df.id_producto, 
	date_part(''year'',fec_documento) as anio, 		
	date_part(''month'',fec_documento) as mes, 
	sum(COALESCE(df.cantidad,0))-COALESCE(SUM(COALESCE((
				SELECT SUM(dff.cantidad) AS IMPORTE FROM compras.tbl_compra NC
				inner join compras.tbl_detcompra dff on (dff.id__compra=nc.id__compra and dff.id_sucursalcompra=nc.id_sucursalcompra) 
				WHERE (dF.id__compra=NC.id__compra__ref AND df.id_sucursalcompra=NC.id__sucursal__ref)
			),0)),0) as cantidad
	FROM compras.tbl_compra f inner join 
	compras.tbl_detcompra df  on (f.id__compra=df.id__compra and f.id_sucursalcompra=df.id_sucursalcompra) 	
	 
	where  f.id_estado=1 and f.nota__credito=false and date_part(''year'',f.fec_documento)=''' || anio_ ||  ''' 
and  f.id_sucursalcompra=''' || 1 ||'''
	group by 
	       date_part(''year'',fec_documento),
	       df.id_producto,		
		date_part(''month'',fec_documento)
			
		 
		
	ORDER BY 
		date_part(''year'',fec_documento) ,
		 df.id_producto,	
		date_part(''month'',fec_documento) 
  ',
  ' SELECT m FROM generate_series(1,14) m '
) AS 
(
	_id_producto  varchar(16),
	_anio   integer ,	
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"Total" numeric(20,4)
	 
);
end;$BODY$
  LANGUAGE plpgsql ;

CREATE OR REPLACE FUNCTION compras.list_importecomprasProductomensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(id_producto varchar(16), anio integer, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric,total numeric(14,6)
  ) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_id_producto,
_anio,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",


COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) 
 as total
 FROM crosstab(
  ' SELECT 
	
	df.id_producto, 
	date_part(''year'',fec_documento) as anio, 		
	date_part(''month'',fec_documento) as mes, 
	sum(COALESCE(df.imp_incluido,0))-COALESCE(SUM(COALESCE((
				SELECT SUM(dff.imp_incluido) AS IMPORTE FROM compras.tbl_compra NC
				inner join compras.tbl_detcompra dff on (dff.id__compra=nc.id__compra and dff.id_sucursalcompra=nc.id_sucursalcompra) 
				WHERE (dF.id__compra=NC.id__compra__ref AND df.id_sucursalcompra=NC.id__sucursal__ref)
			),0)),0) as cantidad
	FROM compras.tbl_compra f inner join 
	compras.tbl_detcompra df  on (f.id__compra=df.id__compra and f.id_sucursalcompra=df.id_sucursalcompra) 	
	 
	where  f.id_estado=1 and f.nota__credito=false and date_part(''year'',f.fec_documento)=''' || anio_ ||  ''' 
and  f.id_sucursalcompra=''' || 1 ||'''
	group by 
	       date_part(''year'',fec_documento),
	       df.id_producto,		
		date_part(''month'',fec_documento)
			
		 
		
	ORDER BY 
		date_part(''year'',fec_documento) ,
		 df.id_producto,	
		date_part(''month'',fec_documento) 
  ',
  ' SELECT m FROM generate_series(1,14) m '
) AS 
(
	_id_producto  varchar(16),
	_anio   integer ,	
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"Total" numeric(20,4)
	 
);
end;$BODY$
  LANGUAGE plpgsql ;





CREATE OR REPLACE FUNCTION compras.list_importecomprasdiariasmensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(mes integer, anio integer, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_mes,
_anio,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",
COALESCE("_13",0)as "_13",
COALESCE("_14",0)as "_14",
COALESCE("_15",0)as "_15",
COALESCE("_16",0)as "_16",
COALESCE("_17",0)as "_17",
COALESCE("_18",0)as "_18",
COALESCE("_19",0)as "_19",
COALESCE("_20",0)as "_20",
COALESCE("_21",0)as "_21",
COALESCE("_22",0)as "_22",
COALESCE("_23",0)as "_23",
COALESCE("_24",0)as "_24",
COALESCE("_25",0)as "_25",
COALESCE("_26",0)as "_26",
COALESCE("_27",0)as "_27",
COALESCE("_28",0)as "_28",
COALESCE("_29",0)as "_29",
COALESCE("_30",0)as "_30",
COALESCE("_31",0)as "_31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0)
 as total
 FROM crosstab(
  ' SELECT 
	date_part(''month'',fec_documento) as mes, 
	date_part(''year'',fec_documento) as anio, 		
	date_part(''day'',fec_documento) as dia, 
	sum(COALESCE(df.imp_incluido,0))-COALESCE(SUM(COALESCE((
				SELECT SUM(dff.imp_incluido) AS IMPORTE FROM compras.tbl_compra NC
				inner join compras.tbl_detcompra dff on (dff.id__compra=nc.id__compra and dff.id_sucursalcompra=nc.id_sucursalcompra) 
				WHERE (dF.id__compra=NC.id__compra__ref AND df.id_sucursalcompra=NC.id__sucursal__ref)
			),0)),0) as cantidad
	FROM compras.tbl_compra f inner join 
	compras.tbl_detcompra df  on (f.id__compra=df.id__compra and f.id_sucursalcompra=df.id_sucursalcompra) 	
	where  f.id_estado=1 and f.nota__credito=false and date_part(''year'',f.fec_documento)=''' || anio_ ||  ''' 
and  f.id_sucursalcompra=''' || 1 ||'''
	group by 
		date_part(''month'',fec_documento),
		date_part(''year'',fec_documento),		
		date_part(''day'',fec_documento)
	ORDER BY 
		date_part(''year'',fec_documento) ,
		date_part(''month'',fec_documento) 
  ',
  ' SELECT m FROM generate_series(1,33) m '
) AS 
(
	_mes  integer,
	_anio   integer ,	
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"_14" numeric(20,4),
	"_15" numeric(20,4),
	"_16" numeric(20,4),
	"_17" numeric(20,4),
	"_18" numeric(20,4),
	"_19" numeric(20,4),
	"_20" numeric(20,4),
	"_21" numeric(20,4),
	"_22" numeric(20,4),
	"_23" numeric(20,4),
	"_24" numeric(20,4),
	"_25" numeric(20,4),
	"_26" numeric(20,4),
	"_27" numeric(20,4),
	"_28" numeric(20,4),
	"_29" numeric(20,4),
	"_30" numeric(20,4),
	"_31" numeric(20,4),
	"_32" numeric(20,4),
	"_33" numeric(20,4)
);
end;$BODY$
  LANGUAGE plpgsql VOLATILE


CREATE OR REPLACE FUNCTION VENTAS.USP_ANULAR_CANJEPREMIOS(
	_id bigint	
) returns text[] as  $$
declare
	res text[];
begin
	if exists(select 1 from VENTAS.TBL_CANJEPUNTOS where id=_id) then
		update VENTAS.TBL_CANJEPUNTOS set id_estado=7 where id=_id ;
		res:=array['0','El premio canjeado ha sido eliminado'];
	else
		res:=array['501','Verifique que exista el registro'];
	end if;
return res;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION VENTAS.USP_CANJEPUNTOS(
	op integer,
	_id bigint ,
	_serie varchar(4),
	_numero varchar(12),
	_fecha text,
	_id_comprobante integer,
	_id_cliente varchar(15),
	_puntos_canjeados numeric(20,2),
	_id_usuario varchar(5),
	_premio_id bigint
) returns text[] as $$
declare
	res text[];
begin
if op=1 then
	if exists(select 1 from planillas.tbl_persona where id_persona=_id_cliente) then
		insert into VENTAS.TBL_CANJEPUNTOS(
			serie,
			numero,
			fecha,
			id_comprobante,
			id_cliente,
			puntos_canjeados,
			id_usuario,
			premio_id
		)values(
			_serie,
			_numero,
			_fecha::timestamp ,  
			_id_comprobante,
			_id_cliente,
			_puntos_canjeados,
			_id_usuario::integer,
			_premio_id 
		)returning array['0','Canje registrado',TBL_CANJEPUNTOS.id::text] into res;
		if not found then
			res:=array['506','Inconsistencia inesperada intente nuevamente'];
		end if;
	else
		res:=array['504','Verifique que el cliente exista'];
	end if;
end if;
if op=2 then
	if exists(select 1 from VENTAS.TBL_CANJEPUNTOS where id=_id) then
		update VENTAS.TBL_CANJEPUNTOS set 
			fecha=_fecha::timestamp,
			puntos_canjeados=_puntos_canjeados,
			id_usuario=_id_usuario,
			premio_id=_premio_id
		where id=_id;
		res:=array['0','Registro actualizado'];
	else
		res:=array['504','Seleccione correctamente el registro que desea actualizar'];
	end if;
end if;
return res;
end;$$
language  'plpgsql';


CREATE OR REPLACE FUNCTION almacen.spi_detproducto(
    _id_producto character varying,
    _id_unidadventa integer,
    _id_estado integer,
    _val_unidad double precision,
    _val_minimo double precision,
    _unidad_inventario boolean,
    _id_tipoventa integer,
    _undpred_compra boolean,
    _ctl_stock boolean,
    _codigo_barra text
)
  RETURNS text[] AS
$BODY$

DECLARE
	res text[];
BEGIN
if not exists(select *from ALMACEN.TBL_DETPRODUCTO where id_producto=_id_producto and id_unidadventa=_id_unidadventa)then 
	if exists(select *from almacen.tbl_producto where id_producto=_id_producto)then
		if exists(select *from almacen.tbl_unidad where id_unidadventa=_id_unidadventa)then
			insert into ALMACEN.TBL_DETPRODUCTO(
				id_producto,
				id_unidadventa,
				fecha         ,
				id_estado,
				val_unidad ,
				val_minimo,
				unidad_inventario,
				ID_TIPOVENTA,
				UNDPRED_COMPRA,
				ctl_stock,
				codigo_barra
			)values(
				_id_producto,
				_id_unidadventa,
				now(),
				_id_estado,
				_val_unidad ,
				_val_minimo,
				_unidad_inventario,
				_ID_TIPOVENTA,
				_UNDPRED_COMPRA,
				_ctl_stock,
				_codigo_barra
			) returning array['0',TBL_DETPRODUCTO.id_producto::text,TBL_DETPRODUCTO.id_unidadventa::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el detalle del producto'];
			end if;
		else
			res:=array['503','la unidad de medida no existe'];
		end if;
	else
		res=array['502','el Producto no existe'];
	end if;
else
	update ALMACEN.TBL_DETPRODUCTO set 
				id_estado=_id_estado,
				val_unidad=_val_unidad ,
				val_minimo=_val_minimo,
				unidad_inventario=_unidad_inventario ,
				ID_TIPOVENTA=_ID_TIPOVENTA,
				UNDPRED_COMPRA=_UNDPRED_COMPRA ,
				ctl_stock=_ctl_stock,	
				codigo_barra=_codigo_barra
				where id_producto=_id_producto and id_unidadventa=_id_unidadventa;
	res:=array['0','Actualizando registros de productos'];
end if;
return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
 

CREATE OR REPLACE FUNCTION almacen.isp_deteleteunidadinventario(
    _id_almacen integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_inventario integer,
    _id_estado integer,
    _observaciones text,
    _und_inventarion boolean,
    _StockMin numeric(20,4),
    _stockMax numeric(20,4),
    _CtrlStock boolean
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_id_sucursal integer;
BEGIN
if exists(select *from almacen.tbl_inventario where id_inventario=_id_inventario and id_almacen=_id_almacen) then
	select id_sucursal into _id_sucursal from almacen.tbl_almacen where id_almacen=_id_almacen;

	delete from almacen.tbl_existencia  where id_producto=_id_producto and id_unidadventa=_id_unidadventa and  id_almacen=_id_almacen and  id_inventario=_id_inventario;	
	delete from almacen.tbl_saldosexistencia where id_producto=_id_producto and id_unidad=_id_unidadventa and id_sucursal=_id_sucursal;
	res:=array['0','Registro elimanado: '|| _id_almacen || ' en el inventario ' || _id_inventario ];
else
	res:=array['503','Verefique existe el registro'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION ALMACEN.isp_unidadesitesMovAlmacen(
    op integer,
    _id_movimiento bigint,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _item integer,
    _id_items bigint,
    _id_cateintem integer,
    _cantidad numeric,
    _precio numeric,
    _ancho numeric,
    _largo numeric,
    _id_unidaditem integer,
    _area numeric,
    _id_estado integer,
    _id_retazo bigint
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res text[];
BEGIN
if op=1 then
	if exists(select *from almacen.tbl_detmovalm where id_movimiento=_id_cotizapreventa)then
		select max(id_items) into _id_items from ventas.tbl_items;
			if _id_items is null then
				_id_items:=1;
			else
				_id_items:=_id_items+1;
			end if;
		INSERT INTO ventas.tbl_items(
			id_movimiento, 
			id_producto, 
			id_unidadventa, 
			id_listaprecio, 
			item, 
			id_items, 
			id_cateintem, 
			cantidad, 
			precio, 
			ancho, 
			largo,
			id_unidaditem,
			area,
			id_estado,
			id_retazo
		)
		VALUES (
			_id_movimiento, 
			_id_producto, 
			_id_unidadventa, 
			_id_listaprecio, 
			_item, 
			_id_items, 
			_id_cateintem, 
			_cantidad, 
			_precio, 
			_ancho, 
			_largo,
			_id_unidaditem,
			_area,
			_id_estado,
			_id_retazo
		)returning array['0','Proceso efectuado con exito'] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar las medidas de la cotización'];
		end if;
	else
		res:=array['504','Verefique que haya seleccionado correctamente el producto del detalle'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_items where id_items=_id_items)then
		UPDATE ventas.tbl_items
			SET 
				id_cateintem=_id_cateintem,
				cantidad=_cantidad, 
				precio=_precio, 
				ancho=_ancho, 
				largo=_largo,
				id_unidaditem=_id_unidaditem,
				area=_area,
				id_estado=id_estado,
				id_retazo=_id_retazo
		 WHERE  id_items=_id_items;
		RES:=ARRAY['0','Actualización efectuada con exito'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.fn_ActualizarDetInventario(
    op integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _item integer,
    _cantidad_fisica numeric,
    _costo numeric,
    _importe numeric,
    _cantefectastock boolean,
    _id_estado integer,
    _id_usuario character,
    _cantidad_sistema numeric,
    _id_inventario integer,
    _serie character,
    _numero character,
    _id_almacen integer,
    _id_comprobante integer,
    _inv_incial boolean)
  RETURNS text[] AS
$BODY$
DECLARE
	Res text[];
	dat record;
	cad text;
	_correl integer;
	_fecha_invent timestamp;
BEGIN


if op=1 then
	if exists(select *from almacen.tbl_cabinventario 
		where id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante) then		
		if exists(select *from almacen.tbl_producto where id_producto=_id_producto) then
				select max(item) into _correl from almacen.tbl_detinventario 
				where id_producto=_id_producto and  id_unidadventa=_id_unidadventa and  
				id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante;
			if _correl is null then
				_correl=1;
			else
				_correl=_correl+1;
			end if;
			/*if exists(select *from almacen.tbl_detinventario where id_producto=_id_producto 
			and id_almacen=_id_almacen and id_inventario=_id_inventario and inv_inicial=true) then
				res:=array['503','Ya existe un registro como inventario incial '];
				--exit;			
				return res;
			end if	;	*/	
			 select fecha into _fecha_invent from almacen.tbl_cabinventario cv where  id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante; 
			 
			INSERT INTO almacen.tbl_detinventario(
				    id_producto, 
				    id_unidadventa, 
				    item, 
				    cantidad_fisica, 
				    costo, 
				    importe, 
				    cantefectastock, 
				    fecha, 
				    id_estado, 
				    id_usuario, 
				    cantidad_sistema, 
				    id_inventario, 
				    serie, 
				    numero, 
				    id_almacen, 
				    id_comprobante,
				    inv_inicial
				)
			VALUES (
				    _id_producto, 
				    _id_unidadventa, 
				    _correl, 
				    _cantidad_fisica, 
				    _costo, 
				    _importe, 
				    _cantefectastock, 
				    _fecha_invent, 
				    _id_estado, 
				    _id_usuario, 
				    _cantidad_sistema, 
				    _id_inventario, 
				    _serie, 
				    _numero, 
				    _id_almacen, 
				    _id_comprobante,
				    _inv_incial
				)returning array['0',
						id_producto, 
						id_unidadventa::text, 
						item::text, 
						id_inventario::text, 
						serie, 
						numero, 
						id_almacen::text, 
						id_comprobante::text,'Proceso efectuado con exito'] into res;
			if not found then
				res:=array['503','Ocurri una inconsistencia al registrar el producto '];
				return res;
				--exit;
			end if;
			
		else
			res:=array['502','Verefique el producto es seleccionado correctamente'];
		end if;
	else
		res:=array['502','Verefique que el documento de inventario este seleccionado correactamente'];
	end if;	
end if;
if op=2 then
	IF EXISTS (SELECT *FROM ALMACEN.TBL_DETINVENTARIO WHERE id_producto=_id_producto AND  id_unidadventa=_id_unidadventa AND --item=_item AND  
								id_inventario=_id_inventario AND  serie=_serie AND numero=_numero  AND 
								id_almacen=_id_almacen  AND id_comprobante=_id_comprobante) THEN
		select fecha into _fecha_invent from almacen.tbl_cabinventario cv where  id_inventario=_id_inventario and serie=_serie and  numero=_numero and  id_almacen=_id_almacen and id_comprobante=_id_comprobante; 
			 
		UPDATE almacen.tbl_detinventario SET  
			cantidad_fisica=cantidad_fisica+_cantidad_fisica, 
			costo=_costo, 
		       importe=_importe, 
		       cantefectastock=_cantefectastock, 
		       fecha=_fecha_invent, 
		       id_estado=_id_estado, 
		       id_usuario=_id_usuario, 
		       cantidad_sistema=_cantidad_sistema ,
		       inv_inicial=_inv_inicial
		WHERE  id_producto=_id_producto AND  id_unidadventa=_id_unidadventa AND --item=_item AND  
		       id_inventario=_id_inventario AND  serie=_serie AND numero=_numero  AND 
		       id_almacen=_id_almacen  AND id_comprobante=_id_comprobante 
		       RETURNING ARRAY['0',
					id_producto, 
					id_unidadventa::text, 
					item::text, 
					id_inventario::text, 
					serie, 
					numero, 
					id_almacen::text, 
					id_comprobante::text,
					'Proceso efectuado con exito'
					] into res;
		if not found then
			res:=array['504','No se ha realizado ninguna actualizacion'];
		end if;
	else
		res:=array['503','No existe el registro en el inventario programado'];
	END IF;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  
CREATE OR REPLACE FUNCTION ventas.list_importeventasdiariasmensual(
    IN anio_ integer,
    IN sucursal integer)
  RETURNS TABLE(mes integer, anio integer, "1" numeric, "2" numeric, "3" numeric, "4" numeric, "5" numeric, "6" numeric, "7" numeric, "8" numeric, "9" numeric, "10" numeric, "11" numeric, "12" numeric, "13" numeric, "14" numeric, "15" numeric, "16" numeric, "17" numeric, "18" numeric, "19" numeric, "20" numeric, "21" numeric, "22" numeric, "23" numeric, "24" numeric, "25" numeric, "26" numeric, "27" numeric, "28" numeric, "29" numeric, "30" numeric, "31" numeric, total numeric) AS
$BODY$
declare
begin
RETURN QUERY SELECT
_mes,
_anio,
COALESCE("_1",0) as "_1" ,
COALESCE("_2",0) as "_2",
COALESCE("_3",0) as "_3",
COALESCE("_4",0) as "_4",
COALESCE("_5",0) as "_5",
COALESCE("_6",0) as "_6",
COALESCE("_7",0)as "_7",
COALESCE("_8",0)as "_8",
COALESCE("_9",0)as "_9",
COALESCE("_10",0)as "_10",
COALESCE("_11",0)as "_11",
COALESCE("_12",0)as "_12",
COALESCE("_13",0)as "_13",
COALESCE("_14",0)as "_14",
COALESCE("_15",0)as "_15",
COALESCE("_16",0)as "_16",
COALESCE("_17",0)as "_17",
COALESCE("_18",0)as "_18",
COALESCE("_19",0)as "_19",
COALESCE("_20",0)as "_20",
COALESCE("_21",0)as "_21",
COALESCE("_22",0)as "_22",
COALESCE("_23",0)as "_23",
COALESCE("_24",0)as "_24",
COALESCE("_25",0)as "_25",
COALESCE("_26",0)as "_26",
COALESCE("_27",0)as "_27",
COALESCE("_28",0)as "_28",
COALESCE("_29",0)as "_29",
COALESCE("_30",0)as "_30",
COALESCE("_31",0)as "_31",

COALESCE("_1",0) +
COALESCE("_2",0) +
COALESCE("_3",0) +
COALESCE("_4",0) +
COALESCE("_5",0) +
COALESCE("_6",0) +
COALESCE("_7",0) +
COALESCE("_8",0) +
COALESCE("_9",0) +
COALESCE("_10",0) +
COALESCE("_11",0) +
COALESCE("_12",0) +
COALESCE("_13",0) +
COALESCE("_14",0) +
COALESCE("_15",0) +
COALESCE("_16",0) +
COALESCE("_17",0)+
COALESCE("_18",0) +
COALESCE("_19",0) +
COALESCE("_20",0) +
COALESCE("_21",0) +
COALESCE("_22",0) +
COALESCE("_23",0) +
COALESCE("_24",0) +
COALESCE("_25",0) +
COALESCE("_26",0) +
COALESCE("_27",0) +
COALESCE("_28",0) +
COALESCE("_29",0) +
COALESCE("_30",0) +
COALESCE("_31",0)
 as total
 FROM crosstab(
  ' SELECT 
	date_part(''month'',fecha_venta) as mes, 
	date_part(''year'',fecha_venta) as anio, 		
	date_part(''day'',fecha_venta) as dia, 
	sum(COALESCE(df.importe,0))-COALESCE(SUM(COALESCE((
				SELECT SUM(dff.importe) AS IMPORTE FROM VENTAS.TBL_FACTURACION NC
				inner join ventas.tbl_detfacturacion dff on (dff.id_facturacion=nc.id_facturacion and dff.id_sucursal=nc.id_sucursal) 
				WHERE (dF.ID_FACTURACION=NC.ID_FACTURACIONREF AND df.ID_SUCURSAL=NC.ID_SUCURSALREF) and dff.id_estado=1
			),0)),0) as cantidad
	FROM ventas.tbl_facturacion f inner join 
	ventas.tbl_detfacturacion df  on (f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal) 	
	where  f.id_estado=1 and df.id_estado=1 and f.nota_credito=false and date_part(''year'',f.fecha_venta)=''' || anio_ ||  ''' 
and  f.id_sucursal=''' || 1 ||'''
	group by 
		date_part(''month'',fecha_venta),
		date_part(''year'',fecha_venta),		
		date_part(''day'',fecha_venta)
	ORDER BY 
		date_part(''year'',fecha_venta) ,
		date_part(''month'',fecha_venta) 
  ',
  ' SELECT m FROM generate_series(1,33) m '
) AS 
(
	_mes  integer,
	_anio   integer ,	
	"_1" numeric(20,4), 
	"_2" numeric(20,4), 
	"_3" numeric(20,4), 
	"_4" numeric(20,4), 
	"_5" numeric(20,4), 
	"_6" numeric(20,4), 
	"_7" numeric(20,4), 
	"_8" numeric(20,4), 
	"_9" numeric(20,4), 
	"_10" numeric(20,4), 
	"_11" numeric(20,4), 
	"_12" numeric(20,4),
	"_13" numeric(20,4),
	"_14" numeric(20,4),
	"_15" numeric(20,4),
	"_16" numeric(20,4),
	"_17" numeric(20,4),
	"_18" numeric(20,4),
	"_19" numeric(20,4),
	"_20" numeric(20,4),
	"_21" numeric(20,4),
	"_22" numeric(20,4),
	"_23" numeric(20,4),
	"_24" numeric(20,4),
	"_25" numeric(20,4),
	"_26" numeric(20,4),
	"_27" numeric(20,4),
	"_28" numeric(20,4),
	"_29" numeric(20,4),
	"_30" numeric(20,4),
	"_31" numeric(20,4),
	"_32" numeric(20,4),
	"_33" numeric(20,4)
);
end;$BODY$
  LANGUAGE plpgsql VOLATILE




select * from ALMACEN.isp_grabarexistencias(1,'1057',36,1,1,'Registro por productos','FALSE','0.00','0.00','FALSE')


CREATE OR REPLACE FUNCTION almacen.isp_grabarexistencias(
    _id_almacen integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_inventario integer,
    _id_estado integer,
    _observaciones text,
    _und_inventario boolean,
    _stockMin numeric(20,4),
    _stockMax numeric(20,4),
    _ctrlStock boolean
    )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	_id_sucursal integer;
	__data record;
	__id bigint;
begin
	if exists(select 1 from almacen.tbl_inventario where id_inventario=_id_inventario and id_almacen=_id_almacen) then
		if not exists(select 1 from almacen.tbl_existencia where id_producto=_id_producto and
				id_unidadventa=_id_unidadventa and  id_almacen=_id_almacen and  id_inventario=_id_inventario) then
			INSERT INTO almacen.tbl_existencia(
				stock_fisico, 
				id_almacen, 
				id_producto, 
				id_unidadventa, 
				stock_reserva, 
				stocktransito, 
				id_lote, 
				id_inventario, 
				fec_inventario, 
				valor_incial, 
				stock_inicial, 
				ubicacion, 
				stock_reparto, 
				id_estado, 
				observaciones,
				UND_INVENTARIO,
				stockMin,
				StockMax,
				ctrlstock
			    )
			VALUES (
				0, 
				_id_almacen, 
				_id_producto, 
				_id_unidadventa, 
				0, 
				0, 
				null, 
				_id_inventario, 
				now(), 
				0, 
				0, 
				'', 
				0, 
				_id_estado,
				_observaciones,
				_UND_INVENTARIO,
				_stockMin,
				_StockMax,
				_ctrlstock
			 ) returning array['0',id_producto::text, id_unidadventa::text, id_almacen::text, id_inventario::text] into res;

			if not found then
				res:=array['504','No se ha podido vincular el producto con el almacen'];
			end if;
		else
			update almacen.tbl_existencia set id_estado=_id_estado,UND_INVENTARIO=_UND_INVENTARIO ,stockMin=_stockMin,
			StockMax=_StockMax,
			ctrlstock=_ctrlstock

			where id_producto=_id_producto and
				id_unidadventa=_id_unidadventa and  id_almacen=_id_almacen and  id_inventario=_id_inventario;
			res:=array['0','No existe  el almacen : '|| _id_almacen || ' en el inventario ' || _id_inventario ];
			--res:=array['503','El producto ya esta en el almacen :' || _id_almacen || ' en el inventario ' || _id_inventario];
		end if;
	else
		update almacen.tbl_existencia 
			set id_estado=_id_estado ,
			UND_INVENTARIO=_UND_INVENTARIO,
			stockMin=_stockMin,
			StockMax=_StockMax,
			ctrlstock=_ctrlstock
			where id_producto=_id_producto and
			id_unidadventa=_id_unidadventa and  
			id_almacen=_id_almacen and  
			id_inventario=_id_inventario;
		res:=array['0','No existe  el almacen : '|| _id_almacen || ' en el inventario ' || _id_inventario ];
	end if;
	if res[1]='0' then
		for __data in select ex.id_producto,ex.id_unidadventa,al.id_sucursal from almacen.tbl_existencia ex 
				inner join almacen.tbl_almacen al on(al.id_almacen=ex.id_almacen)
				where al.id_almacen =_id_almacen and ex.und_inventario=true AND ex.id_producto=__data.id_producto loop
			if not exists(select 1 from almacen.tbl_saldosexistencia  where id_producto=__data.id_producto and 
				id_unidad=__data.id_unidadventa and 
				id_sucursal=__data.id_sucursal) then
				select max(id_saldos) into __id from almacen.tbl_saldosexistencia;
				if __id is  null then
					__id:=1;
				else
					__id:=__id+1;
				end if;
				INSERT INTO almacen.tbl_saldosexistencia(
					id_saldos, 
					stockh, 
					stocktransito, 
					stockcomprometido, 
					fechaactualiza, 
					costounitario, 
					id_unidad, 
					id_producto, 
					id_sucursal, 
					id_estado
				)
			    VALUES (
					__id, 
					0, 
					0, 
					0, 
					now(), 
					0, 
					__data.id_unidadventa, 
					__data.id_producto, 
					__data.id_sucursal, 
					1
			    ) returning array['0','']into res;
			else
				res:=array['0',''];
			end if;
		end loop;
	end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION common.fn_gettelonospersona(
	_id_persona varchar(15)
)
returns text as $$
declare
	dat record;
	rest text;
begin
rest:='';
for dat in select telefono from common.tbl_telefono tlf  where id_persona=_id_persona loop
	rest:=rest || dat.telefono || ',';
end loop;
return rest;
end;$$
language 'plpgsql';

select *from common.fn_gettelonospersona('555');

create or replace function almacen.fn_insexistencias()
returns text  as $$
declare
dat record;
res  text[];
begin


for dat in SELECT * FROM ALMACEN.tbl_detproducto dt inner join almacen.tbl_precio p on p.id_producto=dt.id_producto and dt.id_unidadventa=p.id_unidadventa where unidad_inventario=true loop
	if not exists(select 1 from almacen.tbl_existencia where id_producto=dat.id_producto and  id_unidadventa=dat.id_unidadventa and id_almacen=1 and id_inventario=1)then
	INSERT INTO almacen.tbl_existencia(
            stock_fisico, id_almacen, id_producto, id_unidadventa, stock_reserva, 
            stocktransito, id_lote, id_inventario, fec_inventario, valor_incial, 
            stock_inicial, ubicacion, stock_reparto, id_estado, observaciones, 
            stock_ordencompra, consto_inicial, inv_inicial, costo_promedio, 
            saldo_inianterior, und_inventario)
	VALUES (0, 1, dat.id_producto, dat.id_unidadventa, 0, 
            0, null, 1, now(), dat.costo, 
            0, '', 0, 1, 'Importacion de inventario inicial', 
            0, dat.costo, true, dat.costo, 
            0, true);


	end if;
	
end loop;
return res;
end;$$
language 'plpgsql';

select *from almacen.tbl_existencia

select *from almacen.fn_insexistencias()


CREATE OR REPLACE  FUNCTION ventas.fn_anularpreventas(_id_cotizapreventa bigint,_id_sucursal integer)
returns text[] as $$
declare
	res text[];
begin
       --select *from ventas.tbl_facturacion where 
	if exists(select 1 from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and id_estado=1) then
		if not exists(select 1 from ventas.tbl_facturacion  where id_cotizapreventa::text || id_sucursalpreventa::text =_id_cotizapreventa::text ||_id_sucursal::text and id_estado=1 ) then
			if exists( select 1 from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
				update ventas.tbl_cotizacionpreventa set id_Estado=7 where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal;
				update restaurant.tbl_comandamesa  set id_estado=7 where id_cotizapreventa=_id_cotizapreventa ;
				res:=array['0','Preventa anulada'];
			else
				res:=array['501','Verifique exista el registro'];
			end if;
		else
			res:=array['502','El pedido se encuentra facturado'];
		end if;
	else
		res:=array['503','El pedido de venta ya se encuentra anulado'];
	end if;
return res;
end;$$
language 'plpgsql';


select *from  common.tbl_estado

select *from ventas.tbl_cotizacionpreventa

CREATE OR REPLACE FUNCTION caja.isp_grabarcuentabancaria(
    op integer,
    _id_cuenta integer,
    _nro_cuenta character varying,
    _id_sucursal integer,
    _id_moneda integer,
    _id_plancuenta bigint,
    _id_estado integer,
    _observacion text,
    _id_cajabanco integer,
    _id_concepto character varying)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	id integer;
BEGIN
if op=1 then
	if not exists(select *from CAJA.TBL_CUENTABANCARIA where NRO_CUENTA=_NRO_CUENTA ) then
		select max(id_cuenta) into id from caja.tbl_cuentabancaria;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		INSERT INTO caja.tbl_cuentabancaria(
			    id_cuenta, 
			    nro_cuenta, 
			    id_sucursal, 
			    id_moneda, 
			    id_plancuenta, 
			    id_estado, 
			    observacion,
			    id_banco,
			    id_concepto
			   )
		VALUES (
			    id, 
			    _nro_cuenta, 
			    _id_sucursal, 
			    _id_moneda, 
			    _id_plancuenta, 
			    _id_estado, 
			    _observacion,
			    _id_cajabanco,
			    _id_concepto
		)returning array['0',id_cuenta::text] into res;
		if not found then
			res:=array['504','Ocurrio un error al registrar la cuenta bancaria'];
		end if;
	else
		res:=array['503','El nro de cuenta ya esta registrado'];
	end if;
end if;
if op=2 then
	if exists(select *from caja.tbl_cuentabancaria where id_cuenta=_id_cuenta ) then
		UPDATE caja.tbl_cuentabancaria
		   SET  nro_cuenta=_nro_cuenta, 
			id_sucursal=_id_sucursal, 
			id_moneda=_id_moneda, 
			id_plancuenta=_id_plancuenta, 
		       id_estado=_id_estado, 
		       observacion=_observacion,
		       id_banco=_id_cajabanco,
		       id_concepto=_id_concepto
		 WHERE id_cuenta=_id_cuenta;
		res:=array['0',_id_cuenta::text];
	else
		res:=array['502','Verefique el registro este editado correctamnete'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION caja.isp_grabarcuentabancaria(integer, integer, character varying, integer, integer, bigint, integer, text, integer, character varying)
  OWNER TO postgres;


/*
Se creo una nueva tabla para relacion de bancos con empresas
*/
CREATE OR REPLACE FUNCTION COMMON.spiu_banco(
	op integer,
	_Id_Banco integer  ,
	_Id_Empresa integer ,
	_Nombre_Ban varchar(50),	
	_NombreCorto_Ban varchar(50),
	_Id_Estado Integer,
	_Id_Usuario integer,
	_Equipo_Uss varchar(50)
	)
  RETURNS text[] AS
$BODY$
declare
   correl   integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select 1 from COMMON.TBL_BANCO where Nombre_Ban = _Nombre_Ban and Id_Empresa = _Id_Empresa)) then
		SELECT MAX(Id_Banco) INTO _Id_Banco FROM COMMON.TBL_BANCO;
		IF _Id_Banco IS NULL THEN
			_Id_Banco = 1;
		ELSE
			_Id_Banco = _Id_Banco + 1;
		END IF;
		
		insert into COMMON.TBL_BANCO (
			Id_Banco,
			Id_Empresa,
			Nombre_Ban,
			NombreCorto_Ban,	
			Id_Estado,
			Id_UsuarioIns,
			FechaIns,
			Equipo_Uss
			)
		values(
			_Id_Banco,
			_Id_Empresa,
			_Nombre_Ban,	
			_NombreCorto_Ban,
			_Id_Estado,
			_Id_Usuario,
			now(),
			_Equipo_Uss

		) RETURNING array['0', COMMON.TBL_BANCO.Id_Banco::text] INTO res;

		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
	else
		res:=array['1','Banco ya registrado en la empresa'];
	end if;
end if;
if op=2 then
	if(exists (select 1 from COMMON.TBL_BANCO where Id_Banco = _Id_Banco)) then
		update COMMON.TBL_BANCO set 
			Id_Empresa=_Id_Empresa,
			Nombre_Ban=_Nombre_Ban,	
			NombreCorto_Ban=NombreCorto_Ban,
			Id_Estado=_Id_Estado ,
			Id_UsuarioAct=_Id_Usuario,
			FechaAct =NOW(),
			Equipo_Uss=_Equipo_Uss 	
		where Id_Banco = _Id_Banco;
		res:=array['0',_Id_Banco::text];
	else
		res:=array['1','Seleccione Correctamente el registro'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE


select *from almacen.tbl_precio where id_producto='4599'

CREATE OR REPLACE FUNCTION almacen.spi_precio(
	op integer,
	_id_listaprecio integer,
	_id_producto character varying,
	_id_unidadventa integer,
	_codbarra character varying,
	_costo double precision,
	_flete double precision,
	_otroscostos double precision,
	_coste double precision,
	_precio1 double precision,
	_precio2 double precision,
	_precio3 double precision,
	_id_estado integer,
	_predeterminado boolean,
	_val_unidad double precision,
	_val_minimo_venta double precision,
	_id_tipoventa integer,
	_undpred_compra boolean,
	_precio4 double precision,
	_precio5 double precision,
	_peso numeric(20,4),
	_porcent1 numeric(20,6),
	_porcent2 numeric(20,6),
	_porcent3 numeric(20,6),
	_porcent4 numeric(20,6),
	_porcent5 numeric(20,6)
)
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
BEGIN
if not exists(select 1 from ALMACEN.TBL_PRECIO where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
	if exists(select 1 from ALMACEN.TBL_DETPRODUCTO where id_producto=_id_producto and id_unidadventa=_id_unidadventa)then
		insert into ALMACEN.TBL_PRECIO(
			id_listaprecio,
			id_producto,
			id_unidadventa,
			codbarra,
			costo ,
			flete,
			otroscostos,
			coste ,
			precio1,
			precio2,
			precio3,	
			id_estado,
			predeterminado,
			val_unidad,
			val_minimo_venta,
			ID_TIPOVENTA,
			UNDPRED_COMPRA,
			precio4,
			precio5,
			peso,
			porcent1,
			porcent2,
			porcent3,
			porcent4,
			porcent5
		)
		values(
			_id_listaprecio,
			_id_producto,
			_id_unidadventa,
			_codbarra,
			_costo ,
			_flete,
			_otroscostos,
			_coste ,
			_precio1,
			_precio2,
			_precio3,	
			_id_estado,
			_predeterminado,
			_val_unidad,
			_val_minimo_venta,
			_ID_TIPOVENTA,
			_UNDPRED_COMPRA,
			_precio4  ,
			_precio5 ,
			_peso,
			_porcent1,
			_porcent2,
			_porcent3,
			_porcent4,
			_porcent5
		)returning array[
				'0',
				TBL_PRECIO.id_producto::text,
				TBL_PRECIO.id_unidadventa::text,
				TBL_PRECIO.id_listaprecio::text
				]into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar los precios del producto'];
		end if;
	else
		res:=array['503','Verefique que los datos del producto este ingresados correctamente'];
	end if;
else
	if exists(select * from ALMACEN.TBL_PRECIO where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
		update ALMACEN.TBL_PRECIO  set 
				codbarra=_codbarra,
				costo=_costo ,
				flete=_flete,
				otroscostos=_otroscostos,
				coste=_coste ,
				precio1=_precio1,
				precio2=_precio2,
				precio3=_precio3,	
				id_estado=_id_estado,
				predeterminado=_predeterminado,
				val_unidad=_val_unidad,
				val_minimo_venta=_val_minimo_venta ,
				ID_TIPOVENTA=_ID_TIPOVENTA,
				UNDPRED_COMPRA=_UNDPRED_COMPRA,
				precio4=_precio4,
				precio5=_precio5,
				peso=_peso,
				porcent1=_porcent1,
				porcent2=_porcent2,
				porcent3=_porcent3,
				porcent4=_porcent4,
				porcent5=_porcent5
				where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio;
		res:=array['0',_id_producto::text,_id_unidadventa::text,_id_listaprecio::text];	
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 select  *from ventas.tbl_facturacion where date_part('year',fecha_venta)=fecha_reg and date_part('month',fecha_venta)=3 and id_comprobante=3

update ventas.tbl_facturacion set fecha_venta='31/03/2021' where date_part('year',fecha_venta)=2020 and date_part('month',fecha_venta)=3 and id_comprobante=3
 

select * from almacen.list_kardex_batch('14/11/2017','14/11/2019',1,1)


CREATE OR REPLACE FUNCTION almacen.spi_producto(
    op integer,
    _id_producto character varying,
    _id_familia character,
    _id_marca character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _cod_barra character varying,
    _servicio boolean,
    _id_estado integer,
    _impuesto double precision,
    _reintegro_tributario boolean,
    _partida_arancelaria character varying,
    _dev_envases boolean,
    _perecible boolean,
    _sujet_percepcion boolean,
    _vende_pack boolean,
    _obs_compra text,
    _obs_venta text,
    _caracteristicas text,
    _favorito boolean,
    _gen_correl boolean,
    _codigo character,
    _image bytea,
    _id_color integer,
    _id_impuesto integer,
    _inventariado boolean,
    _id_sucursal integer,
    _activo_fijo boolean,
    _gestiona_lotes boolean,
    _gestiona_series boolean,
    _id_modelo bigint,
    _venta_retaceo boolean,
    _garantia_meses integer ,
    _frecuencia_reviciones integer,
    _cantidad_fraccionada boolean,
    _afecto_icbper boolean,
    _solicitadatosadicionales boolean
)
  RETURNS text[] AS
$BODY$
DECLARE
	RES TEXT[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF NOT EXISTS(SELECT *FROM ALMACEN.TBL_PRODUCTO WHERE descripcion_larga=_descripcion_larga) THEN
		IF NOT EXISTS(SELECT *FROM ALMACEN.TBL_PRODUCTO WHERE trim(codigo)=trim(_codigo) and length(trim(_codigo))>0) THEN
			select MAX(ID_PRODUCTO::bigint) INTO CORREL from ALMACEN.TBL_PRODUCTO  WHERE ISNUMERIC(ID_PRODUCTO);
			IF CORREL IS NULL THEN
				CORREL:=1;
			ELSE
				CORREL:=CORREL+1;
			END IF;
			if _gen_correl=false then
				_id_producto:=CORREL::text;
			end if;
			if length(_codigo)=0 then
				_codigo=CORREL::text;
			end if;
			INSERT INTO ALMACEN.TBL_PRODUCTO(
				id_producto,
				id_familia,
				id_marca,
				descripcion_larga,
				descripcion_corta,
				cod_barra ,
				servicio  ,
				id_estado ,
				impuesto  ,
				reintegro_tributario,
				partida_arancelaria,
				dev_envases        ,
				perecible          ,
				sujet_percepcion   ,
				vende_pack         ,
				obs_compra         ,
				obs_venta          ,
				caracteristicas     ,
				favorito ,
				codigo,
				image,
				id_color,
				id_impuesto,
				INVENTARIADO,
				activo_fijo,
				GESTIONA_LOTES,
				gestiona_series,
				id_modelo,
				venta_retaceo,
				garantia_meses,
				frecuencia_reviciones,
				cantidad_fraccionada,
				afecto_icbper,
				solicitadatosadicionales
			)VALUES(
				_id_producto,
				_id_familia,
				_id_marca,
				_descripcion_larga,
				_descripcion_corta,
				_cod_barra ,
				_servicio  ,
				_id_estado ,
				_impuesto  ,
				_reintegro_tributario,
				_partida_arancelaria,
				_dev_envases        ,
				_perecible          ,
				_sujet_percepcion   ,
				_vende_pack         ,
				_obs_compra         ,
				_obs_venta          ,
				_caracteristicas     ,
				_favorito ,
				_codigo,
				_image,
				_id_color,
				_id_impuesto,
				_INVENTARIADO,
				_activo_fijo,
				_GESTIONA_LOTES,
				_gestiona_series,
				_id_modelo,
				_venta_retaceo,
				_garantia_meses,
				_frecuencia_reviciones,
				_cantidad_fraccionada,
				_afecto_icbper,
				_solicitadatosadicionales
			)returning array['0',tbl_producto.id_producto::text]into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registar el producto'];
			end if;
		ELSE
			RES:=ARRAY['503','Producto con el codigo' || COALESCE(_codigo,'') ||' ya existe'];
		END IF;
	ELSE
		RES:=ARRAY['502','Producto ' || _descripcion_larga ||' ya existe'];
	END IF;
END IF;
IF OP=2 THEN
	IF EXISTS(SELECT *FROM ALMACEN.TBL_PRODUCTO WHERE ID_PRODUCTO=_ID_PRODUCTO)THEN
		UPDATE ALMACEN.TBL_PRODUCTO SET 
			id_familia=_id_familia,
			id_marca=_id_marca,
			descripcion_larga=_descripcion_larga,
			descripcion_corta=_descripcion_corta,
			cod_barra=_cod_barra ,
			servicio=_servicio  ,
			--id_estado =_id_estado,
			impuesto=_impuesto  ,
			reintegro_tributario=_reintegro_tributario,
			partida_arancelaria=_partida_arancelaria,
			dev_envases=_dev_envases,
			perecible=_perecible,
			sujet_percepcion=_sujet_percepcion,
			vende_pack=_vende_pack,
			obs_compra=_obs_compra,
			obs_venta=_obs_venta,
			caraCteristicas=_caracteristicas,
			favorito =_favorito  ,
			codigo=_codigo,
			image=_image,
			id_color=_id_color,
			id_impuesto=_id_impuesto,
			INVENTARIADO=_INVENTARIADO,
			activo_fijo=_activo_fijo,
			GESTIONA_LOTES=_GESTIONA_LOTES,
			gestiona_series=_gestiona_series,
			id_modelo=_id_modelo,
			id_estado=_id_estado,
			venta_retaceo=_venta_retaceo,
			garantia_meses=_garantia_meses,
			frecuencia_reviciones=_frecuencia_reviciones,
			cantidad_fraccionada=_cantidad_fraccionada,
			afecto_icbper=_afecto_icbper,
			solicitadatosadicionales=_solicitadatosadicionales
			WHERE ID_PRODUCTO=_ID_PRODUCTO;
			update almacen.TBL_SALDOSEXISTENCIA set id_estado=_id_estado where id_producto=_id_producto and id_sucursal=_id_sucursal;
			RES:=ARRAY['0',cast(_ID_PRODUCTO as varchar(20))];
	ELSE
		RES:=ARRAY['504','VERIFIQUE QUE LOS DATOS DEL PRODUCTO ESTEN INGRESADO CORRECTAMENTE'];
		--RES:=ARRAY['504','VERIFIQUE QUE LOS DATOS DEL PRODUCTO ESTEN INGRESADO CORRECTAMENTE'];
	END IF;
END IF;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;





CREATE OR REPLACE FUNCTION almacen.spi_sync_producto(
    op integer,
    _id_producto character varying,
    _id_familia character,
    _id_marca character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _cod_barra character varying,
    _servicio boolean,
    _id_estado integer,
    _impuesto double precision,
    _reintegro_tributario boolean,
    _partida_arancelaria character varying,
    _dev_envases boolean,
    _perecible boolean,
    _sujet_percepcion boolean,
    _vende_pack boolean,
    _obs_compra text,
    _obs_venta text,
    _caracteristicas text,
    _favorito boolean,
    _gen_correl boolean,
    _codigo character,
    _image bytea,
    _id_color integer,
    _id_impuesto integer,
    _inventariado boolean,
    _id_sucursal integer,
    _activo_fijo boolean,
    _gestiona_lotes boolean,
    _gestiona_series boolean,
    _id_modelo bigint,
    _venta_retaceo boolean,
    _garantia_meses integer ,
    _frecuencia_reviciones integer,
    _cantidad_fraccionada boolean,
    _afecto_icbper boolean
)
  RETURNS table(statuscode integer,statusmessage text) AS
$BODY$
DECLARE
	RES TEXT[];
	correl integer;
BEGIN
IF NOT EXISTS(SELECT *FROM ALMACEN.TBL_PRODUCTO WHERE id_producto=_id_producto) THEN
	INSERT INTO ALMACEN.TBL_PRODUCTO(
		id_producto,
		id_familia,
		id_marca,
		descripcion_larga,
		descripcion_corta,
		cod_barra ,
		servicio  ,
		id_estado ,
		impuesto  ,
		reintegro_tributario,
		partida_arancelaria,
		dev_envases        ,
		perecible          ,
		sujet_percepcion   ,
		vende_pack         ,
		obs_compra         ,
		obs_venta          ,
		caracteristicas     ,
		favorito ,
		codigo,
		image,
		id_color,
		id_impuesto,
		INVENTARIADO,
		activo_fijo,
		GESTIONA_LOTES,
		gestiona_series,
		id_modelo,
		venta_retaceo,
		garantia_meses,
		frecuencia_reviciones,
		cantidad_fraccionada,
		afecto_icbper
	)VALUES(
		_id_producto,
		_id_familia,
		_id_marca,
		_descripcion_larga,
		_descripcion_corta,
		_cod_barra ,
		_servicio  ,
		_id_estado ,
		_impuesto  ,
		_reintegro_tributario,
		_partida_arancelaria,
		_dev_envases        ,
		_perecible          ,
		_sujet_percepcion   ,
		_vende_pack         ,
		_obs_compra         ,
		_obs_venta          ,
		_caracteristicas     ,
		_favorito ,
		_codigo,
		_image,
		_id_color,
		_id_impuesto,
		_INVENTARIADO,
		_activo_fijo,
		_GESTIONA_LOTES,
		_gestiona_series,
		_id_modelo,
		_venta_retaceo,
		_garantia_meses,
		_frecuencia_reviciones,
		_cantidad_fraccionada,
		_afecto_icbper
	) ;
	return query select  1 as statuscode,'Producto Registrado' as statusmessage ;
ELSE
		UPDATE ALMACEN.TBL_PRODUCTO SET 
			id_familia=_id_familia,
			id_marca=_id_marca,
			descripcion_larga=_descripcion_larga,
			descripcion_corta=_descripcion_corta,
			cod_barra=_cod_barra ,
			servicio=_servicio  ,
			--id_estado =_id_estado,
			impuesto=_impuesto  ,
			reintegro_tributario=_reintegro_tributario,
			partida_arancelaria=_partida_arancelaria,
			dev_envases=_dev_envases,
			perecible=_perecible,
			sujet_percepcion=_sujet_percepcion,
			vende_pack=_vende_pack,
			obs_compra=_obs_compra,
			obs_venta=_obs_venta,
			caraCteristicas=_caracteristicas,
			favorito =_favorito  ,
			codigo=_codigo,
			image=_image,
			id_color=_id_color,
			id_impuesto=_id_impuesto,
			INVENTARIADO=_INVENTARIADO,
			activo_fijo=_activo_fijo,
			GESTIONA_LOTES=_GESTIONA_LOTES,
			gestiona_series=_gestiona_series,
			id_modelo=_id_modelo,
			id_estado=_id_estado,
			venta_retaceo=_venta_retaceo,
			garantia_meses=_garantia_meses,
			frecuencia_reviciones=_frecuencia_reviciones,
			cantidad_fraccionada=_cantidad_fraccionada,
			afecto_icbper=_afecto_icbper
		WHERE ID_PRODUCTO=_ID_PRODUCTO;
		return query select  1 as statuscode,'Producto actualizada' as statusmessage ;
		  
END IF;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


 

select * from GRIFO.ISP_GRABARLECCONTOMETRO(2,1,2,1,'2017-05-30 18:41:46.45','0.00','0.00','0.00','0.00','10.9000','11.207','122.1563',1,'1',1,'1',2,1,'0','8951.5350','8962.7420')


CREATE OR REPLACE FUNCTION grifo.isp_grabarleccontometro(
    op integer,
    _id_isla integer,
    _id_lado integer,
    _id_turno integer,
    _fecha text,
    _gal_entrada numeric,
    _gal_salida numeric,
    _imp_entrada numeric,
    _imp_salida numeric,
    _precio_lista numeric,
    _result_gal numeric,
    _result_imp numeric,
    _id_estado integer,
    _id_usuario character,
    _id_sucursal integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _liquidado boolean,
    _lecinicial numeric(20,4),
    _lecfinal numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	RES TEXT[];
BEGIN
 if op =1 then
	if not exists(select *from GRIFO.TBL_LECCONTOMETRO 
		where id_lado=_id_lado and id_isla=_id_isla and 
		id_turno=_id_turno and fecha=cast(_fecha as date) and 
		id_sucursal=_id_sucursal and id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
		insert into GRIFO.TBL_LECCONTOMETRO(
			id_isla,
			id_lado,
			id_turno,
			fecha,
			gal_entrada,
			gal_salida,
			imp_entrada,
			imp_salida,
			precio_lista,
			result_gal ,
			result_imp ,
			id_estado  ,
			id_usuario ,
			id_sucursal,
			id_producto ,
			id_unidadventa,
			id_listaprecio,
			liquidado,
			lecinicial,
			lecfinal
			
		)values(
			_id_isla,
			_id_lado,
			_id_turno,
			cast(_fecha as date),
			_gal_entrada,
			_gal_salida,
			_imp_entrada,
			_imp_salida,
			_precio_lista,
			_result_gal ,
			_result_imp ,
			_id_estado  ,
			_id_usuario ,
			_id_sucursal,
			_id_producto ,
			_id_unidadventa,
			_id_listaprecio,
			_liquidado,
			_lecinicial,
			_lecfinal
		)returning array['0',TBL_LECCONTOMETRO.id_lado::TEXT ||
					TBL_LECCONTOMETRO.id_isla::TEXT ||
					TBL_LECCONTOMETRO.id_turno::TEXT ||
					TBL_LECCONTOMETRO.fecha::TEXT ||
					TBL_LECCONTOMETRO.id_sucursal::TEXT,
					'Proceso efectuado con exito'] INTO res;
		if not found then
			res:=array['504','Ha ocurrido una inconsitencia inesperada'];
		end if;
	else
		update GRIFO.TBL_LECCONTOMETRO set 		
			gal_entrada=_gal_entrada,
			gal_salida=_gal_salida,
			imp_entrada=_imp_entrada,
			imp_salida=_imp_salida,
			precio_lista=_precio_lista,
			result_gal =_result_gal,
			result_imp =_result_imp ,
			id_estado  =_id_estado ,
			id_usuario=_id_usuario  ,
			liquidado=_liquidado,
			lecinicial=_lecinicial,
			lecfinal=_lecfinal
			where id_lado=_id_lado and id_isla=_id_isla and 
		id_turno=_id_turno and fecha=cast(_fecha as date) and 
		id_sucursal=_id_sucursal and id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio
		returning array['0',TBL_LECCONTOMETRO.id_lado::TEXT ||
					TBL_LECCONTOMETRO.id_isla::TEXT ||
					TBL_LECCONTOMETRO.id_turno::TEXT ||
					TBL_LECCONTOMETRO.fecha::TEXT ||
					TBL_LECCONTOMETRO.id_sucursal::TEXT,
					'Proceso efectuado con exito'] INTO res;
		
		--res:=array['503','La media del contometro ya han sido ingresado'];
	end if;
 end if;
 if op=2 then
	if  exists(select *from GRIFO.TBL_LECCONTOMETRO 
		where id_lado=_id_lado and id_isla=_id_isla and 
		id_turno=_id_turno and fecha=cast(_fecha as date) and 
		id_sucursal=_id_sucursal and id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
		update GRIFO.TBL_LECCONTOMETRO set 		
			gal_entrada=_gal_entrada,
			gal_salida=_gal_salida,
			imp_entrada=_imp_entrada,
			imp_salida=_imp_salida,
			precio_lista=_precio_lista,
			result_gal =_result_gal,
			result_imp =_result_imp ,
			id_estado  =_id_estado ,
			id_usuario=_id_usuario  ,
			liquidado=_liquidado,
			lecinicial=_lecinicial,
			lecfinal=_lecfinal
			where id_lado=_id_lado and id_isla=_id_isla and 
		id_turno=_id_turno and fecha=cast(_fecha as date) and 
		id_sucursal=_id_sucursal and id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio
		returning array['0',TBL_LECCONTOMETRO.id_lado::TEXT ||
					TBL_LECCONTOMETRO.id_isla::TEXT ||
					TBL_LECCONTOMETRO.id_turno::TEXT ||
					TBL_LECCONTOMETRO.fecha::TEXT ||
					TBL_LECCONTOMETRO.id_sucursal::TEXT,
					'Proceso efectuado con exito'] INTO res;
	else
		res:=array['501','Verifique que exista el registro : ' || cast(_fecha as date)::text];
	end if;
 end if;
 return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
 
CREATE OR REPLACE FUNCTION configuracion.isp_config_parametros_sucursal(
    op integer,
    _id_configsucursal bigint,
    _idflagconfig integer,
    _id_sucursal integer,
    _estado boolean,
    _value numeric)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	id integer;
BEGIN
if op=1 then
	if not exists(select * from configuracion.tbl_configsucursal where idflagconfig=_idflagconfig and id_sucursal=_id_sucursal)then
		select max(id_configsucursal) into id from configuracion.tbl_configsucursal;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		insert into configuracion.tbl_configsucursal(id_configsucursal,idflagconfig,id_sucursal,estado,value)values(id,_idflagconfig,_id_sucursal,_estado,_value)
		returning array['0','Proceso efectuado con existo'] into res;
	ELSE
		res:=array['504','El registro ya existe verefique en el listado'];
	end if;
end if;
if op=2 then
	if exists(select 1 from configuracion.tbl_configsucursal where id_configsucursal=_id_configsucursal )then
		update configuracion.tbl_configsucursal set estado=_estado ,value=_value
		where id_configsucursal=_id_configsucursal returning array['0','Registro actualizado con exito-'] into res;
	else
		res:=array['504','verefique que exista el registro para realizar el proceso de actualización'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from CREDITOS.TBL_CREDITO where liquidacion_id is not null

CREATE OR REPLACE FUNCTION creditos.spi_credito(
    op integer,
    _id_credito integer,
    _fec_emision text,
    _imp_credito numeric,
    _nro_cuotas integer,
    _imp_recargo numeric,
    _imp_cuotacapital numeric,
    _imp_cuota numeric,
    _imp_amortizacion numeric,
    _intervalo_cuota integer,
    _nro_cuotas_pago_interes integer,
    _dias_gracia integer,
    _id_sucursal_credito integer,
    _id_estado integer,
    _id_prodcreditos integer,
    _id_nrocuenta bigint,
    _liquidacion_id bigint,
    _fecha_liquidacion text
)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
if op=1 then
	if not  exists(select *from CREDITOS.TBL_CREDITO where id_sucursal_credito=_id_sucursal_credito and id_credito=_id_credito) then
		if exists(select *from common.tbl_sucursal where id_sucursal=_id_sucursal_credito) then
			select max(id_credito) into correl from CREDITOS.TBL_CREDITO where id_sucursal_credito=_id_sucursal_credito;
			if correl is null then
				correl:=1;
			else
				correl=correl+1;
			end if;
			_id_credito:=correl;
			insert into CREDITOS.TBL_CREDITO(
				id_credito ,
				fec_emision,
				imp_credito,
				nro_cuotas ,
				imp_recargo,
				imp_cuotacapital,
				imp_cuota ,
				imp_amortizacion,
				intervalo_cuota ,
				nro_cuotas_pago_interes,
				dias_gracia ,
				id_sucursal_credito,
				id_estado ,
				id_prodcreditos,
				id_nrocuenta ,liquidacion_id,fecha_liquidacion
			)
			values(
				correl ,
				to_timestamp(_fec_emision,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_credito,
				_nro_cuotas ,
				_imp_recargo,
				_imp_cuotacapital,
				_imp_cuota ,
				_imp_amortizacion,
				_intervalo_cuota ,
				_nro_cuotas_pago_interes,
				_dias_gracia ,
				_id_sucursal_credito,
				_id_estado ,
				_id_prodcreditos,
				case when _id_nrocuenta=0 then null else _id_nrocuenta end ,
				_liquidacion_id,
				_fecha_liquidacion::date
			) returning array['0',TBL_CREDITO.id_credito::text,TBL_CREDITO.id_sucursal_credito::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el credito, verefique que los datos esten ingresados correctamente'];
			end if;
		else
			res:=array['504','Verefique que la sucursal en la que ha ingresado sea la correcta'];
		end if;
	else
		 RAISE NOTICE 'id_credito%', _id_credito::text;
		res:=array['0',_id_credito::text,_id_sucursal_credito::text];
	end if;
	
end if;
if op=2 then
	if exists (select *from  CREDITOS.TBL_CREDITO where id_credito=_id_credito  and id_sucursal_credito=_id_sucursal_credito) then
		update CREDITOS.TBL_CREDITO set
			fec_emision=to_timestamp(_fec_emision,'YYYY-MM-DD HH24:MI:SS.MS'),
			imp_credito=_imp_credito,
			nro_cuotas=_nro_cuotas ,
			imp_recargo=_imp_recargo,
			imp_cuotacapital=_imp_cuotacapital,
			imp_cuota=_imp_cuota ,
			imp_amortizacion=_imp_amortizacion,
			intervalo_cuota=_intervalo_cuota ,
			nro_cuotas_pago_interes=_nro_cuotas_pago_interes,
			dias_gracia=_dias_gracia ,
			id_estado=_id_estado ,
			id_prodcreditos=_id_prodcreditos,
			id_nrocuenta=_id_nrocuenta,
			liquidacion_id=_liquidacion_id,
			fecha_liquidacion=_fecha_liquidacion::date
		where id_credito=_id_credito  and id_sucursal_credito=_id_sucursal_credito;
		res:=array['0',_id_credito::text,_id_sucursal_credito::text];
	else
		res:=array['503','No existe el registro de credito verefique este seleccionado correctamente el documento'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION VENTAS.FN_ANULARRBOVALESCONSUMO(
	_id_consumovale bigint  
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN
IF EXISTS(SELECT 1 FROM ventas.tbl_consumovales WHERE id_consumovale=_id_consumovale) THEN
	UPDATE ventas.tbl_consumovales SET id_estado=7 WHERE id_consumovale=_id_consumovale;
	res:=array['0','Registro Anulado'];
ELSE
	res:=array['0','Seleccione Correctamente el regitro'];
END IF;
return res;
END;$$
LANGUAGE 'plpgsql';


select * from VENTAS.FN_RBOVALESCONSUMO(2,18,'0001','0000001','2017-05-12 21:48:28.227',54,1,18,'','','',190,'60.0000','9.6000','576.0000','17',1,'3',2,1,'DIESEL B5 fhfgfgh',8);

select *from ventas.tbl_consumovales v

select *from VENTAS.v_recibo_vales_consumo


CREATE OR REPLACE   FUNCTION VENTAS.FN_RBOVALESCONSUMO(
	_op integer,
	_id_consumovale bigint  ,
	_serie char(4),
	_numero varchar(7),
	_fecha_consumo VARCHAR(100),	
	_id_comprobante integer ,
	_id_sucursal integer,
	_id_vale integer ,
	_vehiculo character varying(50),
	_placa character varying(20),
	_conductor character varying(50)	,
	_id_direccion bigint  ,
	_cantidad numeric(20,4),
	_precio numeric(20,4),
	_imp_total numeric(20,4),
	_id_cliente character varying(15)  ,
	_id_isla integer  ,
	_id_producto character varying(20) ,
	_id_unidadventa integer  ,
	_id_listaprecio integer,
	_Glosa varchar(250),
	_id_caja integer,
	_id_turno integer
)
RETURNS TEXT[] AS  $$
DECLARE
	res text[];
	id bigint;
	_id_almacen integer;
BEGIN
  _id_almacen:=(select a.id_almacen    from almacen.tbl_almacen a
	inner join almacen.tbl_existencia e on e.id_almacen=a.id_almacen where id_sucursal=_id_sucursal and e.id_producto=_id_producto and e.id_unidadventa=_id_unidadventa  );
if _op=1 then
	if exists(select  * from ventas.tbl_valesconsumo where id_vale=_id_vale and id_sucrusal_vale=_id_sucursal) then
		if exists(select *from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion =_id_direccion)then
				select max(id_consumovale) into id from ventas.tbl_consumovales;
				if id is null then
					id:=1;
				else
					id:=id+1;
				end if;
				INSERT INTO ventas.tbl_consumovales(
					id_consumovale ,
					serie ,
					numero ,
					fecha_consumo ,	
					id_comprobante ,
					id_sucursal ,
					id_vale  ,
					vehiculo ,
					placa ,
					conductor ,
					id_direccion ,
					cantidad ,
					precio ,
					imp_total,
					id_cliente ,
					id_isla  ,
					id_producto ,
					id_unidadventa ,
					id_listaprecio ,
					glosa,
					id_almacen,
					id_caja,
					id_turno
				)VALUES(
					id ,
					_serie ,
					_numero ,
					_fecha_consumo::DATE ,	
					_id_comprobante ,
					_id_sucursal ,
					_id_vale  ,
					_vehiculo ,
					_placa ,
					_conductor ,
					_id_direccion ,
					_cantidad ,
					_precio ,
					_imp_total,
					_id_cliente ,
					_id_isla  ,
					_id_producto ,
					_id_unidadventa ,
					_id_listaprecio ,
					_glosa,
					_id_almacen,
					_id_caja,
					_id_turno
				);
				res:= array['0','Recibo registrado'] ;
				if not found then
					res:=array['504','Inconsistencia inesperada al momento de registar el detalle del vale de Consumo'];
				end if;
			else
				res:=array['501','Verfique que el cliente este seleccionado correctamente'];
			end if;
		else
			res:=array['502','Seleccione correctamente el producto'];
		end if;
	else
		res:=array['503','Verfique que exista el vale de consumo'];
	end if;
end if;
if _op=2 then
 
if exists(select  1 from ventas.tbl_valesconsumo where id_vale=_id_vale and id_sucrusal_vale=_id_sucursal) then
		if exists(select 1 from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			if exists(select 1 from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion =_id_direccion)then				 				
				update ventas.tbl_consumovales set
					serie=_serie ,
					numero=_numero ,
					fecha_consumo=_fecha_consumo::DATE ,	
					id_comprobante=id_comprobante ,
					id_sucursal=_id_sucursal ,
					id_vale =_id_vale ,
					vehiculo=_vehiculo ,
					placa=_placa ,
					conductor =_conductor,
					id_direccion=_id_direccion ,
					cantidad=cantidad ,
					precio=_precio ,
					imp_total=_imp_total,
					id_cliente=_id_cliente ,
					id_isla=_id_isla  ,
					id_producto =_id_producto,
					id_unidadventa=_id_unidadventa ,
					id_listaprecio=_id_listaprecio ,
					glosa=_glosa,
					id_almacen=_id_almacen,
					id_caja=_id_caja,
					id_turno=_id_turno
				 where id_consumovale=_id_consumovale;
				 res:= array['0','Registro actualizado '|| cast(_id_consumovale as varchar(10))];
				
			else
				res:=array['501','Verfique que el cliente este seleccionado correctamente'];
			end if;
		else
			res:=array['502','Seleccione correctamente el producto'];
		end if;
	else
		res:=array['503','Verfique que exista el vale de consumo'];
	end if;
end if;
return res;
END;$$
language 'plpgsql';




CREATE OR REPLACE FUNCTION ventas.spiu_detvaleconsumo(
    op integer,
    _id_vale integer,
    _cantidad numeric,
    _lista integer,
    _precio numeric,
    _imp_dsct numeric,
    _total numeric,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _item integer,
    _id_estado integer,
    _id_sucrusal_vale integer 
   )
  RETURNS text[] AS
$BODY$
  DECLARE 
	res text[];
	_id_almacen integer;
  BEGIN
if(op=1) then
	select id_almacen into _id_almacen from almacen.tbl_almacen where id_sucursal=_id_sucrusal_vale;
	if _id_vale<>0 then
		 insert into ventas.tbl_detvale(
		  id_vale,
		  cantidad,
		  lista,
		  precio,
		  imp_dsct,
		  total,
		  id_producto,
		  id_unidadventa,
		  id_listaprecio,
		  item,
		  id_estado,
		  id_sucrusal_vale,
		  id_almacen
		)values(
		  _id_vale,
		  _cantidad,
		  _lista,
		  _precio,
		  _imp_dsct,
		  _total,
		  _id_producto,
		  _id_unidadventa,
		  _id_listaprecio,
		  _item,
		  _id_estado,
		  _id_sucrusal_vale,
		  _id_almacen
		)returning array['0',tbl_detvale.id_vale::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al momento de registar el detalle del vale de Consumo'];
		end if;
	else
		res:=array['0',_id_vale::text];
	end if;
end if;
if (op=2) then
	if exists (select 1 from ventas.tbl_detvale where id_producto = _id_producto and id_unidadventa = _id_unidadventa and 
		id_listaprecio = _id_listaprecio and id_vale = _id_vale and item = _item and id_sucrusal_vale = _id_sucrusal_vale) then
		update ventas.tbl_detvale set
			  cantidad  =   _cantidad,
			  lista	    = 	_lista,
			  precio  =   _precio,
			  imp_dsct = _imp_dsct,
			  total  =   _total,
			  id_estado  =   _id_estado,
			  id_almacen=_id_almacen
		where id_producto = _id_producto and id_unidadventa = _id_unidadventa and 
		id_listaprecio = _id_listaprecio and id_vale = _id_vale and item = _item and id_sucrusal_vale = _id_sucrusal_vale;
		res:= array['0', _id_vale::text, _id_sucrusal_vale::text, _id_producto, _id_unidadventa::text, _id_listaprecio::text, _item::text];
	else
		res:=array['504','Verifique que los datos del detalle del vale de Consumo esten ingresados correctamente'];
	end if;
end if;
return res;
  END;
  $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION VENTAS.FN_MOVIMIENTOS_STOCK(
	Desde varchar(10),
	Hasta varchar(10),
	_id_empresa integer
)
RETURNS TABLE(
	codarti text,
	descrip text, 
	grupo text,
	linea text,
	unidmed text,  
	contenido numeric(20,6)  ,
	fecha timestamp, 
	tipodoc text,
	documento text,
	cliprov text, 
	ruc text,
	cant1 numeric(20,6) ,
	c_unid1 numeric(20,6) ,
	total1 numeric(20,6) ,
	cant2 numeric(20,6) ,
	c_unid2 numeric(20,6),
	total2 numeric(20,6) ,
	cant3 numeric(20,6) , 
	c_unid3 numeric(20,6), 
	total3 numeric(20,6), 
	movi TEXT,
	fila integer,
	idunimed  char(3),
	idalmacen integer,
	tot_cant numeric(20,6),
	tot_saldo numeric(20,6)
) AS $$
DECLARE
	dat record;
	_id_empresa integer;
	_saldo numeric(20,4);
	_costo_prom numeric(20,4);
	dventas record;
	res text[];
BEGIN
 


CREATE TEMPORARY TABLE  tmp_movimiento_stock (
			_codarti text,
			_descrip text, 
			_grupo text,
			_linea text,
			_unidmed text,  
			_contenido numeric(20,6) default 0.00,
			_fecha timestamp, 
			_tipodoc text,
			_documento text,
			_cliprov text, 
			_ruc text,
			_cant1 numeric(20,6) default 0.00,
			_c_unid1 numeric(20,6) default 0.00,
			_total1 numeric(20,6) default 0.00,
			_cant2 numeric(20,6) default 0.00,
			_c_unid2 numeric(20,6) default 0.00,
			_total2 numeric(20,6) default 0.00,
			_cant3 numeric(20,6) default 0.00, 
			_c_unid3 numeric(20,6) default 0.00, 
			_total3 numeric(20,6) default 0.00, 
			_movi TEXT,
			_fila integer,
			_idunimed  char(3),
			_idalmacen integer,
			_tot_cant numeric(20,6),
			_tot_saldo numeric(20,6)
		) ON COMMIT DROP;

FOR dventas in select distinct df.id_producto,df.id_almacen,df.id_unidadventa,s.id_empresa from ventas.tbl_facturacion f 
		inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
		inner join common.tbl_sucursal s on s.id_sucursal=f.id_sucursal
		where f.fecha_venta::date=Desde::date 
		UNION
		SELECT distinct dv.id_producto,dv.id_almacen,dv.id_unidadventa,s.id_empresa FROM ventas.tbl_consumovales DV
		--  INNER JOIN ventas.tbl_detvale dv on v.id_vale=dv.id_vale and v.id_sucrusal_vale=dv.id_sucrusal_vale
		  INNER JOIN common.tbl_sucursal s on s.id_sucursal=dv.id_sucursal
		  WHERE fecha_consumo::date=Desde::date 
		loop

	FOR dat in select * from almacen.list_movimientoventaskardex(Desde,Hasta,'09','1',' where id_empresa='|| dventas.id_empresa ||'and id_almacen='|| dventas.id_almacen ||' and id_producto = '''|| dventas.id_producto  ||'''  and idunimed='|| dventas.id_unidadventa ||'',1) loop
		insert into tmp_movimiento_stock(
					_codarti, 
					_descrip,
					_grupo,
					_linea, 
					_unidmed, 
					_contenido, 
					_fecha, 
					_tipodoc, 
					_documento, 
					_cliprov, 
					_ruc,
					_cant1, 
					_c_unid1, 
					_total1, 
					_cant2, 
					_c_unid2, 
					_total2, 
					_cant3, 
					_c_unid3, 
					_total3, 
					_movi, 
					_fila,
					_idunimed,
					_idalmacen
				)
				values(
					dat.codarti, 
					dat.descrip,
					dat.grupo,
					dat.linea, 
					dat.unidmed, 
					dat.contenido, 
					dat.fecha, 
					dat.tipodoc, 
					dat.documento, 
					dat.cliprov, 
					dat.ruc,
					dat.cant1, 
					dat.c_unid1, 
					dat.total1, 
					dat.cant2, 
					dat.c_unid2, 
					dat.total2, 
					dat.cant3, 
					dat.c_unid3, 
					dat.total3, 
					dat.movi, 
					dat.fila,
					dat.idunimed,
					dat.idalmacen
				);
				
	end loop;
	drop table tmp_kdx_val;
	--drop table tmpcompra;
end loop;
	
	 return query SELECT 
		_codarti ,
			_descrip , 
			_grupo ,
			_linea ,
			COALESCE(_unidmed , '-') as _unidmed,
			_contenido ,
			_fecha , 
			COALESCE(_tipodoc,'') as _tipodoc,
			COALESCE(_documento ,'-') as _documento,
			_cliprov , 
			COALESCE(_ruc,'') _ruc ,
			_cant1 ,
			_c_unid1 ,
			_total1 ,
			_cant2 ,
			_c_unid2 ,
			_total2 ,
			_cant3 , 
			_c_unid3 , 
			_total3 , 
			_movi ,
			_fila ,
			_idunimed ,
			_idalmacen ,
			_tot_cant ,
			COALESCE(_tot_saldo,0) as _tot_saldo  FROM tmp_movimiento_stock;
END;$$
language 'plpgsql'






CREATE OR REPLACE FUNCTION ALMACEN.FN_TRIGGERR_ACTUALIZA_STOCK()
RETURNS trigger AS $$
DECLARE
	dat record;
	_id_empresa integer;
	_saldo numeric(20,4);
	_costo_prom numeric(20,4);
	res text[];
BEGIN
select e.id_empresa into _id_empresa from common.tbl_empresa e 
inner join common.tbl_sucursal s on s.id_empresa=e.id_empresa
inner join almacen.tbl_almacen a on a.id_sucursal=s.id_sucursal
where a.id_almacen=new.id_almacen;
	FOR dat in select * from almacen.list_kardex('01/09/2016',to_char(new.fecha,'dd/MM/YYYY'),'09','1',' where id_empresa='|| _id_empresa ||'and id_almacen='|| new.id_almacen ||' and id_producto = '''|| new.id_producto  ||'''  and idunimed='|| new.id_unidadventa ||'',1) loop
		_saldo=dat.cant3;
		_costo_prom=dat.c_unid3;
	end loop;
	update almacen.tbl_existencia set stock_fisico=_saldo,costo_promedio=_costo_prom 
		where id_producto=new.id_producto and id_almacen=new.id_almacen and id_unidadventa=new.id_unidadventa;
	insert into  almacen.tbl_temexistencia (id_producto,id_unidad,id_almacen,cantidad,cantidad_trans)values(new.id_producto,new.id_unidadventa,new.id_almacen,_saldo,-1*new.cantidad);
	  DROP TABLE tmp_kdx_val;
	return new;
END;$$
language 'plpgsql'




CREATE OR REPLACE FUNCTION ALMACEN.FN_TRIGGERR_ACTUALIZA_STOCK_MOVALM()
RETURNS trigger AS $$
DECLARE
	dat record;
	_id_empresa integer;
	_saldo numeric(20,4);
	_costo_prom numeric(20,4);
	res text[];
BEGIN
select e.id_empresa into _id_empresa from common.tbl_empresa e 
inner join common.tbl_sucursal s on s.id_empresa=e.id_empresa
inner join almacen.tbl_almacen a on a.id_sucursal=s.id_sucursal
where a.id_almacen=new.id_almacen;
	FOR dat in select * from almacen.list_kardex('24/09/2016',to_char(new.fecha,'dd/MM/YYYY'),'09','1',' where id_empresa='|| _id_empresa ||'and id_almacen='|| new.id_almacen ||' and id_producto = '''|| new.id_producto  ||'''  and idunimed='|| new.id_unidadkardex ||'',1) loop
		_saldo=dat.cant3;
		_costo_prom=dat.c_unid3;
	end loop;
	update almacen.tbl_existencia set stock_fisico=_saldo,costo_promedio=_costo_prom 
		where id_producto=new.id_producto and id_almacen=new.id_almacen and id_unidadventa=new.id_unidadkardex;
	insert into  almacen.tbl_temexistencia (id_producto,id_unidad,id_almacen,cantidad,cantidad_trans)values(new.id_producto,new.id_unidadkardex,new.id_almacen,_saldo,new.cantidad);
	   DROP TABLE tmp_kdx_val;
	return new;
END;$$
language 'plpgsql';



  select *from almacen.tbl_temexistencia
  select *from almacen.tbl_existencia where id_producto='1756'




CREATE TRIGGER TRIGGER_KARDEX_DETFACTURACION BEFORE INSERT OR UPDATE ON ventas.tbl_detfacturacion
    FOR EACH ROW EXECUTE PROCEDURE ALMACEN.FN_TRIGGERR_ACTUALIZA_STOCK();

    
CREATE TRIGGER TRIGGER_KARDEX_DETMOVALM BEFORE INSERT OR UPDATE ON ALMACEN.tbl_detmovalm 
    FOR EACH ROW EXECUTE PROCEDURE ALMACEN.FN_TRIGGERR_ACTUALIZA_STOCK_MOVALM();


DROP TRIGGER trigger_kardex_detmovalm ON almacen.tbl_detmovalm;


SELECT *FROM ALMACEN.tbl_detmovalm WHERE ID_PRODUCTO='475' AND LP=1

UPDATE ALMACEN.tbl_detmovalm SET LP=1 WHERE ID_PRODUCTO='475' AND LP=1 AND ID_MOVIMIENTO=28000100071231

select *from almacen.tbl_temexistencia
 
UPDATE almacen.TBL_EXISTENCIA SET STOCK_fisico=20 WHERE ID_PRODUCTO='475' and id_unidadventa=3 and id_almacen=1

select *from  almacen.TBL_EXISTENCIA WHERE ID_PRODUCTO='475'

update ventas.tbl_detfacturacion set cantidad=1 where id_facturacion=14030 and id_producto='475'

select *from ventas.tbl_facturacion  where date_part('year',fecha_venta)=2017

select *from ventas.tbl_detfacturacion where id_facturacion=14030


SELECT *FROM ALMACEN.TBL_EXISTENCIA WHERE ID_PRODUCTO='475'

create table almacen.tbl_temexistencia(
	id_producto varchar(20),
	id_unidad int,
	id_almacen integer,
	cantidad_antes numeric(24,4),
	cantidad numeric(20,4),
	fecha timestamp default now(),
	tipo char(1),
	cantidad_trans numeric(20,4)
)

alter table almacen.tbl_temexistencia add column cantidad_trans numeric(20,4)


CREATE OR REPLACE FUNCTION SEGURIDAD.FN_INSERTMENU(
  op integer,
  _item integer  ,
  _fk_codmenu integer,
  _descripcion character varying(30),
  _item_orden integer,
  _evento character varying(200),
  _estado boolean,
  _menu_item boolean,
  _orden character(18),
  _menu character varying(100),
  _tooltip text,
  _icono text,
  _maximised character(1),
  _toolbar boolean
)
RETURNS TEXT[] AS  $$
DECLARE 
	correlItem integer;
	res text[];
BEGIN
if op=1 then
	if exists(select 1 from seguridad.tbl_item where item=_fk_codmenu) then
		select max(item) into correlItem from seguridad.item;
		if correlItem is null then
			correlItem:=1;
		else
			correlItem:=correlItem+1;
		end if;
		INSERT INTO seguridad.item(
		    item, 
		    fk_codmenu, 
		    descripcion, 
		    item_orden, 
		    evento, 
		    estado, 
		    menu_item, 
		    orden, 
		    menu, 
		    tooltip, 
		    icono, 
		    maximised, 
		    toolbar, 
		    id_modulo, 
		    mnu_favorito
		   )
		VALUES (
		    correlItem, 
		    case when _fk_codmenu=-1 then null else _fk_codmenu end, 
		    _descripcion, 
		    _item_orden, 
		    _evento, 
		    _estado, 
		    _menu_item, 
		    _orden, 
		    _menu, 
		    _tooltip, 
		    _icono, 
		    _maximised, 
		    false, 
		    1, 
		    false
		    
			
		);
		
		res:=array['0','Item regisrado'];
	else	
		res:=array['501','Seleccione correctamente el menu principal'];
	end if;
end if;

if op=2 then
	if exists(select 1 from seguridad.item where item=_item) then
		UPDATE seguridad.item
		   SET 
			fk_codmenu=case when _fk_codmenu=-1 then null else _fk_codmenu end, 
			descripcion=_descripcion, 
			item_orden=_item_orden, 
			evento=_evento, 
			estado=_estado, 
			menu_item=_menu_item, 
			orden=_orden, 
			menu=_menu, 
			tooltip=_tooltip, 
			icono=_icono, 
			maximised=_maximised, 
		       toolbar=_toolbar 
		 WHERE item=_item;
		res:=array['0','Item Actualizado'];
	else
		res:=array['501','Seleccione correctamente el item'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';




CREATE OR REPLACE FUNCTION creditos.isp_garbarimgenbaucher(
    _id_movimcaja integer,
    _id_sucursal integer,
    _vaucher bytea)
  RETURNS text[] AS
$BODY$
declare
	res text;
begin
if exists(select 1 from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal) then
	update caja.tbl_movcaja set vaucher=_vaucher where id_movimcaja=_id_movimcaja and id_sucursal=_id_sucursal;
	res:=array['0','Registro procesado con exito'];
else
	res:=array['504','Seleccione correctamente el registro'];
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



 

CREATE OR REPLACE FUNCTION caja.spi_movcajacuotactas_x_pagar(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _puntos numeric,
    _id_cuenta integer,
    _id_concepto character varying,
    _id_centrocostos integer,
    _cheque boolean,
    _id_tipocheque integer,
    _dni_cliente character,
    _nomape_cliente text,
    _id_personaingdiv character varying,
    _importe_mn numeric,
    _importe_tc numeric)
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from caja.tbl_cajabanco where id_cajabanco=_id_caja_destino) then
		select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
		if correl is  null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CAJA.TBL_MOVCAJA(
			id_movimcaja,
			id_facturacion,
			id_caja_destino,
			id_persona,
			id_sucursal_fac,
			serie,
			numero,
			fecha_mov,
			descargo ,
			imp_mora ,
			imp_movimiento,
			imp_recibido  ,
			imp_vuelto    ,
			glosa         ,
			id_comprobante,
			id_moneda     ,
			id_tipocambio ,
			id_sucursal   ,
			id_usuario    ,
			doc_referencia,
			id_estado,
			id_tranzaccion,
			id_turno,
			id_cuenta,
			id_concepto,
			id_centrocostos,
			signo,
			cheque,
			dni_cliente,
			nomape_cliente,
			id_personaingdiv,
			IMPORTE_MN,
			IMPORTE_TC
		)values(
			correl,
			case when _id_facturacion =0 then null else _id_facturacion end ,
			_id_caja_destino,
			_id_persona,
			case when _id_sucursal_fac=0 then null else _id_sucursal_fac end,
			_serie,
			_numero,
			to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			_descargo ,
			_imp_mora ,
			_imp_movimiento,
			_imp_recibido  ,
			_imp_vuelto    ,
			_glosa         ,
			_id_comprobante,
			_id_moneda     ,
			_id_tipocambio ,
			_id_sucursal   ,
			_id_usuario    ,
			_doc_referencia,
			_id_estado,
			_id_tranzaccion,
			_id_turno,
			_id_cuenta,
			_id_concepto,
			_id_centrocostos,
			-1,
			_cheque,
			_dni_cliente,
			_nomape_cliente,
			_id_personaingdiv,
			_IMPORTE_MN,
			_IMPORTE_TC
		) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
		end if;
	else
		res:=array['504','Verefique que la caja este ingresado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from ventas.tbl_facturacion

SELECT *FROM almacen.tbl_seriecompra

select *from seguridad.v__documento__usuario


select distinct * from almacen.v_serie_producto   where id_producto='002985' and id_almacen=1 and id_unidadventa=87 and nro_serie ilike '%%'

select * from almacen.v_serie_producto   where id_producto='002985' and id_almacen=1 and id_unidadventa=9 and nro_serie ilike '%%'


select * from almacen.isp_grabarseries(1,1,'1',0,'4444545','6545645',2017,2017,1,1,'002985',87,'',1,11,0)

CREATE OR REPLACE FUNCTION compras.isp_seriecompra(
    op integer,
    __id_usuario character,
    __id_estado integer,
    __id_sucursalcompra integer,
    __id__compra bigint,
    __id_almacen integer,
    __id_serie bigint,
    __observaciones text,
    __item integer)
  RETURNS text[] AS
$BODY$
declare
	__res text[];
begin
if op=1 then
	delete from almacen.tbl_seriecompra where id_sucursalcompra=__id_sucursalcompra and id__compra=__id__compra and id_serie=__id_serie;
	if exists(select 1 from ALMACEN.TBL_SERIEPRODUCTO where id_Serie=__id_serie)then
		if exists(select 1 from COMPRAS.TBL_COMPRA c where (c.id_sucursalcompra=__id_sucursalcompra and id__compra=__id__compra))then
			INSERT INTO almacen.tbl_seriecompra(
				fecha_compra, 
				id_usuario_r, 
				id_estado, 
				id_sucursalcompra, 
				id__compra, 
				id_almacen, 
				id_serie, 
				observaciones, 
				fecha_registro,
				item
			)
			VALUES (
				NOW(), 
				__id_usuario,  
				__id_estado, 
				__id_sucursalcompra, 
				__id__compra, 
				__id_almacen, 
				__id_serie, 
				__observaciones, 
				now(),
				__item
			)returning array['0','Proceso efectuado con exito'] INTO __res;
			if not found then
				__res:=array['504','Inconsistencia Inesperada al vincular el Nro.serie con el con el documento de compra'];
			end if;
		else
			__res:=array['503','Vererique que exista la compra'];
		end if;
	else
		__res:=array['502','Verefique que exista el Nro.Serie'];
	end if;
end if;
return __res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION  almacen.isp_grabarseries(
	op		       integer,
	__op_movimiento	       integer,--1:Compras,2:Notas de Ingreso,3:Notas de credito,4:Inventario
	__id_usuario           CHAR(5)  ,
	__id_serie             bigint   ,
	__NRO_SERIE            VARCHAR(30)  ,
	__NRO_CHASIS           VARCHAR(30)  ,
	__ANIO_FARICACION      INTEGER  ,
	__ANIO_MODELO          INTEGER  ,
	__id_almacen           INTEGER ,
	__id_estado            INTEGER  ,
	__id_producto          VARCHAR(20)  ,
	__id_unidadventa       INTEGER,
	__observacion 	     	text,
	__id_sucursal	       integer, 
	__id_movimiento	       bigint,
	__item		       integer
)
returns text[] as $$
declare
	__nro__serieOld text;
	__res text[];
begin
if op=1 then
	if not exists(select *from almacen.TBL_SERIEPRODUCTO where NRO_SERIE=__NRO_SERIE and id_estado=1)  then
		select max(id_serie) into __id_serie from almacen.TBL_SERIEPRODUCTO ;
		if __id_serie is null then
			__id_serie:=1;
		else
			__id_serie:=__id_serie+1;
		end if;
		INSERT INTO almacen.tbl_serieproducto(
			nro_serie, 
			nro_chasis, 
			anio_faricacion, 
			anio_modelo, 
			id_almacen, 
			id_estado, 
			fecha_registro, 
			id_usuario_r, 
			id_serie, 
			id_producto, 
			id_unidadventa
		)
		VALUES (
			__nro_serie, 
			__nro_chasis, 
			__anio_faricacion, 
			__anio_modelo, 
			__id_almacen, 
			__id_estado, 
			now(),
			__id_usuario, 
			__id_serie, 
			__id_producto, 
			__id_unidadventa
		)returning array['0','Serie registrada'] into __res;
		if not found then
			__res:=array['504','Inconsistencia Inesperada al registrar el Nro.Serie'];
		end if;
		if __res[1]='0' then
			if __op_movimiento=1 then
				__res:=(select * from COMPRAS.ISP_SERIECOMPRA(
					1 ,
					__id_usuario,
					__id_estado ,
					__id_sucursal,
					__id_movimiento,
					__id_almacen,
					__id_serie,
					__observacion,
					__item
				));
			end if;
			if __op_movimiento=2 then-- por nota de ingreso
				__res:=(select *from ALMACEN.ISP_SERIENOTAINGRESO(
					1,
					0 ,
					__id_movimiento,
					__id_almacen ,
					__id_serie  ,
					__id_sucursal,	
					__id_usuario,
					__id_estado ,	
					__item  ,
					__observacion ,
					true
					));
			end if;
		end if;
	else
		__res:=array['504','El nro.Serie ya se encuentra registrado' || '-' || __nro_serie];
	end if;
end if;
if op=2 then
	if exists(select *from almacen.TBL_SERIEPRODUCTO where id_serie=__id_serie) then
		__nro__serieOld:=(select nro_serie from almacen.TBL_SERIEPRODUCTO where id_serie=__id_serie);
		if __nro__serieOld=__nro_serie then
			UPDATE almacen.tbl_serieproducto
			   SET 
				nro_serie=__nro_serie, 
				nro_chasis=__nro_chasis, 
				anio_faricacion=__anio_faricacion,
				anio_modelo=__anio_modelo, 
				id_almacen=__id_almacen, 
				id_estado=__id_estado, 
				fecha_actualiza=now(), 
				id_usuario_a=__id_usuario,  
				id_producto=__id_producto, 
				id_unidadventa=__id_unidadventa
			 WHERE id_serie=__id_serie;
			__res:=array['0','Registro Actualizado'];
			if __op_movimiento=1 then-- por compra
				__res:=(select * from COMPRAS.ISP_SERIECOMPRA(
					1 ,
					__id_usuario,
					__id_estado ,
					__id_sucursal,
					__id_movimiento,
					__id_almacen,
					__id_serie,
					__observacion,
					__item
				));
			end if;
			if __op_movimiento=2 then-- por nota de ingreso
				__res:=(select *from ALMACEN.ISP_SERIENOTAINGRESO(
					        1,
						0 ,
						__id_movimiento,
						__id_almacen ,
						__id_serie  ,
						__id_sucursal,	
						__id_usuario,
						__id_estado ,	
						__item  ,
						__observacion ,
						true
					));
			end if;
		else
			__res:=(select *from almacen.isp_grabarseries(
				1,
				__id_usuario  ,
				__id_serie,
				__NRO_SERIE  ,
				__NRO_CHASIS  ,
				__ANIO_FARICACION ,
				__ANIO_MODELO ,
				__id_almacen  ,
				__id_estado   ,
				__id_producto   ,
				__id_unidadventa,
				__observacion 	
			));
		end if;
	else
		__Res:=array['504','Verefique que los registros existan para realizar esta actualización'];
	end if;
end if;
return __Res;
end;$$
language 'plpgsql';


 
CREATE OR REPLACE FUNCTION ventas.spi_facturacion(
    op integer,
    _id_facturacion integer,
    _numdoc_facturacion character,
    _id_detatencion character,
    _id_tipoventa integer,
    _id_tipocambio integer,
    _id_igv integer,
    _id_direccion bigint,
    _id_pedido character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _serie_facturacion character,
    _fecha_venta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _imp_neto numeric,
    _imp_igv numeric,
    _imp_redondeo numeric,
    _imp_total numeric,
    _tasa_persepcion numeric,
    _valor_venta numeric,
    _id_moneda integer,
    _id_estado integer,
    _id_cliente character varying,
    _id_operacion integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_sucursalpreventa integer,
    _id_vendedor character varying,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _imp_percepcion numeric,
    _comprobante_manual boolean,
    _porconsumo boolean,
    _Imp_BasePercepcion numeric(14,2),
    _pendiente_despacho boolean,
    _id_facturacionref integer,
    _id_sucursalref integer,
    _glosa text,
    _orden_compra text,
    _imp_icbper numeric(20,4),
    _anticipo boolean,
    _con_anticipo boolean,
    _tipo_factura text
   )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
        dat record;
        res_mov boolean;
	rec_item record;
	_id_movimiento bigint;
	_id_sucursal_mov bigint;
begin
if op=1 then

	if not exists(select *from ventas.tbl_facturacion where 
				numdoc_facturacion=_numdoc_facturacion and 
				serie_facturacion=_serie_facturacion and  id_comprobante=_id_comprobante and id_sucursal=_id_sucursal ) then
		if exists(select *from planillas.tbl_persona where trim(id_persona)=_id_vendedor) then
			select max(id_facturacion) into correl from ventas.tbl_facturacion where id_sucursal=_id_sucursal;
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
				end if;
				if (_id_cliente='000'  and _imp_total>750 )  then
					res:=array['506','Es obligatorio ingresar datos completos del cliente(DNI,Nombres y apellidos,direccion) a partir de 750.00  soles'];
					return res;
				end if;
				insert into ventas.tbl_facturacion(
						id_facturacion,
						numdoc_facturacion,
						id_detatencion,
						id_tipoventa,
						id_tipocambio,
						id_igv,
						id_direccion,
						id_pedido   ,
						id_comprobante ,
						id_tranzaccion ,
						serie_facturacion,
						fecha_venta      ,
						imp_bruto        ,
						imp_dscto        ,
						imp_neto         ,
						imp_igv          ,
						imp_redondeo     ,
						imp_total        ,
						tasa_persepcion  ,
						valor_venta  ,
						id_moneda        ,
						id_estado        ,
						id_cliente       ,
						id_operacion     ,
						id_sucursal,
						id_cotizapreventa ,
						id_sucursalpreventa ,
						id_vendedor,
						DNI_CLIENTE ,
						NOMAPE_CLIENTE,
						DIRECCION_CLIENTE,
						IMP_PERCEPCION,
						comprobante_manual,
						porconsumo,
						Imp_BasePercepcion,
						pendiente_despacho,
						id_facturacionref,
						id_sucursalref,
						glosa,
						orden_compra,
						imp_icbper,
						anticipo,
						con_anticipo,
						tipo_factura
						
				)values(
						correl,
						_numdoc_facturacion,
						_id_detatencion,
						_id_tipoventa,
						_id_tipocambio,
						_id_igv,
						_id_direccion,
						_id_pedido   ,
						_id_comprobante ,
						_id_tranzaccion ,
						_serie_facturacion,
						to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS')      ,
						_imp_bruto        ,
						_imp_dscto        ,
						_imp_neto         ,
						_imp_igv          ,
						_imp_redondeo     ,
						_imp_total        ,
						_tasa_persepcion  ,
						_valor_venta ,
						_id_moneda        ,
						_id_estado        ,
						_id_cliente       ,
						_id_operacion     ,
						_id_sucursal,
						case when _id_cotizapreventa=0 then null else _id_cotizapreventa end  ,
						case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end,
						_id_vendedor,
						_DNI_CLIENTE ,
						_NOMAPE_CLIENTE,
						_DIRECCION_CLIENTE,
						_IMP_PERCEPCION,
						_comprobante_manual,
						_porconsumo,
						_Imp_BasePercepcion,
						_pendiente_despacho,
						case when _id_facturacionref=0 then null else _id_facturacionref end,
						case when _id_sucursalref=0 then null else _id_sucursalref end,
						_glosa,
						_orden_compra,
						_imp_icbper,
						_anticipo,
						_con_anticipo,
						_tipo_factura
				) returning array['0',tbl_facturacion.id_facturacion::text, 
						tbl_facturacion.id_sucursal::text
						]into res;
				--select *from ventas.tbl_puntos
				insert into ventas.tbl_puntos(
					id_puntos,
					id_persona,
					fecha,
					puntos,
					id_estado,
					importe,
					id_facturacion,
					id_sucursal
				) values(
					correl,
					_id_cliente,
					to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
					_imp_total/5,
					1,
					_imp_total,
					correl,
					_id_sucursal
				);
				if not found then
					res:=array['504','Ocurrio un error al registar el documento de venta\n verefique que los datos esten ingresados correctamente'];
				end if;
				update ventas.tbl_items set id_facturacion=cast(res[2] as integer), id_sucursalfac=cast(res[3] as integer) 
					where id_cotizapreventa=_id_cotizapreventa;
			else
				res:=array['501','Seleccione correctamente el cliente::'|| _id_cliente || ' DireccionId: '|| cast(_id_direccion as varchar(10))];
			end if;
		else
			res:=array['502','Seleccione correctamente el vendedor : '|| _id_vendedor];
			--exit;
		end if;
	else
		res:=array['504','El documento con serie ' || _serie_facturacion ||' Nro : ' || _numdoc_facturacion || ' ya se encuentran registrados'];
		--exit;
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		
			update ventas.tbl_facturacion set 
						numdoc_facturacion=_numdoc_facturacion,
						id_detatencion=_id_detatencion,
						id_tipoventa=_id_tipoventa,
						id_tipocambio=_id_tipocambio,
						id_igv=_id_igv,
						id_direccion=_id_direccion,
						id_pedido=_id_pedido,
						id_comprobante=_id_comprobante ,
						id_tranzaccion=_id_tranzaccion ,
						serie_facturacion=_serie_facturacion,
						fecha_venta=to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
						imp_bruto=_imp_bruto,
						imp_dscto=_imp_dscto,
						imp_neto=_imp_neto,
						imp_igv=_imp_igv,
						imp_redondeo=_imp_redondeo,
						imp_total=_imp_total,
						tasa_persepcion=_tasa_persepcion,
						valor_venta=_valor_venta,
						id_moneda=_id_moneda,
						id_estado=_id_estado,
						id_cliente=_id_cliente,
						id_operacion=_id_operacion,
						id_cotizapreventa=case when _id_cotizapreventa=0 then null else _id_cotizapreventa end ,
						id_sucursalpreventa=case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end ,
						id_vendedor=_id_vendedor,
						DNI_CLIENTE=_DNI_CLIENTE ,
						NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
						DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
						IMP_PERCEPCION=_IMP_PERCEPCION,
						comprobante_manual=_comprobante_manual,
						Imp_BasePercepcion=Imp_BasePercepcion,
						pendiente_despacho=_pendiente_despacho,
						id_facturacionref=case when _id_facturacionref=0 then null else _id_facturacionref end,
						id_sucursalref=case when _id_sucursalref=0 then null else _id_sucursalref end,
						glosa=_glosa,
						orden_compra=_orden_compra,
						imp_icbper=_imp_icbper,
						anticipo=_anticipo,
						con_anticipo=_con_anticipo,
						tipo_factura=_tipo_factura
						where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						res:=array['0',_id_facturacion::text,_id_sucursal::text];
			update  caja.tbl_movcaja set id_estado=7  where id_facturacion=_id_facturacion and id_sucursal_fac=_id_sucursal;
						 
			--update creditos.tbl_detpagocuota set id_estado=7 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;
			if _id_tipoventa<>1 then
				for dat in select *from  creditos.tbl_ventacredito where id_facturacion=_id_facturacion loop
					if exists(select *from creditos.tbl_detpagocuota dpc 
						inner join caja.tbl_movcaja mv on mv.id_movimcaja=dpc.id_movimcaja and mv.id_sucursal=dpc.id_sucursal
						where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito and mv.id_estado=1) then
						res_mov=true;
					else
						res_mov=false;						
					end if;
					if res_mov=false then	
/*
						delete from caja.tbl_movcaja mc 
						inner join creditos.tbl_detpagocuota dpc on mc.id_movimcaja=dpc.id_movimcaja and mc.id_sucursal=dpc.id_sucursal
						
						delete from caja.tbl_movcaja mc 
						inner join creditos.tbl_detpagocuota dpc on mc.id_movimcaja=dpc.id_movimcaja and mc.id_sucursal=dpc.id_sucursal
						
					        --select id_movimiento into _id_movimiento from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
					        --select id_sucursal into _id_sucursal_mov from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
						delete from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
					        delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
						delete from creditos.tbl_cuota cc where cc.id_credito=dat.id_credito and  cc.id_sucursal_credito=dat.id_sucursal_credito;
						delete from creditos.tbl_credito c where c.id_credito=dat.id_credito and  c.id_sucursal_credito=dat.id_sucursal_credito;
*/
--select *from caja.tbl_movcaja
						--update  caja.tbl_movcaja set id_estado=7 from creditos.tbl_detpagocuota dpc
						--where  tbl_movcaja.id_movimcaja=dpc.id_movimcaja and tbl_movcaja.id_sucursal=dpc.id_sucursal;
						update  caja.tbl_movcaja set id_estado=3  where id_facturacion=_id_facturacion and id_sucursal_fac=_id_sucursal;
						 
						update creditos.tbl_detpagocuota set id_estado=3 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;
					        update creditos.tbl_ventacredito set id_estado=3  where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						update creditos.tbl_cuota set id_estado=3 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;
						update creditos.tbl_credito set id_estado=3 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;

						
					end if;
				end loop;
				if res_mov=true then
					res:=Array['506','Existe movimientos de caja, en cuentas por cobrar \n primero anule los movimientos de caja y luego realice este proceso'];		
				end if;
				/*if res=false then
					delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
				end if;	*/			
			end if;
		
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
RETURN RES;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
   

CREATE OR REPLACE FUNCTION CREDITOS.ISP_ANULAR_CANJE_LETRAS_CREDITOS(
	_id_credito integer,
	_id_sucursal integer,
	_id_estado integer,
	_glosa text
)returns text[] as $$
declare
	res text[];
begin
if exists(select 1 from creditos.tbl_creditoscompra where id_credito=_id_credito and  id_sucursal_credito=_id_sucursal) then
	update creditos.tbl_creditoscompra set id_estado=7 where id_credito=_id_credito and  id_sucursal_credito=_id_sucursal;
	res:=array['0','Credito anulado'];
else
	res:=array['502','Verifique que el credito exista'];
end if;
return res;
end;$$
language 'plpgsql';

CREATE OR REPLACE FUNCTION ventas.spi_facturacion_bloque(
    op integer,
    _id_facturacion integer,
    _numdoc_facturacion character,
    _id_detatencion character,
    _id_tipoventa integer,
    _id_tipocambio integer,
    _id_igv integer,
    _id_direccion bigint,
    _id_pedido character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _serie_facturacion character,
    _fecha_venta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _imp_neto numeric,
    _imp_igv numeric,
    _imp_redondeo numeric,
    _imp_total numeric,
    _tasa_persepcion numeric,
    _valor_venta numeric,
    _id_moneda integer,
    _id_estado integer,
    _id_cliente character varying,
    _id_operacion integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_sucursalpreventa integer,
    _id_vendedor character varying,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _imp_percepcion numeric,
    _comprobante_manual boolean,
    _porconsumo boolean,
    _Imp_BasePercepcion numeric(14,2),
    _pendiente_despacho boolean,
    _id_usuario varchar(5)
    
   )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
        dat record;
        res_mov boolean;
	rec_item record;
	_id_movimiento bigint;
	_id_sucursal_mov bigint;
	_id_tipdocidentidad integer;
begin
if op=1 then
	select COALESCE(pref.id_tipdocidentidad,p.id_tipdocidentidad)  into _id_tipdocidentidad from planillas.tbl_persona  p	
	left JOIN planillas.tbl_persona pref on pref.id_persona=p.id_persona_ref
	where p.id_persona=_id_cliente;
	if (_id_tipdocidentidad in(2,4)) then
		if _id_tipdocidentidad=2 then
			_id_comprobante:=2;
			--select *from common.tbl_comprobante order by 1
		end if;
		if _id_tipdocidentidad=4 then
			_id_comprobante:=3;			 
			--select *from common.tbl_comprobante order by 1
		end if;
		select serie into _serie_facturacion from seguridad.v__documento__usuario where id_proceso=1 and id_comprobante=_id_comprobante and id_usuario=_id_usuario AND id_estado=1  and id_sucursal=_id_sucursal  ;
		 
		select max(COALESCE(numero,0))+1 into _numdoc_facturacion from common.v_configseries where id_tranzaccion='20' and id_comprobante=_id_comprobante and serie=_serie_facturacion AND id_estado=1 and  id_sucursal=_id_sucursal  ;


	else
		return array['504','Verifique que el documento de identidad del cliente este configurado correctamente'];
	end if;
	
	if not exists(select *from ventas.tbl_facturacion where 
				numdoc_facturacion=_numdoc_facturacion and 
				serie_facturacion=_serie_facturacion and  id_comprobante=_id_comprobante and id_sucursal=_id_sucursal ) then
		if exists(select *from planillas.tbl_persona where id_persona=_id_vendedor) then
			select max(id_facturacion) into correl from ventas.tbl_facturacion where id_sucursal=_id_sucursal;
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
				end if;
				
				insert into ventas.tbl_facturacion(
						id_facturacion,
						numdoc_facturacion,
						id_detatencion,
						id_tipoventa,
						id_tipocambio,
						id_igv,
						id_direccion,
						id_pedido   ,
						id_comprobante ,
						id_tranzaccion ,
						serie_facturacion,
						fecha_venta      ,
						imp_bruto        ,
						imp_dscto        ,
						imp_neto         ,
						imp_igv          ,
						imp_redondeo     ,
						imp_total        ,
						tasa_persepcion  ,
						valor_venta  ,
						id_moneda        ,
						id_estado        ,
						id_cliente       ,
						id_operacion     ,
						id_sucursal,
						id_cotizapreventa ,
						id_sucursalpreventa ,
						id_vendedor,
						DNI_CLIENTE ,
						NOMAPE_CLIENTE,
						DIRECCION_CLIENTE,
						IMP_PERCEPCION,
						comprobante_manual,
						porconsumo,
						Imp_BasePercepcion,
						pendiente_despacho
						 
						
				)values(
						correl,
						lpad(_numdoc_facturacion::text,7,'0'),
						_id_detatencion,
						_id_tipoventa,
						_id_tipocambio,
						_id_igv,
						_id_direccion,
						_id_pedido   ,
						_id_comprobante ,
						_id_tranzaccion ,
						_serie_facturacion,
						to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS')      ,
						_imp_bruto        ,
						_imp_dscto        ,
						_imp_neto         ,
						_imp_igv          ,
						_imp_redondeo     ,
						_imp_total        ,
						_tasa_persepcion  ,
						_valor_venta ,
						_id_moneda        ,
						_id_estado        ,
						_id_cliente       ,
						_id_operacion     ,
						_id_sucursal,
						case when _id_cotizapreventa=0 then null else _id_cotizapreventa end  ,
						case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end,
						_id_vendedor,
						_DNI_CLIENTE ,
						_NOMAPE_CLIENTE,
						_DIRECCION_CLIENTE,
						_IMP_PERCEPCION,
						_comprobante_manual,
						_porconsumo,
						_Imp_BasePercepcion,
						_pendiente_despacho
				) returning array['0',tbl_facturacion.id_facturacion::text, 
						tbl_facturacion.id_sucursal::text
						]into res;
					
				if not found then
					res:=array['504','Ocurrio un error al registar el documento de venta\n verefique que los datos esten ingresados correctamente'];
				end if;
				if _imp_total>700 then
					update ventas.tbl_facturacion set imp_retencion=0.06*_imp_total where id_facturacion=cast(res[2] as integer) and id_sucursal=cast(res[3] as integer); 
				end if;
				update ventas.tbl_items set id_facturacion=cast(res[2] as integer), id_sucursalfac=cast(res[3] as integer) 
					where id_cotizapreventa=_id_cotizapreventa;
			else
				res:=array['501','Seleccione correctamente el cliente::'|| _id_cliente || ' DireccionId: '|| cast(_id_direccion as varchar(10))];
			end if;
		else
			res:=array['502','Seleccione correctamente el vendedor'];
			--exit;
		end if;
	else
		res:=array['504','El documento con serie ' || _serie_facturacion ||' Nro : ' || _numdoc_facturacion || ' ya se encuentran registrados'];
		--exit;
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		
			update ventas.tbl_facturacion set 
						numdoc_facturacion=_numdoc_facturacion,
						id_detatencion=_id_detatencion,
						id_tipoventa=_id_tipoventa,
						id_tipocambio=_id_tipocambio,
						id_igv=_id_igv,
						id_direccion=_id_direccion,
						id_pedido=_id_pedido,
						id_comprobante=_id_comprobante ,
						id_tranzaccion=_id_tranzaccion ,
						serie_facturacion=_serie_facturacion,
						fecha_venta=to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
						imp_bruto=_imp_bruto,
						imp_dscto=_imp_dscto,
						imp_neto=_imp_neto,
						imp_igv=_imp_igv,
						imp_redondeo=_imp_redondeo,
						imp_total=_imp_total,
						tasa_persepcion=_tasa_persepcion,
						valor_venta=_valor_venta,
						id_moneda=_id_moneda,
						id_estado=_id_estado,
						id_cliente=_id_cliente,
						id_operacion=_id_operacion,
						id_cotizapreventa=case when _id_cotizapreventa=0 then null else _id_cotizapreventa end ,
						id_sucursalpreventa=case when _id_sucursalpreventa =0 then null else _id_sucursalpreventa  end ,
						id_vendedor=_id_vendedor,
						DNI_CLIENTE=_DNI_CLIENTE ,
						NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
						DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
						IMP_PERCEPCION=_IMP_PERCEPCION,
						comprobante_manual=_comprobante_manual,
						Imp_BasePercepcion=Imp_BasePercepcion,
						pendiente_despacho=_pendiente_despacho
						where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						res:=array['0',_id_facturacion::text,_id_sucursal::text];
			if _id_tipoventa=2 then
				for dat in select *from  creditos.tbl_ventacredito where id_facturacion=_id_facturacion loop
					if exists(select *from creditos.tbl_detpagocuota dpc 
						inner join caja.tbl_movcaja mv on mv.id_movimcaja=dpc.id_movimcaja and mv.id_sucursal=dpc.id_sucursal
						where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito and mv.id_estado=1) then
						res_mov=true;
					else
						res_mov=false;						
					end if;
					if res_mov=false then	
/*
						delete from caja.tbl_movcaja mc 
						inner join creditos.tbl_detpagocuota dpc on mc.id_movimcaja=dpc.id_movimcaja and mc.id_sucursal=dpc.id_sucursal
						
						delete from caja.tbl_movcaja mc 
						inner join creditos.tbl_detpagocuota dpc on mc.id_movimcaja=dpc.id_movimcaja and mc.id_sucursal=dpc.id_sucursal
						
					        --select id_movimiento into _id_movimiento from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
					        --select id_sucursal into _id_sucursal_mov from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
						delete from creditos.tbl_detpagocuota dpc where dpc.id_credito=dat.id_credito and  dpc.id_sucursal_credito=dat.id_sucursal_credito;
					        delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
						delete from creditos.tbl_cuota cc where cc.id_credito=dat.id_credito and  cc.id_sucursal_credito=dat.id_sucursal_credito;
						delete from creditos.tbl_credito c where c.id_credito=dat.id_credito and  c.id_sucursal_credito=dat.id_sucursal_credito;
*/
--select *from caja.tbl_movcaja
						--update  caja.tbl_movcaja set id_estado=7 from creditos.tbl_detpagocuota dpc
						--where  tbl_movcaja.id_movimcaja=dpc.id_movimcaja and tbl_movcaja.id_sucursal=dpc.id_sucursal;
						update  caja.tbl_movcaja set id_estado=7  where id_facturacion=_id_facturacion and id_sucursal_fac=_id_sucursal;
						 
						update creditos.tbl_detpagocuota set id_estado=7 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;
					        update creditos.tbl_ventacredito set id_estado=7  where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						update creditos.tbl_cuota set id_estado=7 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;
						update creditos.tbl_credito set id_estado=7 where id_credito=dat.id_credito and  id_sucursal_credito=dat.id_sucursal_credito;

						
					end if;
				end loop;
				if res_mov=true then
					res:=Array['506','Existe movimientos de caja, en cuentas por cobrar \n primero anule los movimientos de caja y luego realice este proceso'];		
				end if;
				/*if res=false then
					delete from creditos.tbl_ventacredito  where id_facturacion=_id_facturacion;
				end if;	*/			
			end if;
		
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
RETURN RES;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  


select *from ventas.tbl_facturacion

CREATE OR REPLACE FUNCTION ventas.isp_notacredito(
    op integer,
    _id_facturacion integer,
    _numdoc_facturacion character,
    _id_detatencion character,
    _id_tipoventa integer,
    _id_tipocambio integer,
    _id_igv integer,
    _id_direccion bigint,
    _id_pedido character,
    _id_comprobante integer,
    _id_tranzaccion character,
    _serie_facturacion character,
    _fecha_venta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _imp_neto numeric,
    _imp_igv numeric,
    _imp_redondeo numeric,
    _imp_total numeric,
    _tasa_persepcion numeric,
    _valor_venta numeric,
    _id_moneda integer,
    _id_estado integer,
    _id_cliente character varying,
    _id_operacion integer,
    _id_sucursal integer,
    _id_facturacionref integer,
    _id_sucursalref integer,
    _id_vendedor character varying,
    _nota_credito boolean,
    _id_motivonotacredito character varying,
    _glosa text,
    _dni_cliente varchar(11),
    _nomape_cliente text,
    _direccion_cliente text
    )
  RETURNS text[] AS
$BODY$
declare
	res text[];
	correl integer;
begin
if op=1 then
	if not exists(select *from ventas.tbl_facturacion where 
				numdoc_facturacion=_numdoc_facturacion and 
				serie_facturacion=_serie_facturacion and  id_comprobante=_id_comprobante ) then
		if exists(select *from planillas.tbl_persona where id_persona=_id_vendedor) then
			select max(id_facturacion) into correl from ventas.tbl_facturacion where id_sucursal=_id_sucursal;
			if exists(select *from ventas.tbl_direccion where id_persona=_id_cliente and id_direccion=_id_direccion) then
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
				end if;
				insert into ventas.tbl_facturacion(
						id_facturacion,
						numdoc_facturacion,
						id_detatencion,
						id_tipoventa,
						id_tipocambio,
						id_igv,
						id_direccion,
						id_pedido   ,
						id_comprobante ,
						id_tranzaccion ,
						serie_facturacion,
						fecha_venta      ,
						imp_bruto        ,
						imp_dscto        ,
						imp_neto         ,
						imp_igv          ,
						imp_redondeo     ,
						imp_total        ,
						tasa_persepcion  ,
						valor_venta  ,
						id_moneda        ,
						id_estado        ,
						id_cliente       ,
						id_operacion     ,
						id_sucursal,
						id_facturacionref ,
						id_sucursalref ,
						id_vendedor,
						nota_credito,
						ID_MOTIVONOTACREDITO,
						glosa,
					       dni_cliente,
					       nomape_cliente,
					       direccion_cliente
						
				)values(
						correl,
						_numdoc_facturacion,
						_id_detatencion,
						_id_tipoventa,
						_id_tipocambio,
						_id_igv,
						_id_direccion,
						_id_pedido   ,
						_id_comprobante ,
						_id_tranzaccion ,
						_serie_facturacion,
						to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS')      ,
						_imp_bruto        ,
						_imp_dscto        ,
						_imp_neto         ,
						_imp_igv          ,
						_imp_redondeo     ,
						_imp_total        ,
						_tasa_persepcion  ,
						_valor_venta ,
						_id_moneda        ,
						_id_estado        ,
						_id_cliente       ,
						_id_operacion     ,
						_id_sucursal,
						case when _id_facturacionref=0 then null else _id_facturacionref end  ,
						case when _id_sucursalref =0 then null else _id_sucursalref  end,
						_id_vendedor,
						_nota_credito,
						_ID_MOTIVONOTACREDITO,
						_glosa,
						_dni_cliente,
					        _nomape_cliente,
					        _direccion_cliente
				) returning array['0',tbl_facturacion.id_facturacion::text, 
						tbl_facturacion.id_sucursal::text
						]into res;
				if not found then
					res:=array['504','Ocurrio un error al registar el documento de venta\n verefique que los datos esten ingresados correctamente'];
				end if;
			else
				res:=array['501','Seleccione correctamente el cliente'];
			end if;
		else
			res:=array['502','Seleccione correctamente el vendedor'];
			--exit;
		end if;
	else
		res:=array['504','El documento con serie ' || _serie_facturacion ||' Nro : ' || _numdoc_facturacion || ' ya se encuentran registrados'];
		--exit;
	end if;
end if;
if op=2 then
	if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal) then
		
			update ventas.tbl_facturacion set 
						numdoc_facturacion=_numdoc_facturacion,
						id_detatencion=_id_detatencion,
						id_tipoventa=_id_tipoventa,
						id_tipocambio=_id_tipocambio,
						id_igv=_id_igv,
						id_direccion=_id_direccion,
						id_pedido=_id_pedido,
						id_comprobante=_id_comprobante ,
						id_tranzaccion=_id_tranzaccion ,
						serie_facturacion=_serie_facturacion,
						fecha_venta=to_timestamp(_fecha_venta,'YYYY-MM-DD HH24:MI:SS.MS'),
						imp_bruto=_imp_bruto,
						imp_dscto=_imp_dscto,
						imp_neto=_imp_neto,
						imp_igv=_imp_igv,
						imp_redondeo=_imp_redondeo,
						imp_total=_imp_total,
						tasa_persepcion=_tasa_persepcion,
						valor_venta=_valor_venta,
						id_moneda=_id_moneda,
						id_estado=_id_estado,
						id_cliente=_id_cliente,
						id_operacion=_id_operacion,
						id_facturacionref=case when _id_facturacionref=0 then null else _id_facturacionref end ,
						id_sucursalref=case when _id_sucursalref =0 then null else _id_sucursalref  end ,
						id_vendedor=_id_vendedor,
						nota_credito=_nota_credito,
						ID_MOTIVONOTACREDITO=_ID_MOTIVONOTACREDITO,
						glosa=_glosa,
						dni_cliente=_dni_cliente,
					        nomape_cliente=_nomape_cliente,
					        direccion_cliente=_direccion_cliente
						 where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
						res:=array['0',_id_facturacion::text,_id_sucursal::text];
		
	else
		res:=array['504','Verefique que exista el registro editado'];
	end if;
end if;
RETURN RES;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
 

select *from ventas.tbl_puntos

CREATE OR REPLACE FUNCTION VENTAS.CORRELATIVO_PERCEPCION()
RETURNS TEXT AS $$
DECLARE
  dat record;
  correl  integer;
  res	text;
BEGIN
	correl:=10;
for dat in select P.id_percepcion, P.numero from VENTAS.TBL_PERCEPCION P 
	INNER JOIN VENTAS.TBL_detPERCEPCION  DP ON P.id_percepcion=DP.id_percepcion
	JOIN ventas.tbl_facturacion fac ON fac.id_facturacion = dp.id_facturacion AND fac.id_sucursal = dp.id_sucursalfac
where date_part('year',fecha::Date)=2016 and  date_part('MONTH',fecha::Date)>=12  AND FAC.ID_COMPROBANTE=2  and P.id_percepcion  not in (7269,
	7270,
	7271,
	7272,
	7273,
	7274,
	7275,
	7276,
	7277
) order by id_percepcion   loop
	UPDATE VENTAS.TBL_PERCEPCION SET numero=lpad(correl::text,7,'0') where id_percepcion=dat.id_percepcion;
	correl:=correl+1;
	res:='data';
end loop;
return res;
END;$$
LANGUAGE 'plpgsql';


 
SELECT *FROM VENTAS.CORRELATIVO_PERCEPCION();

CREATE OR REPLACE FUNCTION VENTAS.FN_ACTUALIZA_BASEPERCEPCION()
RETURNS TEXT AS $$
DECLARE
	res text;
	ImpBase Numeric(20,4);
	dat record;
BEGIN
 
CREATE TEMPORARY TABLE TEMPFAC(
	id_Facturacion integer,
	id_sucursal integer,
	imp_percepcion NUMERIC(20,4),
	basepercepcion numeric(20,4)
)ON COMMIT DROP;

INSERT INTO TEMPFAC(id_Facturacion,id_sucursal,imp_percepcion,basepercepcion)
select f.id_facturacion,f.id_sucursal,f.imp_percepcion,CANTIDAD*(PRECIO/1.02) AS BasePercepcion from ventas.tbl_facturacion f
inner join  ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion AND df.id_estado=1
inner join  almacen.tbl_producto p on p.id_producto=df.id_producto where df.imp_percepcion>0 and f.id_estado=1 AND F.ID_CLIENTE NOT IN ('764','769','777') ;--  and date_part('year',f.fecha_venta)=2016;
 

for dat in 
select f.id_facturacion,f.id_sucursal,f.imp_percepcion,sum(basepercepcion) AS BasePercepcion from TEMPFAC f
group by f.id_facturacion,f.id_sucursal,f.imp_percepcion
loop
	update VENTAS.TBL_FACTURACION SET IMP_BASEPERCEPCION=DAT.BasePercepcion WHERE id_facturacion=DAT.id_facturacion;
	RES:='ATUALIZANDO';
end loop;
RETURN RES;
END;$$
LANGUAGE 'plpgsql';


SELECT *FROM VENTAS.FN_ACTUALIZA_BASEPERCEPCION();

CREATE OR REPLACE FUNCTION VENTAS.UDP_ACTUALIZA_IMPPERCEPCION()
RETURNS TEXT AS $$
DECLARE
	dat record;
	res text;
BEGIN
	for dat in select p.id_percepcion,p.id_sucursal,f.IMP_BASEPERCEPCION,dp.imp_percepcion from ventas.tbl_percepcion p
		inner join ventas.tbl_detpercepcion dp on p.id_percepcion=dp.id_percepcion
		inner join ventas.tbl_facturacion f on f.id_facturacion=dp.id_facturacion and f.id_sucursal=dp.id_sucursalfac
		where p.fecha::date>'31/12/2016'  loop
		update 
			ventas.tbl_detpercepcion set imp_venta=dat.IMP_BASEPERCEPCION,imp_totalcobrado=dat.IMP_BASEPERCEPCION+dat.imp_percepcion 
		where 
			id_percepcion=dat.id_percepcion and id_sucursal=dat.id_sucursal;
		update ventas.tbl_percepcion set imp_total=dat.IMP_BASEPERCEPCION+dat.imp_percepcion  where id_percepcion=dat.id_percepcion and id_sucursal=dat.id_sucursal;
		res:='Actualiza';
	end loop;
return res;		
END;$$
LANGUAGE 'plpgsql';


SELECT *FROM VENTAS.FN_ACTUALIZA_BASEPERCEPCION();
SELECT *FROM VENTAS.UDP_ACTUALIZA_IMPPERCEPCION();

update ventas.tbl_percepcion set fecha='01/01/2050' where id_percepcion in(7607,7608,7609)  and id_sucursal= 1

update ventas.tbl_percepcion set numero='0000326' where id_percepcion=7682

select *from ventas.tbl_percepcion where id_percepcion=7606  and id_sucursal= 1

select p.id_percepcion,p.id_sucursal,f.IMP_BASEPERCEPCION from ventas.tbl_percepcion p
inner join ventas.tbl_detpercepcion dp on p.id_percepcion=dp.id_percepcion
inner join ventas.tbl_facturacion f on f.id_facturacion=dp.id_facturacion and f.id_sucursal=dp.id_sucursalfac
where p.fecha::date='31/12/2016'

select *from ventas.tbl_percepcion p

select DF.* from ventas.tbl_facturacion f
inner join  ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion
inner join  almacen.tbl_producto p on p.id_producto=df.id_producto where df.imp_percepcion>0

select id_Facturacion,IMP_BASEPERCEPCION,imp_percepcion,(IMP_BASEPERCEPCION*0.02) as Percep from ventas.tbl_facturacion where imp_percepcion>0 and id_estado=1
 
CREATE OR REPLACE FUNCTION ventas.fn_actualiza_percepcion_sunat(
    _id_percepcion bigint, 
    _id_sucursal integer,
    _status_sunat boolean,
    _code_sunat character varying,
    _message_sunat character varying,
    _observation_sunat character varying,
    _digestvalue character varying,
    _signaturevalue character varying)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select 1 from ventas.tbl_percepcion where id_percepcion=_id_percepcion and id_sucursal=_id_sucursal)then
	UPDATE VENTAS.tbl_percepcion SET
		STATUS_SUNAT=_STATUS_SUNAT,
		CODE_SUNAT=_CODE_SUNAT,
		MESSAGE_SUNAT=_MESSAGE_SUNAT,
		OBSERVATION_SUNAT=_OBSERVATION_SUNAT,
		DigestValue=_DigestValue,
		SignatureValue=_SignatureValue
	 WHERE id_percepcion=_id_percepcion and id_sucursal=_id_sucursal;
	 res:=array['0','Registro Actualizado'];
else
	res:=array['0','Registro No existe'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.spi_precio(
    op integer,
    _id_listaprecio integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _codbarra character varying,
    _costo double precision,
    _flete double precision,
    _otroscostos double precision,
    _coste double precision,
    _precio1 double precision,
    _precio2 double precision,
    _precio3 double precision,
    _id_estado integer,
    _predeterminado boolean,
    _val_unidad double precision,
    _val_minimo_venta double precision,
    _id_tipoventa integer,
    _undpred_compra boolean,
    _precio4 double precision,
    _precio5 double precision
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
BEGIN
if not exists(select 1 from ALMACEN.TBL_PRECIO where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
	if exists(select 1 from ALMACEN.TBL_DETPRODUCTO where id_producto=_id_producto and id_unidadventa=_id_unidadventa)then
		insert into ALMACEN.TBL_PRECIO(
			id_listaprecio,
			id_producto,
			id_unidadventa,
			codbarra,
			costo ,
			flete,
			otroscostos,
			coste ,
			precio1,
			precio2,
			precio3,	
			id_estado,
			predeterminado,
			val_unidad,
			val_minimo_venta,
			ID_TIPOVENTA,
			UNDPRED_COMPRA,
			precio4,
			precio5
		)
		values(
			_id_listaprecio,
			_id_producto,
			_id_unidadventa,
			_codbarra,
			_costo ,
			_flete,
			_otroscostos,
			_coste ,
			_precio1,
			_precio2,
			_precio3,	
			_id_estado,
			_predeterminado,
			_val_unidad,
			_val_minimo_venta,
			_ID_TIPOVENTA,
			_UNDPRED_COMPRA,
			_precio2  ,
			_precio3 
		)returning array[
				'0',
				TBL_PRECIO.id_producto::text,
				TBL_PRECIO.id_unidadventa::text,
				TBL_PRECIO.id_listaprecio::text
				]into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar los precios del producto'];
		end if;
	else
		res:=array['503','Verefique que los datos del producto este ingresados correctamente'];
	end if;
else
	if exists(select * from ALMACEN.TBL_PRECIO where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio)then
		update ALMACEN.TBL_PRECIO  set 
				codbarra=_codbarra,
				costo=_costo ,
				flete=_flete,
				otroscostos=_otroscostos,
				coste=_coste ,
				precio1=_precio1,
				precio2=_precio2,
				precio3=_precio3,	
				id_estado=_id_estado,
				predeterminado=_predeterminado,
				val_unidad=_val_unidad,
				val_minimo_venta=_val_minimo_venta ,
				ID_TIPOVENTA=_ID_TIPOVENTA,
				UNDPRED_COMPRA=_UNDPRED_COMPRA,
				precio4=_precio4,
				precio5=_precio5
				where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio;
		res:=array['0',_id_producto::text,_id_unidadventa::text,_id_listaprecio::text];	
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION compras.list_pedidos_proveedores(
    IN op integer,
    IN _numero_desde bigint,
    IN _numero_hasta bigint,
    IN _fecha_desde text,
    IN _fecha_hasta text,
    IN _proveedor_desde bigint,
    IN _proveedor_hasta bigint,
    IN _id_estado integer,
    IN _id_sucursal integer,
    IN _op_codigo integer)
  RETURNS TABLE(serie character, numero bigint, fecha timestamp without time zone, imp_recibido numeric, sucursal character varying, valor_venta numeric, imp_igv numeric, imp_total numeric, estado character varying, tipo_compra character varying, id_producto text, codigo text, producto text, cantidad numeric, pendiente numeric, recibido numeric, p_unitario numeric, dscto numeric, total_lin numeric, id_familia text, id_proveedor bigint, id_estado integer, proveedor character varying, id_cotizaorden bigint, item integer, unidad text, op_codigo integer, familia text) AS
$BODY$
declare
begin
if op=1 then
return query select  
	oc.serie,
	(oc.serie || oc.numero)::bigint numero,
	oc.fecha_registro as fecha,
	COALESCE(z.imp_neto,0)::numeric(20,4) as imp_recibido,
	 s.nombre as sucursal ,
	 oc.valor_venta,
	 oc.imp_igv,
	 (oc.imp_total-COALESCE(z.imp_neto,0))::numeric(20,4) as imp_total,
	 e.des_estado as estado,
	 fp.descripcion_larga as tipo_compra,
	 ''::text id_producto,
	 ''::text codigo,
	 ''::text producto,
	 0::numeric(20,4) cantidad,
	 0::numeric(20,4) pendiente_lin,
	 0::numeric(20,4) recibido,
	 0::numeric(20,4) p_unitario,
	 0::numeric(20,4) dscto,
	 0::numeric(20,4) total_lin,
	 ''::text id_familia,
	oc.id_proveedor::bigint id_proveedor,
	oc.id_estado,
	prov.nombre_razon as proveedor,
	oc.id_cotizaorden,
	0::integer,
	''::text unidad,
	_op_codigo,
	''::text familia
from compras.tbl_ordencotizacompra oc
inner join planillas.tbl_persona prov on prov.id_persona=oc.id_proveedor
inner join common.tbl_sucursal s on s.id_sucursal=oc.id_sucursal
inner join common.tbl_estado e on e.id_estado=oc.id_estado
inner join common.tbl_moneda  m on m.id_moneda=oc.id_moneda
inner join common.tbl_tipoventa fp on fp.id_tipoventa=oc.id_tipoventa
left join (
	select cm.id_cotizaorden,cm.imp_neto from almacen.tbl_cabmovalm cm
	where cm.id_estado=1
)z on z.id_cotizaorden=oc.id_cotizaorden 

where (oc.id_proveedor::integer between _proveedor_desde and _proveedor_hasta) and 
	(oc.fecha_registro::date between _fecha_desde::date and _fecha_hasta::date)  and ((oc.serie || oc.numero)::bigint between _numero_desde and _numero_hasta ) and
	isnumeric(id_persona)
order by oc.fecha_registro::date,(oc.serie || oc.numero)::bigint;
end if;
if op=2 then
	return query select  
	oc.serie,
	(oc.serie || oc.numero)::bigint numero,
	oc.fecha_registro as fecha,
	0::numeric(20,4) as imp_pendiente,
	 s.nombre as sucursal ,
	 oc.valor_venta,
	 oc.imp_igv,
	 oc.imp_total,
	 e.des_estado as estado,
	 fp.descripcion_larga as tipo_compra,
	case when _op_codigo=1 then doc.id_producto::text else COALESCE(pro.codigo::text,'0') end as id_producto,
	 pro.codigo::text codigo,
	 pro.descripcion_larga::text producto,
	 doc.cantidad::numeric(20,4) cantidad,
	 COALESCE((doc.cantidad-COALESCE(z.cantidad,0)),0)::numeric(20,4) pendiente_lin,
	 COALESCE(z.cantidad,0)::numeric(20,4) recibido,
	 doc.costo_unitario::numeric(20,4) p_unitario,
	 doc.imp_dscto::numeric(20,4) dscto,
	 doc.total::numeric(20,4) total_lin,
	 pro.id_familia::text id_familia,
	oc.id_proveedor::bigint id_proveedor,
	oc.id_estado,
	prov.nombre_razon as proveedor,
	oc.id_cotizaorden,
	doc.item,
	u.desc_corta::text as unidad,
	_op_codigo,
	f.descripcion_larga::text as familia
from compras.tbl_ordencotizacompra oc
inner join compras.tbl_detordencotizacomp doc on oc.id_cotizaorden=doc.id_cotizaorden
inner join almacen.tbl_precio pre on pre.id_producto=doc.id_producto and pre.id_unidadventa=doc.id_unidad and pre.id_listaprecio=doc.id_listaprecio
inner join almacen.tbl_detproducto dp on dp.id_producto=pre.id_producto and dp.id_unidadventa=pre.id_unidadventa
inner join almacen.tbl_producto pro on pro.id_producto=dp.id_producto 
inner join planillas.tbl_persona prov on prov.id_persona=oc.id_proveedor
inner join common.tbl_sucursal s on s.id_sucursal=oc.id_sucursal
inner join common.tbl_estado e on e.id_estado=oc.id_estado
inner join common.tbl_moneda  m on m.id_moneda=oc.id_moneda
inner join common.tbl_tipoventa fp on fp.id_tipoventa=oc.id_tipoventa
inner join almacen.tbl_familia f on f.id_familia=pro.id_familia
inner join almacen.tbl_unidad u on u.id_unidadventa=doc.id_unidad
left join (
	select cm.id_cotizaorden,  dm.id_producto, dm.id_unidadkardex, dm.id_almacen,dm.cantidad,dm.precio from almacen.tbl_cabmovalm cm
	INNER JOIN  almacen.tbl_detmovalm DM ON CM.id_movimiento=DM.id_movimiento
)z on z.id_cotizaorden=doc.id_cotizaorden and z.id_producto=doc.id_producto  and z.id_unidadkardex=doc.id_unidad
;
--where (oc.id_proveedor::integer between _proveedor_desde and _proveedor_hasta) and 
--	(oc.fecha_registro::date between _fecha_desde::date and _fecha_hasta::date)  and ((oc.serie || oc.numero)::integer between _numero_desde and _numero_hasta ) and
--	isnumeric(id_persona);
end if;
end;$BODY$
  LANGUAGE plpgsql ; 


CREATE OR REPLACE FUNCTION planillas.spiu_colaborador(
    op integer,
    _id_persona character varying,
    _sexo character,
    _email character varying,
    _paginaweb text,
    _id_estadocivil integer,
    _id_estado integer,
    _fecha_nac text,
    _id_profesion integer,
    _id_cargo integer,
    _id_lugartrabajo integer,
    _id_centrocostos integer,
    _id_gradoestudios integer,
    _empleado boolean,
    _carnet_essalud character varying,
    _carnet_afp character varying,
    _cod_barras character varying,
    _fecha_ing text,
    _fecha_reing text,
    _nro_hijos integer,
    _fecha_cese text,
    _nro_cuenta character varying,
    _clave_asistencia character varying,
    _id_sistemapp integer,
    _carga_familiar text,
    _situacion_laboral boolean,
    _apell_paterno character varying,
    _apell_materno character varying,
    _nombres character varying,
    _dni character varying,
    _lugar_nacim character varying,
    _comicion_vcontado numeric,
    _comicion_vcredito numeric,
    _comicion_cobranza numeric,
    _codigo_persona  varchar(30)
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	RES TEXT[];
	correl integer;
BEGIN
	IF OP=1 THEN
		if not exists(select 1 from PLANILLAS.TBL_PERSONA where dni = _dni and empleado = true) then
				select  max(COALESCE(ID_PERSONA,'0')::numeric) into correl from PLANILLAS.TBL_PERSONA 
				where isnumeric(id_persona);
				if correl is null then
					correl:=1;
				else
					correl:=correl+1;
					_id_persona:=correl::text;
				end if;
			insert into PLANILLAS.TBL_PERSONA(
				id_persona ,
				sexo ,
				email ,
				paginaweb ,
				id_estadocivil ,
				id_estado ,
				fecha_nac ,
				id_profesion ,
				id_cargo ,
				id_lugartrabajo ,
				id_centrocostos ,
				id_gradoestudios ,
				empleado ,
				carnet_essalud ,
				carnet_afp ,
				cod_barras ,
				fecha_ing ,
				fecha_reing ,
				nro_hijos ,
				fecha_cese ,
				nro_cuenta ,
				clave_asistencia ,
				id_sistemapp ,
				carga_familiar ,
				situacion_laboral ,
				apell_paterno ,
				apell_materno ,
				nombres ,
				dni ,
				lugar_nacim ,
				COMICION_VCONTADO,
				COMICION_VCREDITO,
				COMICION_COBRANZA,
				doc_persona,
				codigo_persona,
				empleado
				)
				values(
					_id_persona ,
					_sexo ,
					_email ,
					_paginaweb ,
					_id_estadocivil ,
					_id_estado ,
					_fecha_nac::date,
					_id_profesion ,
					_id_cargo ,
					_id_lugartrabajo ,
					_id_centrocostos ,
					_id_gradoestudios ,
					_empleado ,
					_carnet_essalud ,
					_carnet_afp ,
					_cod_barras ,
					_fecha_ing::date ,
					_fecha_reing::date ,
					_nro_hijos ,
					_fecha_cese::date ,
					_nro_cuenta ,
					_clave_asistencia ,
					_id_sistemapp ,
					_carga_familiar ,
					_situacion_laboral ,
					_apell_paterno ,
					_apell_materno ,
					_nombres ,
					_dni ,
					_lugar_nacim,
					_COMICION_VCONTADO,
					_COMICION_VCREDITO,
					_COMICION_COBRANZA,
					_dni,
					_codigo_persona,
					true
				)returning array['0',TBL_PERSONA.id_persona::text]into res;
		else
				res:=array['504','El Empleado con Documento de Identidad << ' || dni || ' >> ya esta registrado ..!! '];
			
		end if;
		
	END IF;
	IF OP=2 THEN
		if exists(select * from PLANILLAS.TBL_PERSONA where id_persona=_id_persona) then
			update PLANILLAS.TBL_PERSONA set 
				sexo =_sexo ,
				email =_email ,
				paginaweb =_paginaweb ,
				id_estadocivil =_id_estadocivil ,
				id_estado =_id_estado ,
				fecha_nac =_fecha_nac ::date,
				id_profesion =_id_profesion ,
				id_cargo =_id_cargo ,
				id_lugartrabajo =_id_lugartrabajo ,
				id_centrocostos =_id_centrocostos ,
				id_gradoestudios =_id_gradoestudios ,
				empleado =_empleado ,
				carnet_essalud =_carnet_essalud ,
				carnet_afp =_carnet_afp ,
				cod_barras =_cod_barras ,
				fecha_ing =_fecha_ing ::date,
				fecha_reing =_fecha_reing ::date ,
				nro_hijos =_nro_hijos ,
				fecha_cese =_fecha_cese ::date,
				nro_cuenta =_nro_cuenta ,
				clave_asistencia =_clave_asistencia ,
				id_sistemapp =_id_sistemapp ,
				carga_familiar =_carga_familiar ,
				situacion_laboral =_situacion_laboral ,
				apell_paterno =_apell_paterno ,
				apell_materno =_apell_materno ,
				nombres =_nombres ,
				dni =_dni ,
				lugar_nacim =_lugar_nacim,
				COMICION_VCONTADO=_COMICION_VCONTADO,
				COMICION_VCREDITO=_COMICION_VCREDITO,
				COMICION_COBRANZA=_COMICION_COBRANZA,
				doc_persona=_dni,
				nombre_razon=_apell_paterno || ' ' ||_apell_materno ||' ' || _nombres,
				razon_comercial='-',
				cliente_proveedor=true,
				codigo_persona=_codigo_persona,
				empleado=true
			where id_persona=_id_persona;
			res:=array['0',_id_persona::text];	
		end if;
	end if;
	return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from planillas.tbl_persona

CREATE OR REPLACE FUNCTION almacen.isp_detnotaingresoalm(
    op integer,
    _id_movimiento bigint,
    _cantidad numeric,
    _precio numeric,
    _total numeric,
    _imp_dscto numeric,
    _imp_igv numeric,
    _porcent_igv numeric,
    _porcent_dscto numeric,
    _id_estado integer,
    _item integer,
    _observaciones text,
    _lp integer,
    _id_lote character varying,
    _peso numeric,
    _descripcion_linea text,
    _modotexto boolean,
    _id_producto character varying,
    _id_unidadkardex integer,
    _id_unidadingreso integer,
    _id_inventario integer,
    _id_almacen integer,
    _imp_valorventa numeric,
    _imp_bruto numeric,
    _id_usuario character)
  RETURNS text[] AS
$BODY$
declare
	res text[];
	id_almacenOld integer;
begin
if op=1 then
	if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=_id_movimiento)then
		if exists(select *from almacen.tbl_existencia where id_producto=_id_producto and id_unidadventa=_id_unidadkardex and 
			id_inventario=_id_inventario and id_almacen=_id_almacen)then
		
			INSERT INTO almacen.tbl_detmovalm(
				id_movimiento, 
				cantidad, 
				precio, 
				total, 
				imp_dscto, 
				imp_igv, 
				porcent_igv, 
				porcent_dscto, 
				id_estado, 
				item, 
				observaciones, 
				lp, 
				id_lote, 
				peso, 
				descripcion_linea, 
				modotexto, 
				id_producto, 
				id_unidadkardex, 
				id_unidadingreso, 
				id_inventario, 
				id_almacen, 
				fec_actualiza, 
				fecha, 
				imp_valorventa, 
				imp_bruto, 
				id_usuario
			)
			VALUES (
				_id_movimiento, 
				_cantidad, 
				_precio, 
				_total, 
				_imp_dscto, 
				_imp_igv, 
				_porcent_igv, 
				_porcent_dscto, 
				_id_estado, 
				_item, 
				_observaciones, 
				_lp, 
				_id_lote, 
				_peso, 
				_descripcion_linea, 
				_modotexto, 
				_id_producto, 
				_id_unidadkardex, 
				_id_unidadingreso, 
				_id_inventario, 
				_id_almacen, 
				NOW(), 
				NOW(), 
				_imp_valorventa, 
				_imp_bruto, 
				_id_usuario
			) returning array['0',id_movimiento::text] into res;
			if not found then
				res:=array['504','Inconsistencia al registrar el detalle '];
			end if;
		else
			res:=array['503','Verefique que exista el producto con el codigo '|| _id_producto];
		end if;
	else
		res:=array['502','Verefique exista la cabecera del documento'];
	end if;
end if;
if op=2 then
	if exists(select *from  almacen.tbl_detmovalm where id_movimiento=_id_movimiento and  
		item=_item and id_producto=_id_producto and  
		id_unidadkardex=_id_unidadkardex and id_inventario=_id_inventario and id_almacen=_id_almacen)then
			
		UPDATE almacen.tbl_detmovalm
		   SET  cantidad=_cantidad, 
			precio=_precio, 
			total=_total, 
			imp_dscto=_imp_dscto, 
			imp_igv=_imp_igv, 
			porcent_igv=_porcent_igv, 
			porcent_dscto=_porcent_dscto, 
			id_estado=_id_estado, 
			
			observaciones=_observaciones, 
			lp=_lp, 
			id_lote=_id_lote, 
			peso=_peso, 
			descripcion_linea=_descripcion_linea, 
			modotexto=_modotexto, 			
			fec_actualiza=now(), 
			imp_valorventa=_imp_valorventa, 
			imp_bruto=_imp_bruto, 
			id_usuario=_id_usuario
		 WHERE id_movimiento=_id_movimiento and id_producto=_id_producto and 
			id_unidadkardex=_id_unidadkardex and id_inventario=_id_inventario and 
			id_almacen=_id_almacen and item=_item,  returning array['0','0'] into res;
	else
		select id_almacen into id_almacenold from  almacen.tbl_detmovalm where id_movimiento=_id_movimiento and  
		item=_item and id_producto=_id_producto and  
		id_unidadkardex=_id_unidadkardex and id_inventario=_id_inventario  ;
		if id_almacenOld<>_id_almacen then
			res:=array['504','No existe el registro con el item :'|| _item::text || ' Debido a que el almacen Actual Seleccionado es diferente al Almacen con el cual fue Registrado'];
		else
			res:=array['504','No existe el registro con el item :'|| _item::text];
		end if;
		
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(1,1,'646',3,'5','0.00')
select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(4,1,'1031',15,'1.0000',NULL)


select *from ALMACEN.FN_STOCK('1031',15,1,1);

select * from ALMACEN.spi__actualizar__existencias(1,1,'1031',15,15,'1.0000','0.00')

--017553
select * from ventas.fn_anularpreventas(924,1)

select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(8,1,'0.0000',1,'3.0000',NULL)
select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(2,1,'3848',2,'1.0000',NULL)


select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(3,1,'1008',1,'1.0000'::numeric,NULL)

select stock,unit_id,cantidad  from ALMACEN.fn_stock_anula('1006',1,1,1);

select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(3,1,'1006',1,'1.0000'::numeric,NULL)



CREATE OR REPLACE FUNCTION almacen.fn_stock_anula(
    IN _id_producto character varying,
    IN _id_unidad integer,
    IN _id_almacen integer,
    IN _cantidad numeric)
  RETURNS TABLE(product_id character varying, unit_id integer, val_unit integer, stock numeric, cantidad numeric) AS
$BODY$
declare 
	_stock numeric(20,4);
	_val_unidad integer;
	_id_unidad_inventario integer;
	_val_unidad_inventario integer;
	_val_unidad_venta integer;
	_descuento numeric(20,4);
	_stock_saldo numeric(20,4);	
	_stock_reserva numeric(20,4);
begin
_descuento:=0;
stock:=0;
_val_unidad:=0;
_val_unidad_venta:=0;
_stock_saldo:=0;
	select dp.id_unidadventa,dp.val_unidad,stock_reserva into _id_unidad_inventario,_val_unidad_inventario,_stock_reserva from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto
	inner join almacen.tbl_existencia ex on ex.id_producto=dp.id_producto and ex.id_unidadventa=dp.id_unidadventa
	where ex.id_producto=_id_producto and ex.id_almacen=_id_almacen and dp.unidad_inventario=true;

	select dp.val_unidad into _val_unidad_venta from almacen.tbl_producto p
	inner join almacen.tbl_detproducto dp on p.id_producto=p.id_producto	 
	where dp.id_producto=_id_producto and dp.id_unidadventa=_id_unidad and dp.id_estado=1 ;

	RAISE NOTICE '_val_unidad_venta %', _val_unidad_venta;
	RAISE NOTICE '_id_unidad_inventario %', _id_unidad_inventario;
	RAISE NOTICE '_val_unidad_inventario %', _val_unidad_inventario;
	select stock_fisico into _stock from almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen and id_unidadventa=_id_unidad_inventario;
	RAISE NOTICE 'stock-01  %', _stock ;
	_descuento:=(_cantidad*_val_unidad_venta)/case when _val_unidad_inventario>0 then _val_unidad_inventario else 1 end;
	_stock_saldo :=_stock+_descuento;
	IF (SELECT COUNT(*) FROM almacen.tbl_existencia where id_producto=_id_producto and id_almacen=_id_almacen )>1 THEN
		RAISE NOTICE 'stock-02  %', _stock_saldo ;
		return query select COALESCE(_id_producto,'1'), COALESCE(_id_unidad_inventario,1), COALESCE(_val_unidad_inventario,1),COALESCE(_stock_saldo,0),COALESCE(_descuento,0);	
	ELSE
	return query select  ex.id_producto,ex.id_unidadventa,dp.val_unidad::integer, (ex.stock_fisico+_cantidad)::numeric(20,4) ,_cantidad::numeric(20,4) 
		from almacen.tbl_existencia ex 
		inner join almacen.tbl_detproducto dp on dp.id_producto=ex.id_producto and dp.id_unidadventa=ex.id_unidadventa
		where dp.id_producto=_id_producto and ex.id_almacen=_id_almacen and ex.id_unidadventa=_id_unidad_inventario and dp.unidad_inventario=true;
	END IF;

end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;


--select * from ventas.SPI_ANULARVENTA(109,1,7)

--update  ventas.tbl_facturacion set id_estado=1 where fecha_venta::date='16/01/2020' and numdoc_facturacion='0000625'

select *from almacen.v_producto
--select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(1,0,'4243',1,'12.0000'::numeric,'0'::numeric)

CREATE OR REPLACE FUNCTION almacen.spi_actualizar_existencias(
    op integer,
    _id_almacen integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _cantidad numeric,
    _cantidad_old numeric)
  RETURNS text[] AS
$BODY$
DECLARE	
	res text[];
	_id_sucursal integer;
	lrec_und_kdx record;--optenemos todas unidas del prducto y convertirlo a la unidad de inventario
	--cantidad numeric(20,3);--cantidad de ingreso/salida de las operaciones
	val_und_kardex numeric(20,3);--valor base de la unidad de inventario
	ls_unidmed  varchar(12);
	is_unidad_inventario boolean;	
	cantidad_old numeric(20,3);
	_unit_id integer;
	_stock numeric(20,4);
	_unidades_dscto numeric(20,4);
BEGIN


	if exists(select *from almacen.tbl_almacen where id_almacen=_id_almacen)then
		if exists(select *from  ALMACEN.TBL_EXISTENCIA where id_producto=_id_producto --and id_unidadventa=_id_unidadventa 
				and id_almacen=_id_almacen)then
			if op=1 then
				select id_sucursal into _id_sucursal from almacen.tbl_almacen where id_almacen=_id_almacen;
				/*				
				for lrec_und_kdx in select dp.unidad_inventario,dp.val_unidad,u.desc_corta as unidad  
					from 
						almacen.tbl_detproducto dp inner join 
						almacen.tbl_unidad u on (u.id_unidadventa=dp.id_unidadventa)
					 where id_producto=_id_producto loop
					if lrec_und_kdx.unidad_inventario=true then
						val_und_kardex:=lrec_und_kdx.val_unidad;
						ls_unidmed:=lrec_und_kdx.unidad;
					end if;
				end loop;

				for lrec_und_kdx in select *from almacen.tbl_detproducto where id_producto= _id_producto and id_unidadventa=_id_unidadventa loop
					if lrec_und_kdx.unidad_inventario=true then
						is_unidad_inventario=true;
					else
						is_unidad_inventario=false;
					end if;
				end loop;
				
				if is_unidad_inventario=true then
					cantidad=coalesce(_cantidad,0);
					cantidad_old=coalesce(_cantidad_old,0);
				else
					cantidad=coalesce(_cantidad,0)/val_und_kardex;
					cantidad_old=coalesce(_cantidad_old,0)/val_und_kardex;
				end if;*/
				select cantidad,unit_id into cantidad_old,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad_old);

				select stock,unit_id,cantidad into _stock,_unit_id,_unidades_dscto from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad);
				--select unit_id into _unit_id from ALMACEN.FN_STOCK('22',1,1,'3')
				--select * from ALMACEN.FN_STOCK('22',1,1,'3')
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock+cantidad_old
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico= _stock+cantidad_old
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
								
				update ALMACEN.TBL_EXISTENCIA set stock_reserva= COALESCE(stock_reserva,0)-COALESCE(_unidades_dscto,0)+COALESCE(cantidad_old,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				/*
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=stockh-COALESCE(_cantidad,0)+COALESCE(_cantidad_old,0)
				where id_producto=_id_producto and id_unidad=_id_unidadventa and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico=stock_fisico-COALESCE(_cantidad,0)+COALESCE(_cantidad_old,0)
				where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen;
				*/
				res:=array['0',_stock::text];
			end if;
			if op=2 then --extorna los stocks cuandos se anula una factura que tiene referencia a una preventa
				select cantidad,unit_id into cantidad_old,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad_old);

				select stock,unit_id,cantidad into _stock,_unit_id,_unidades_dscto from ALMACEN.fn_stock_anula(_id_producto,_id_unidadventa,_id_almacen,_cantidad);
				 
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock+_unidades_dscto
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico= _stock+_unidades_dscto
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
								
				update ALMACEN.TBL_EXISTENCIA set stock_reserva= COALESCE(stock_reserva,0)+COALESCE(_unidades_dscto,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				res:=array['0',_stock::text];
			end if;
			if op=3 then --extona el stock cuando se anula una factura sin preventa
				--select cantidad,unit_id into cantidad_old,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad_old);

				select stock,unit_id,cantidad into _stock,_unit_id,_unidades_dscto from ALMACEN.fn_stock_anula(_id_producto,_id_unidadventa,_id_almacen,_cantidad);
				RAISE NOTICE '_stock(%)', _stock ;
				RAISE NOTICE '_unit_id(%)', _unit_id ;
				RAISE NOTICE '_unidades_dscto(%)', _unidades_dscto ;
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock--+_unidades_dscto
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico= _stock--+_unidades_dscto
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				res:=array['0',_stock::text];								 
			end if;
			if op=4 then


				select cantidad,unit_id into _stock,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad);

				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=stockh+COALESCE(_stock,0)
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico=stock_fisico+COALESCE(_stock,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;	
				
				update ALMACEN.TBL_EXISTENCIA set stock_reserva= COALESCE(stock_reserva,0)+COALESCE(_stock,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				
				
				--update ALMACEN.TBL_EXISTENCIA set stocktransito=stocktransito-COALESCE(_cantidad,0),stock_fisico=stock_fisico+COALESCE(_cantidad,0)
				--where trim(id_producto)=trim(_id_producto) and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen returning array['0'] into res;
				res:=array['0',_stock::text];
			end if;
			if op=5 then
				/*
				select id_sucursal into _id_sucursal from almacen.tbl_almacen where id_almacen=_id_almacen;
								
				for lrec_und_kdx in select dp.unidad_inventario,dp.val_unidad,u.desc_corta as unidad  
					from 
						almacen.tbl_detproducto dp inner join 
						almacen.tbl_unidad u on (u.id_unidadventa=dp.id_unidadventa)
					 where id_producto=_id_producto loop
					if lrec_und_kdx.unidad_inventario=true then
						val_und_kardex:=lrec_und_kdx.val_unidad;
						ls_unidmed:=lrec_und_kdx.unidad;
					end if;
				end loop;

				for lrec_und_kdx in select *from almacen.tbl_detproducto where id_producto= _id_producto and id_unidadventa=_id_unidadventa loop
					if lrec_und_kdx.unidad_inventario=true then
						is_unidad_inventario=true;
					else
						is_unidad_inventario=false;
					end if;
				end loop;
				
				if is_unidad_inventario=true then
					cantidad=coalesce(_cantidad,0);
					cantidad_old=coalesce(_cantidad_old,0);
				else
					cantidad=coalesce(_cantidad,0)/val_und_kardex;
					cantidad_old=coalesce(_cantidad_old,0)/val_und_kardex;
				end if;
					*/
					
				/*update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=stockh+COALESCE(_cantidad,0)-COALESCE(_cantidad_old,0)
				where id_producto=_id_producto and id_unidad=_id_unidadventa and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico=stock_fisico+COALESCE(_cantidad,0)-COALESCE(_cantidad_old,0)
				where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen;	
				*/
				

				select stock,unit_id into _stock,_unit_id from ALMACEN.FN_STOCK_COMPRA(_id_producto,_id_unidadventa,_id_almacen,_cantidad,_cantidad_old);
				--select unit_id into _unit_id from ALMACEN.FN_STOCK('1130',1,1,'2')
				
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico= _stock
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
			



				
				--update ALMACEN.TBL_EXISTENCIA set stock_fisico=stock_fisico+COALESCE(_cantidad,0)
				--where trim(id_producto)=trim(_id_producto) and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen returning array['0'] into res;
				res:=array['0',_stock::text];
			end if;
			if op=6 then-- SOLO SE UTILIZA CUANDO SE ANULA UNA  NOTA DE INGRESO POR ORDEN DE COMPRA
				update ALMACEN.TBL_EXISTENCIA set stock_fisico=stock_fisico-COALESCE(_cantidad,0),stocktransito=stocktransito+COALESCE(_cantidad,0)
				where trim(id_producto)=trim(_id_producto) and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen returning array['0'] into res;
				--res:=array['000'];
			end if;

			if op=7 then
				select id_sucursal into _id_sucursal from almacen.tbl_almacen where id_almacen=_id_almacen;				 				
				select cantidad,unit_id into _stock,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad);				
				select cantidad,unit_id into cantidad_old,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad_old);
				--
				/*update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;
				*/
				--select *from ALMACEN.TBL_EXISTENCIA,--
				update ALMACEN.TBL_EXISTENCIA set stock_reserva= COALESCE(stock_reserva,0)+COALESCE(_stock,0)-COALESCE(cantidad_old,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				
				res:=array['0',_stock::text];
			end if;
			if op=8 then


				select cantidad,unit_id into _unidades_dscto,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad);
			
				update ALMACEN.TBL_EXISTENCIA set stock_reserva= COALESCE(stock_reserva,0)-COALESCE(_unidades_dscto,0)
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
				
				--update ALMACEN.TBL_EXISTENCIA set stocktransito=stocktransito-COALESCE(_cantidad,0),stock_fisico=stock_fisico+COALESCE(_cantidad,0)
				--where trim(id_producto)=trim(_id_producto) and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen returning array['0'] into res;
				res:=array['0',_stock::text];
			end if;
			if op=9 then  --se utiliza cuando se efectua una venta sin pedido de venta
				select cantidad,unit_id into cantidad_old,_unit_id from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad_old);

				select stock,unit_id,cantidad into _stock,_unit_id,_unidades_dscto from ALMACEN.FN_STOCK(_id_producto,_id_unidadventa,_id_almacen,_cantidad);
				
				update ALMACEN.TBL_SALDOSEXISTENCIA set stockh=_stock+cantidad_old
				where id_producto=_id_producto and id_unidad=_unit_id and id_sucursal=_id_sucursal;

				update ALMACEN.TBL_EXISTENCIA set stock_fisico= _stock+cantidad_old
				where id_producto=_id_producto and id_unidadventa=_unit_id and id_almacen=_id_almacen;
								
				 
				res:=array['0',_stock::text];
			end if;
			--res:=array['0',cantidad::text];
			--if not found then
			--	res:=array['504','Inconsistencia inesperada al actualizar el stock'];
			--end if;			
		else
			--res:=array['503','Verefique que los datos del productos esten ingresados correctamente'];
			res:=array['0','Verefique que los datos del productos esten ingresados correctamente'];
		end if;
	else
		res:=array['502','Verefique que el almacen este correctamente seleccionado'];
	end if;

return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from migrate.undart where codart='MED033'

select * from ALMACEN.SPI_ACTUALIZAR_EXISTENCIAS(7,1,'1012',13,'1.00','1.0000')
select * from ALMACEN.FN_STOCK('1012',13,1,2);

select stock_reserva,*from almacen.tbl_existencia where id_producto='2766'

select *from almacen.tbl_detproducto where id_producto='1012'

ALTER FUNCTION almacen.spi_actualizar_existencias(integer, integer, character varying, integer, numeric, numeric)
  OWNER TO postgres;

select *from ventas.tbl_facturacion

update ventas.tbl_facturacion set id_estado=1


CREATE OR REPLACE FUNCTION ventas.v_resumenboletas(IN _fecha text)
  RETURNS TABLE(serie text, codigo text, inicio integer, fin integer, 
  impgravada numeric, impexonerado numeric, impinafecto numeric, otroscagos numeric, imp_isc numeric, impigv numeric, total_percep numeric, otros_tributos numeric, imp_total numeric, nro_fila integer, identificador text, issuedate text, referencedate text, prefix text) AS
$BODY$
declare
begin
 return query SELECT f.serie_facturacion::text AS serie,
    cp.codigosunat,
    min(f.numdoc_facturacion::integer) AS startdocument,
    max(f.numdoc_facturacion::integer) AS enddocument,
        CASE
            WHEN f.id_operacion = 1 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_gravada,
        CASE
            WHEN f.id_operacion = 2 THEN sum(f.valor_venta)
            ELSE 0::numeric
        END AS valorventa_op_exonerada,
    0.00 AS valorventa_op_nafecta,
    0.00 AS otros_cargos,
    0.00 AS imp_isc,
    sum(f.imp_igv) AS impigv,
    sum(f.imp_total) AS total_percep,
    sum(f.imp_percepcion) AS otros_tributos,
    sum(f.imp_neto) AS imp_total,
    1 AS nro_fila,
    ('RC'::text || '-'::text) || to_char(f.fecha_venta::date::timestamp with time zone, 'yyyymmdd'::text) AS identificador,
    to_char(now()::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS issuedate,
    to_char(f.fecha_venta::date::timestamp with time zone, 'yyyy-mm-dd'::text) AS referencedate,
    'RC'::text AS prefix
   FROM ventas.tbl_facturacion f
     JOIN common.tbl_comprobante cp ON cp.id_comprobante = f.id_comprobante
     JOIN planillas.tbl_persona cli ON cli.id_persona::text = f.id_cliente::text
  WHERE cp.id_comprobante  in( 2,19) and f.fecha_venta::Date=_fecha::date --and f.serie_facturacion ilike '%BB%' AND  (trim(F.serie_facturacion)||trim(codigosunat)) not in('BB1107','BB1407')
  GROUP BY f.serie_facturacion, (f.fecha_venta::date), cp.codigosunat, f.id_operacion;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
211

CREATE OR REPLACE FUNCTION CAJA.ISP__ANULAR__MOVREC__EGRESO(
	_ID_MOVIMCAJA INTEGER,
	_ID_SUCURSAL INTEGER,
	_ID_USUARIO CHAR(5)	,
	_GLOSA TEXT
)
RETURNS TEXT[] AS $$
DECLARE
	res text;
BEGIN
IF EXISTS(SELECT * FROM  CAJA.TBL_MOVCAJA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL) THEN
	--IF EXISTS (SELECT *FROM CAJA.TBL_MOVCAJA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL AND FECHA_MOV::DATE=NOW()::DATE) THEN
		UPDATE CAJA.TBL_MOVCAJA SET ID_ESTADO=7,GLOSA=_GLOSA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL ;
		RES:=ARRAY['0','REGISTRO ANULADO'];
	--ELSE
	--	RES:=ARRAY['505','EL MOVIMIENTO DE CAJA QUE INTENTA ANULAR NO PERTENECE A LA FECHA DE LA CAJA APERTURADA','GENERE UN DOCUMENTO DE TIPO ANULACIÓN Y/O DEVOLUCIÓN'];
	--END IF;
ELSE
	res:=array['502','Verifique que exista el registro seleccionado'];
END IF;
RETURN RES;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION CAJA.ISP__ANULAR__MOVPAGO__CUOTA(
	_ID_MOVIMCAJA INTEGER,
	_ID_SUCURSAL INTEGER,
	_ID_USUARIO CHAR(5)	,
	_GLOSA TEXT
)
RETURNS TEXT[] AS $$
DECLARE
	res text;
BEGIN
IF EXISTS(SELECT * FROM  CAJA.TBL_MOVCAJA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL) THEN
--	IF EXISTS (SELECT *FROM CAJA.TBL_MOVCAJA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL AND FECHA_MOV::DATE=NOW()::DATE) THEN
	IF EXISTS (SELECT *FROM CAJA.TBL_MOVCAJA WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL ) THEN
		UPDATE CAJA.TBL_MOVCAJA SET 
			ID_ESTADO=7,
			GLOSA=_GLOSA,
			ID_USUARIOA=_ID_USUARIO ,
			fecha_anula=NOW()
		WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL ;
		UPDATE creditos.tbl_detpagocuota SET id_ussanula=_ID_USUARIO,fec_anula=NOW(),GLOSA=_GLOSA ,id_estado=7
			WHERE ID_MOVIMCAJA=_ID_MOVIMCAJA AND ID_SUCURSAL=_ID_SUCURSAL;
		RES:=ARRAY['0','REGISTRO ANULADO'];
	ELSE
		RES:=ARRAY['505','EL MOVIMIENTO DE CAJA QUE INTENTA ANULAR NO PERTENECE A LA FECHA DE LA CAJA APERTURADA','GENERE UN DOCUMENTO DE TIPO ANULACIÓN Y/O DEVOLUCIÓN'];
	END IF;
ELSE
	res:=array['502','Verifique que exista el registro seleccionado'];
END IF;
RETURN RES;
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION caja.spi_movreciboegresocaja(
    op integer,
    _id_movimcaja integer,
    _id_caja_origen integer,
    _id_caja_destino integer,
    _id_persona character varying,
    _id_sucursal_fac integer,
    _id_facturacion integer,
    _serie character,
    _numero character,
    _fecha_mov text,
    _descargo boolean,
    _imp_mora numeric,
    _imp_movimiento numeric,
    _imp_recibido numeric,
    _imp_vuelto numeric,
    _glosa text,
    _id_comprobante integer,
    _id_moneda integer,
    _id_tipocambio integer,
    _id_sucursal integer,
    _id_usuario character,
    _doc_referencia text,
    _id_estado integer,
    _id_tranzaccion character,
    _id_turno integer,
    _id_concepto character varying,
    _signo integer,
    _id_personaingdiv character varying,
    _dni_cliente character,
    _nomape_cliente text,
    _id__compra bigint,
    _id__sucursal__compra integer,
     _liquidacion_id bigint,
    _fecha_liquidacion text,
    _egreso_tarjeta boolean
    )
  RETURNS text[] AS
$BODY$
DECLARE
	correl integer;
	res text[];
BEGIN
if op=1 then
	if  exists(select *from COMMON.TBL_CONCEPTO
		where id=_id_concepto::integer) then
		if not  exists(select 1 from CAJA.TBL_MOVCAJA where serie=_serie and numero=_numero and id_comprobante=_id_comprobante and id_sucursal=_id_sucursal)then
			select max(id_movimcaja) into correl from  CAJA.TBL_MOVCAJA where  id_sucursal=_id_sucursal;
			if correl is  null then
				correl:=1;
			else
				correl:=correl+1;
			end if;
			insert into CAJA.TBL_MOVCAJA(	
				id_movimcaja,
				id_facturacion,
				id_caja_destino,
				id_persona,
				id_sucursal_fac,
				serie,
				numero,
				fecha_mov,
				descargo ,
				imp_mora ,
				imp_movimiento,
				imp_recibido  ,
				imp_vuelto    ,
				glosa         ,
				id_comprobante,
				id_moneda     ,
				id_tipocambio ,
				id_sucursal   ,
				id_usuario    ,
				doc_referencia,
				id_estado,
				id_tranzaccion,
				id_turno,
				id_concepto,
				signo,
				id_personaingdiv,
				DNI_CLIENTE ,
				NOMAPE_CLIENTE ,
				id__compra, 
				id__sucursal__compra,
				liquidacion_id ,
				fecha_liquidacion ,
				egreso_tarjeta
			)values(
				correl,
				case when _id_facturacion=0 then null else _id_facturacion end ,
				_id_caja_destino,
				_id_persona,
				case when _id_sucursal_fac =0 then null else _id_sucursal_fac end ,
				_serie,
				_numero,
				case when _fecha_mov is null then now() else  to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS')  end ,
				_descargo ,
				_imp_mora ,
				_imp_movimiento,
				_imp_recibido  ,
				_imp_vuelto    ,
				_glosa         ,
				_id_comprobante,
				_id_moneda     ,
				_id_tipocambio ,
				_id_sucursal   ,
				_id_usuario    ,
				_doc_referencia,
				_id_estado,
				_id_tranzaccion,
				_id_turno,
				_id_concepto,
				_signo,
				_id_personaingdiv,
				_DNI_CLIENTE ,
				_NOMAPE_CLIENTE ,
				case when _id__compra=0 then null else _id__compra end , 
				case when _id__sucursal__compra=0 then null else _id__sucursal__compra end,
				_liquidacion_id ,
				_fecha_liquidacion ::date,
				_egreso_tarjeta
			) returning array['0',TBL_MOVCAJA.id_movimcaja::text,TBL_MOVCAJA.id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el movimiento de caja'];
			end if;
		else
			res:=array['506','El Nro.Recibo ya esta registrado en el sistema'];
		end if;				
	else
		res:=array['504','Verefique que este seleccionado el motivo del movimiento de caja'];
	end if;
end if;
if op=2 then
	if exists (select *from caja.tbl_movcaja where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal) then
		delete from caja.tbl_detmovpago where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal;
		update CAJA.TBL_MOVCAJA set 
			id_caja_destino=_id_caja_destino,
			id_persona=_id_persona,
			id_sucursal_fac=_id_sucursal_fac,
			serie=_serie,
			numero=_numero,
			fecha_mov=to_timestamp(_fecha_mov,'YYYY-MM-DD HH24:MI:SS.MS') ,
			imp_movimiento=_imp_movimiento,
			imp_recibido =_imp_recibido  ,
			imp_vuelto  =_imp_vuelto    ,
			glosa      =_glosa         ,
			id_comprobante=_id_comprobante,
			id_moneda=_id_moneda     ,
			id_tipocambio=_id_tipocambio ,
			id_usuario=_id_usuario    ,
			doc_referencia=_doc_referencia,
			id_estado=_id_estado,
			id_tranzaccion=_id_tranzaccion,
			id_turno=_id_turno,
			id_concepto=_id_concepto,
			signo=_signo,
			id_personaingdiv=_id_personaingdiv ,
			DNI_CLIENTE=_DNI_CLIENTE ,
			NOMAPE_CLIENTE=_NOMAPE_CLIENTE ,
			id__compra=case when _id__compra=0 then null else _id__compra end, 
			id__sucursal__compra=case when _id__sucursal__compra=0 then null else _id__sucursal__compra end,
			liquidacion_id =_liquidacion_id ,
			fecha_liquidacion=fecha_liquidacion::date ,
			egreso_tarjeta=_egreso_tarjeta
			where id_movimcaja=_id_movimcaja and  id_sucursal=_id_sucursal;
			res:=array['0',_id_movimcaja::text,_id_sucursal::text,'Proceso efectuado con exito'];
	else
		res:=array['504','Verefique que el registro editado seleccionado correctamente'];
	end if;
end if;	
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION caja.spi_movreciboegresocaja(integer, integer, integer, integer, character varying, integer, integer, character, character, text, boolean, numeric, numeric, numeric, numeric, text, integer, integer, integer, integer, character, text, integer, character, integer, character varying, integer, character varying, character, text, bigint, integer)
  OWNER TO postgres;


CREATE OR REPLACE FUNCTION almacen.isp_newprogramainvtario(
    op integer,
    _id_tipoinventario integer,
    _fecha text,
    _id_almacen integer,
    _id_inventario integer,
    _glosa text,
    _id_usuario character,
    _id_estado integer,
    _id_inventarionew integer)
  RETURNS text[] AS
$BODY$
DECLARE
 correl integer;
 res text[];
 can_regs integer;
BEGIN
if op=1 then
	 if exists(select *from almacen.tbl_almacen where id_almacen=_id_almacen)then
		select max(id_inventario) into correl from ALMACEN.TBL_INVENTARIO where id_almacen=_id_almacen ;
		if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into ALMACEN.TBL_INVENTARIO(
			id_tipoinventario,
			fecha,
			id_almacen,
			id_inventario,
			glosa,
			id_usuario,
			id_estado 
		)values(
			_id_tipoinventario,
			cast(_fecha as date),
			_id_almacen,
			correl,
			_glosa,
			_id_usuario,
			_id_estado 
		)RETURNING ARRAY['0',id_inventario::TEXT,id_almacen::TEXT] INTO RES;
		IF NOT FOUND THEN
			RES:=ARRAY['504','No se ha relizado ninguna operacion'];
		END IF;
	else
		res:=array['503','Verfique que exista el almacen'];
	 end if;
end if;
if op=2 then
	 if exists(select *from ALMACEN.TBL_INVENTARIO where id_inventario=_id_inventario and id_almacen=_id_almacen ) then
		select count(*) into can_regs from almacen.tbl_cabinventario where id_inventario=_id_inventario and id_almacen=_id_almacen;
		if _id_inventarionew!=_id_inventario then
			update ALMACEN.TBL_INVENTARIO set
					id_tipoinventario=_id_tipoinventario,
					fecha=cast(_fecha as date),
					glosa=_glosa,
					id_usuario=_id_usuario,
					id_estado =_id_estado,
					id_inventario=_id_inventarionew,
					id_almacen=_id_almacen 
					where  id_inventario=_id_inventario and id_almacen=_id_almacen 
					returning array['0',id_inventario::TEXT,id_almacen::TEXT] INTO RES;
			if not found then
				res:=array['504','No se ha realizado ninguna actualización'];
			end if;	
		else
			update ALMACEN.TBL_INVENTARIO set
					--id_tipoinventario=_id_tipoinventario,
					fecha=cast(_fecha as date),
					glosa=_glosa,
					id_usuario=_id_usuario,
					id_estado =_id_estado
					--id_inventario=_id_inventarionew,
					--id_almacen=_id_almacen 
					where  id_inventario=_id_inventario and id_almacen=_id_almacen 
					returning array['0',id_inventario::TEXT,id_almacen::TEXT] INTO RES;
			if not found then
				res:=array['504','No se ha realizado ninguna actualización'];
			end if;	
			--res:=array['505','No puede cambiar el tipo de inventario ya se encuentran programados documentos de inventarios'];	
		end if;	
	else
		res:=array['505','Seleccione correctamente el registro para realizr este proceso de actualizacion'];	
	end if;
	
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION almacen.isp_newprogramainvtario(integer, integer, text, integer, integer, text, character, integer, integer)
  OWNER TO postgres;
CREATE OR REPLACE FUNCTION ventas.rec__cobranzasvendedor(
    refcursor,
    anio integer,
    id__mes integer,
    fecha_ini text,
    fecha_fin text,
    op integer,
    text)
  RETURNS refcursor AS
$BODY$
 DECLARE
	datVentas record  ;
	Cant_Total numeric(20,4);
	porcentParticip numeric(20,4);
 BEGIN
	


if op=1 then

	open $1 for 
select nombre_razon as vendedor,sum(importe_contado) as imp_contado,sum(imp_cobrado) as imp_cobrado,familia ,sum(importe_contado) +sum(imp_cobrado) as total
from ventas.v__cobrazans_vendedores

where date_part('month',fecha)=id__mes  and  date_part('year',fecha)=anio
group by nombre_razon,familia order by familia;

end if;	


if op=2 then

	open $1 for select nombre_razon as vendedor,sum(importe_contado) as imp_contado,sum(imp_cobrado) as imp_cobrado ,familia ,sum(importe_contado) +sum(imp_cobrado) as total
from ventas.v__cobrazans_vendedores
where  fecha>=cast(fecha_ini as date)and  fecha<=cast(fecha_fin as date)
group by nombre_razon,familia
order by familia;

end if;	
if op=3 then
	
	open $1 for 
 select nombre_razon as vendedor,sum(importe_contado) as imp_contado,sum(imp_cobrado) as imp_cobrado ,familia ,sum(importe_contado) +sum(imp_cobrado) as total
from ventas.v__cobrazans_vendedores
where   date_part('year',fecha)=anio 
group by nombre_razon,familia
order by familia;

end if;
return $1;
 END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION ventas.rec__cobranzasvendedor(refcursor, integer, integer, text, text, integer, text)
  OWNER TO postgres;


CREATE OR REPLACE FUNCTION caja.list_arqueocaja(
    IN __id__caja integer,
    IN __fecha text)
  RETURNS TABLE(numero text, cliente text, concepto text, tipoventa text, m text, efectivo numeric, deposito numeric, canje numeric, tarjeta numeric, cheque numeric, tipo text) AS
$BODY$
declare
begin

CREATE TEMPORARY TABLE ARQUEO(
	__numero text,
	__cliente text,
	__concepto text,
	__tipoventa text,
	__m text,
	__efectivo numeric, 
	__deposito numeric(20,4), 
	__canje numeric(20,4), 
	__tarjeta numeric(20,4), 
	__cheque NUMERIC(20,4),
	__tipo text
)ON COMMIT DROP;
/*
INSERT INTO ARQUEO(
	__numero,
	__tipo
	)VALUES('INGRESOS','INGRESOS');
	*/
INSERT INTO ARQUEO(
	__numero,
	__cliente,
	__concepto,
	__tipoventa,
	__m ,
	__tipo,
	__efectivo,
	__deposito,
	__canje,
	__tarjeta,
	__cheque
)  SELECT 
	ct.numero ,
	ct.cliente ,
	COALESCE(ct.concepto ,'') as concepto,
	ct.tipoventa ,
	ct.m ,
	ct.tipo,
	COALESCE(ct.efectivo ,0) as efectivo, 
	COALESCE(ct.deposito , 0) as deposito,
	COALESCE(ct.canje , 0) as canje,
	COALESCE(ct.tarjeta ,0) as tarjeta,
	COALESCE(ct.cheque,0) as cheque
 FROM crosstab(
  '
	SELECT 
		
		(com.descripcion_corta || ''/'' || f.serie_facturacion ||''-'' || f.numdoc_facturacion) as documento,
		CASE
                    WHEN btrim(f.id_cliente::text) =''000''::text THEN btrim(f.nomape_cliente)
                    ELSE (btrim(cli.nombre_razon::text))
                END AS cliente,
                CPTO.descripcion_larga AS concepto,
                tv.descripcion_larga as tv,
		M.SIMBOLO,
		''INGRESOS'',
		trim(fp.descripcion) as forma_pago,
		sum(COALESCE(dm.imp_pago,0)) as importe
	FROM ventas.tbl_facturacion f 
	inner join caja.tbl_movcaja CM on(f.id_facturacion=cm.id_facturacion and f.id_sucursal=cm.id_sucursal_Fac)
	left join common.tbl_concepto cpto on (cpto.id_concepto=cm.id_concepto)	
	INNER JOIN caja.tbl_detmovpago DM ON (CM.id_movimcaja=DM.id_movimcaja AND CM.id_sucursal=DM.id_sucursal) 
	INNER JOIN common.tbl_moneda m ON m.id_moneda = dm.id_moneda
	INNER JOIN common.tbl_formapago FP ON (FP.ID_FORMAPAGO=DM.ID_FORMAPAGO)
	INNER JOIN ventas.tbl_direccion dir ON dir.id_direccion = F.id_direccion AND dir.id_persona::text = F.id_cliente::text
	INNER JOIN planillas.tbl_persona cli ON cli.id_persona::text = dir.id_persona::text
	INNER JOIN common.tbl_comprobante com ON com.id_comprobante = f.id_comprobante
	INNER JOIN common.tbl_tipoventa tv ON (tv.id_tipoventa=f.id_tipoventa)
	 where cm.id_caja_destino='||__id__caja ||' and CM.fecha_mov::date=''' || __fecha || '''
	 group by 
		f.serie_facturacion, 
		f.numdoc_facturacion, 
		fp.descripcion,
		com.descripcion_corta ,
		f.id_cliente,
		f.nomape_cliente,
		cli.nombre_razon,
		cm.glosa,
		M.SIMBOLO,
		tv.descripcion_larga,
		CPTO.descripcion_larga
	ORDER BY 1',
  ' select descripcion from common.tbl_formapago m '
) AS ct(
	numero TEXT, 
	cliente text,
	concepto text,
	tipoventa text,
	M text,
	tipo text,
	efectivo numeric, 
	deposito numeric(20,4), 
	canje numeric(20,4), 
	tarjeta numeric(20,4), 
	cheque NUMERIC(20,4)
);


/*
INSERT INTO ARQUEO(
	__numero,
	__tipo
)VALUES('COBRANZAS','COBRANZAS');
*/
INSERT INTO ARQUEO(
	__numero,
	__cliente,
	__concepto,
	__tipoventa,
	__m ,
	__tipo,
	__efectivo,
	__deposito,
	__canje,
	__tarjeta,
	__cheque
) 
SELECT 
	ct.numero ,
	ct.cliente ,
	COALESCE(ct.concepto ,'') as concepto,
	ct.tipoventa ,
	ct.m ,
	ct.tipo,
	COALESCE(ct.efectivo ,0) as efectivo, 
	COALESCE(ct.deposito , 0) as deposito,
	COALESCE(ct.canje , 0) as canje,
	COALESCE(ct.tarjeta ,0) as tarjeta,
	COALESCE(ct.cheque,0) as cheque
 FROM crosstab(
  '
	SELECT 
		
		(com.descripcion_corta || ''/'' || cm.serie ||''-'' || cm.numero) as documento,
		CASE
                    WHEN btrim(cm.id_personaingdiv::text) =''000''::text THEN btrim(cm.nomape_cliente)
                    ELSE (btrim(cli.nombre_razon::text))
                END AS cliente,
                CPTO.descripcion_larga AS concepto,
                ''EGRESOS'' as tv,
		M.SIMBOLO,
		''COBRANZAS'',
		trim(fp.descripcion) as forma_pago,
		sum(COALESCE(dm.imp_pago,0)) as importe
	FROM  caja.tbl_movcaja cm
	left join common.tbl_concepto cpto on (cpto.id_concepto=cm.id_concepto)	
	INNER JOIN caja.tbl_detmovpago DM ON (CM.id_movimcaja=DM.id_movimcaja AND CM.id_sucursal=DM.id_sucursal) 
	INNER JOIN common.tbl_moneda m ON m.id_moneda = dm.id_moneda
	INNER JOIN common.tbl_formapago FP ON (FP.ID_FORMAPAGO=DM.ID_FORMAPAGO)	
	INNER JOIN planillas.tbl_persona cli ON cli.id_persona::text = cm.id_personaingdiv::text
	INNER JOIN common.tbl_comprobante com ON com.id_comprobante = cm.id_comprobante
	INNER JOIN creditos.tbl_detpagocuota dpc on (cm.id_movimcaja=dpc.id_movimcaja and cm.id_sucursal=dpc.id_sucursal)
	 where cm.id_caja_destino='||__id__caja ||' and CM.fecha_mov::date=''' || __fecha || ''' --AND CM.SIGNO=1
	 group by 
		cm.serie, 
		cm.numero, 
		fp.descripcion,
		com.descripcion_corta ,
		cm.id_personaingdiv,
		cm.nomape_cliente,
		cli.nombre_razon,
		cm.glosa,
		M.SIMBOLO,
		CPTO.descripcion_larga
	ORDER BY 1',
  ' select descripcion from common.tbl_formapago m '
) AS ct(
	numero TEXT, 
	cliente text,
	concepto text,
	tipoventa text,
	M text,
	tipo text,
	efectivo numeric, 
	deposito numeric(20,4), 
	canje numeric(20,4), 
	tarjeta numeric(20,4), 
	cheque NUMERIC(20,4)
);	

/*
INSERT INTO ARQUEO(
	__numero,
	__tipo
)VALUES('EGRESOS','EGRESOS');
*/
INSERT INTO ARQUEO(
	__numero,
	__cliente,
	__concepto,
	__tipoventa,
	__m ,
	__tipo,
	__efectivo,
	__deposito,
	__canje,
	__tarjeta,
	__cheque
) 
SELECT 
	ct.numero ,
	ct.cliente ,
	COALESCE(ct.concepto ,'') as concepto,
	ct.tipoventa ,
	ct.m ,
	ct.tipo,
	COALESCE(ct.efectivo ,0) as efectivo, 
	COALESCE(ct.deposito , 0) as deposito,
	COALESCE(ct.canje , 0) as canje,
	COALESCE(ct.tarjeta ,0) as tarjeta,
	COALESCE(ct.cheque,0) as cheque
 FROM crosstab(
  '
	SELECT 
		
		(com.descripcion_corta || ''/'' || cm.serie ||''-'' || cm.numero) as documento,
		CASE
                    WHEN btrim(cm.id_personaingdiv::text) =''000''::text THEN btrim(cm.nomape_cliente)
                    ELSE (btrim(cli.nombre_razon::text))
                END AS cliente,
                CPTO.descripcion_larga AS concepto,
                ''EGRESOS'' as tv,
		M.SIMBOLO,
		''EGRESOS'',
		trim(fp.descripcion) as forma_pago,
		sum(COALESCE(dm.imp_pago,0))*-1 as importe
	FROM  caja.tbl_movcaja cm
	left join common.tbl_concepto cpto on (cpto.id_concepto=cm.id_concepto)	
	INNER JOIN caja.tbl_detmovpago DM ON (CM.id_movimcaja=DM.id_movimcaja AND CM.id_sucursal=DM.id_sucursal) 
	INNER JOIN common.tbl_moneda m ON m.id_moneda = dm.id_moneda
	INNER JOIN common.tbl_formapago FP ON (FP.ID_FORMAPAGO=DM.ID_FORMAPAGO)	
	INNER JOIN planillas.tbl_persona cli ON cli.id_persona::text = cm.id_personaingdiv::text
	INNER JOIN common.tbl_comprobante com ON com.id_comprobante = cm.id_comprobante
	 where cm.id_caja_destino='||__id__caja ||' and CM.fecha_mov::date=''' || __fecha || ''' AND CM.SIGNO=-1
	 group by 
		cm.serie, 
		cm.numero, 
		fp.descripcion,
		com.descripcion_corta ,
		cm.id_personaingdiv,
		cm.nomape_cliente,
		cli.nombre_razon,
		cm.glosa,
		M.SIMBOLO,
		CPTO.descripcion_larga
	ORDER BY 1',
  ' select descripcion from common.tbl_formapago m '
) AS ct(
	numero TEXT, 
	cliente text,
	concepto text,
	tipoventa text,
	M text,
	tipo text,
	efectivo numeric, 
	deposito numeric(20,4), 
	canje numeric(20,4), 
	tarjeta numeric(20,4), 
	cheque NUMERIC(20,4)
);	

RETURN QUERY SELECT __numero ,
	COALESCE(__cliente ,'')__cliente,
	COALESCE(__concepto ,'') AS __concepto ,
	COALESCE(__tipoventa ,'') AS __tipoventa,
	COALESCE(__m ,'') __m,
	COALESCE(__efectivo , 0) __efectivo,
	COALESCE(__deposito, 0) __deposito,
	COALESCE(__canje , 0) __canje,
	COALESCE(__tarjeta,0) __tarjeta, 
	COALESCE(__cheque,0)__cheque   ,
	COALESCE(__tipo,'')__tipo   
	
	FROM ARQUEO;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION caja.list_arqueocaja(integer, text)
  OWNER TO postgres;


CREATE OR REPLACE FUNCTION planillas.isp_nrocuenta(
    op integer,
    _id_nrocuenta bigint,
    _nro_cuenta character varying,
    _id_estado integer,
    _id_persona character varying,
    _id_banco integer,
    _id_moneda integer,
    _id_usuario character)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	id bigint;
BEGIN
if op=1 then
	if not  exists(select 1 from planillas.tbl_nrocuenta where nro_cuenta=_nro_cuenta and id_banco=_id_banco and id_persona=_id_persona)then
		select max(id_nrocuenta) into id from planillas.tbl_nrocuenta;
		if id is null then
			id:=1;
		else
			id:=id+1;
		end if;
		INSERT INTO planillas.tbl_nrocuenta(
			id_nrocuenta, 
			nro_cuenta, 
			id_estado, 
			id_persona, 
			id_banco, 
			id_moneda, 
			id_usuario_reg, 
			fecha_reg
		)
		VALUES (
			id, 
			_nro_cuenta, 
			_id_estado, 
			_id_persona, 
			_id_banco, 
			_id_moneda, 
			_id_usuario, 
			now()
		)returning array['0','Registro efectuado con exito'] into res;

		if not found then
			res:=array['503','Inconsistencioa inesperada'];
		end if;
	else
		res:=array['502','El Nro de cuenta ya existe'];
	end if;
end if;
if op=2 then
	if exists(select 1 from planillas.tbl_nrocuenta where id_nrocuenta=_id_nrocuenta)then
		UPDATE planillas.tbl_nrocuenta
		   SET  nro_cuenta=_nro_cuenta, 
			id_estado=_id_estado, 
			id_persona=_id_persona, 
			id_banco=_id_banco, 
		        id_moneda=_id_moneda, 
		        id_usuario_act=_id_usuario, 
		       fecha_act=now()
		 WHERE id_nrocuenta=_id_nrocuenta returning array['0','Actualizacion efectuada con exito'] into res;
	else
		res:=array['502','Veferefique que exista el registro seleccionado para realizar este proceso'];
	end if;
end if;
RETURN RES;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
select * from creditos.list_vcuentas__x__pagar(1)where  proveedor ilike '%%' and id_sucursal=1

CREATE OR REPLACE  FUNCTION creditos.list_vcuentas__x__pagar(IN __id_sucursal integer)
  RETURNS TABLE(
	documento text, 
	fec_credito timestamp without time zone, 
	proveedor character varying, 
	fec_vencimiento timestamp without time zone, 
	moneda character varying, 
	credito numeric, 
	pagos numeric, 
	saldo numeric, 
	total_venta numeric, 
	tipo_venta text, 
	id_compra integer, 
	id_sucursal_compra integer, 
	id_proveedor character varying, 
	id_dirproveedor bigint, 
	id_credito integer, 
	id_sucursal integer, 
	comprobante character, 
	serie character, 
	nro_doc_compra character, 
	dni character, 
	estado text, 
	id_estado integer, 
	id_moneda integer,
	importe_nc numeric(20,2)
) AS
$BODY$
declare
	dat record;
	rec_docs record;
	docs text;
	_proveedor text;
	__id_credito integer;
	__id_sucursal integer;
	_moneda text;
	_doc_persona text;
	_tipo_venta text;
	_imp_total numeric(20,4);
	_comprobante char(3);
	query text;
begin

		
	
	
	return query	
	SELECT c.documento ,
            cred.fec_emision AS fec_credito,
            c.proveedor::varchar(100) as _proveedor,
            ( SELECT c.fec_vencimiento
                   FROM creditos.tbl_cuota c
                  WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito
                  ORDER BY c.nro_cuota DESC
                 LIMIT 1) AS fec_vencimiento,
            c.moneda::varchar(5),
            
            COALESCE(( SELECT sum(c.imp_cuota) AS sum
                   FROM creditos.tbl_cuota c
                  WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito), 0::numeric) AS credito,
                  
		COALESCE((select sum(dp.imp_pago)from creditos.tbl_detpagocuota dp
		where dp.id_credito=cred.id_credito and dp.id_sucursal_credito=cred.id_sucursal_credito and dp.id_Estado=1),0) as pagos,

            COALESCE(( SELECT sum(c.imp_cuota) AS sum
                   FROM creditos.tbl_cuota c
                  WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito), 0::numeric) - 
		COALESCE(( SELECT sum(cmov.imp_pago) AS sum
                   FROM creditos.tbl_detpagocuota cmov 
        WHERE cred.id_credito = cmov.id_credito AND cred.id_sucursal_credito = cmov.id_sucursal_credito and cmov.id_estado=1), 0::numeric)-COALESCE((select sum(nc.imp_dscto) from creditos.tbl_cuota_notacredito NC where cred.ID_CREDITO=NC.ID_CREDITO AND cred.ID_SUCURSAL_CREDITO=NC.id_sucursal_cred),0) AS saldo,
            c.imp_total + COALESCE(( SELECT sum(c.imp_interes) AS sum
                   FROM creditos.tbl_cuota c
                  WHERE cred.id_credito = c.id_credito AND cred.id_sucursal_credito = c.id_sucursal_credito), 0.00) AS total_venta,
           c.tipo_venta,
            0 _id_compra,
            1::integer as _id_sucursalcompra,
            c.id_proveedor::varchar(15) as _id_proveedor,
            0::bigint  as _id_dirproveedor,
            cred.id_credito as _id_credito,
            cred.id_sucursal_credito as _id_sucursal_credito,
            c.comprobante,
            ''::char(4) serie,
            ''::char(7) as _nro_doc_compra,
            c.doc_persona::char(11) AS _dni,
            e.des_estado::text as estado,
            cred.id_estado,
            c.id_moneda,
	    COALESCE((select sum(nc.imp_dscto) from creditos.tbl_cuota_notacredito NC where cred.ID_CREDITO=NC.ID_CREDITO AND cred.ID_SUCURSAL_CREDITO=NC.id_sucursal_cred),0) as importe_nc
           FROM 
           creditos.tbl_credito cred 
           inner join common.tbl_estado e on (e.id_estado=cred.id_estado)
           inner join creditos.list_agrupadocscompras( cred.id_credito,cred.id_sucursal_credito) c on (cred.id_credito=c.id_Credito and cred.id_sucursal_credito=c.id_sucursal);
	  --where cred.id_sucursal_credito=__id_sucursal;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

CREATE OR REPLACE FUNCTION creditos.list_agrupadocscompras(
    IN __id_credito integer,
    IN __id_sucursal integer)
  RETURNS TABLE(documento text, id_credito integer, id_sucursal integer, moneda text, tipo_venta text, proveedor text, imp_total numeric, doc_persona text, comprobante character, id_proveedor text, id_moneda integer) AS
$BODY$
declare
	dat record;
	rec_docs record;
	docs text;
	_proveedor text;
	_id_credito integer;
	_id_sucursal integer;
	_moneda text;
	_doc_persona text;
	_tipo_venta text;
	_imp_total numeric(20,4);
	_comprobante char(3);
	numbers_regs integer;
	rows integer;
	documents text;
begin
	/*CREATE TEMPORARY TABLE  imp_documentos (
			_documento text,
			_nombre_razon text,
			_id_credito integer,
			_id_sucursal integer,
			_moneda text,
			_tipo_venta text,
			_proveedor text,
			_imp_total numeric(20,4),
			_doc_persona  text,
			_comprobante char(3)
			
		)ON COMMIT DROP;*/
		rows:=0;
		for rec_docs in select 
			(((tbl_comprobante.descripcion_corta::text || '/'::text) || fac.serie::text) || '-'::text) || fac.nro_doc_compra::text AS documento
					
			FROM compras.tbl_compra fac
				inner  JOIN creditos.tbl_creditoscompra vc ON fac.id_sucursalcompra=vc.id_sucursalcompra and  fac.id__compra=vc.id__compra 
				inner JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
				where vc.id_credito=__id_credito and vc.id_sucursal_credito=__id_sucursal
				
			loop
				
					documents:=COALESCE(documents ,'') || COALESCE(rec_docs.documento,'') || ', ' ;		
			rows:=rows+1;
		end loop;
		docs:= substring(trim(documents) from 1 for (length(trim(documents))-1));
		return query 
		select 
			docs::text documento,			
			vc.id_credito	,
			vc.id_sucursal_credito,	
			m.simbolo::text AS moneda,		
			tv.descripcion_larga::text as tipo_venta,	
			cli.nombre_razon::text as proveedor,	
			sum(fac.imp_total) as imp_total,		
			cli.doc_persona::text as doc_persona	,			
			tbl_comprobante.descripcion_corta::char(3) AS comprobante,
			cli.id_persona::text as id_proveedor,
			fac.id_moneda
			FROM compras.tbl_compra fac
				inner  JOIN creditos.tbl_creditoscompra vc ON fac.id_sucursalcompra=vc.id_sucursalcompra and  fac.id__compra=vc.id__compra 
				JOIN planillas.tbl_persona cli ON cli.id_persona::text = fac.id_proveedor::text
				inner JOIN common.tbl_comprobante ON fac.id_comprobante = tbl_comprobante.id_comprobante
				JOIN common.tbl_moneda m ON fac.id_moneda = m.id_moneda
				JOIN common.tbl_tipoventa tv ON tv.id_tipoventa = fac.id_tipocompra 
				where vc.id_credito=__id_credito and vc.id_sucursal_credito=__id_sucursal
				group by vc.id_sucursal_credito,vc.id_credito,	
					m.simbolo,		
					tv.descripcion_larga,	
					cli.nombre_razon,							
					cli.doc_persona	,			
					tbl_comprobante.descripcion_corta,cli.id_persona,fac.id_moneda
				;
		
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

CREATE OR REPLACE FUNCTION creditos.spi_cuotacompra(
    op integer,
    _id_cuotas integer,
    _id_credito integer,
    _id_sucursal_credito integer,
    _nro_letra character varying,
    _nro_cuota integer,
    _fec_vencimiento text,
    _imp_capital numeric,
    _imp_interes numeric,
    _imp_cuota numeric,
    _imp_adicional numeric,
    _imp_mora numeric,
    _intervalo_dias integer,
    _dias_gracia integer,
    _imp_total numeric,
    _fec_registro text,
    _genera_mora boolean,
    _id_estado integer,
    _nro_unico_pago character varying,
    _dias_protesto integer)
  RETURNS text[] AS
$BODY$
DECLARE	
	res text[];
	correl integer;
	_fecha_protesto timestamp;
BEGIN
_fecha_protesto:=_fec_vencimiento::date +  CAST( _dias_protesto || ' DAY' AS INTERVAL);
/*
IF NOT EXISTS(SELECT *FROM creditos.tbl_detpagocuota WHERE id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito AND id_estado<>1) THEN
	DELETE FROM CREDITOS.TBL_CUOTA WHERE id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito;
ELSE
	RES:=ARRAY['505','EL DOCUMENTO DE COMPRA YA TIENE MOMIENTOS DE CAJA'];
END IF;*/
if op=1 then
	if exists(select *from creditos.tbl_credito where id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
		select max(id_cuotas) into correl from CREDITOS.TBL_CUOTA;-- where id_credito=_id_credito and  id_sucursal_credito=_id_sucursal_credito;
		if correl is null then
			correl:=1;
		else
			correl:=correl+1;
		end if;
		insert into CREDITOS.TBL_CUOTA(
			id_cuotas ,
			id_credito,
			id_sucursal_credito,
			nro_letra  ,
			nro_cuota  ,
			fec_vencimiento,
			imp_capital ,
			imp_interes ,
			imp_cuota   ,
			imp_adicional,
			imp_mora     ,
			intervalo_dias,
			dias_gracia   ,
			imp_total     ,
			fec_registro  ,
			genera_mora   ,
			id_estado,
			NRO_UNICO_PAGO,
			dias_protesto,
			FECHA_PROTESTO
		)
		values(
			correl ,
			_id_credito,
			_id_sucursal_credito,
			_nro_letra  ,
			_nro_cuota  ,
			_fec_vencimiento::DATE,
			_imp_capital ,
			_imp_interes ,
			_imp_cuota   ,
			_imp_adicional,
			_imp_mora     ,
			_intervalo_dias,
			_dias_gracia   ,
			_imp_total     ,
			_fec_registro::DATE ,
			_genera_mora   ,
			_id_estado,
			_NRO_UNICO_PAGO,
			_dias_protesto,
			_fecha_protesto
		)returning array['0',TBL_CUOTA.id_cuotas::text,TBL_CUOTA.id_credito::text,TBL_CUOTA.id_sucursal_credito::text,nro_cuota::TEXT] into res;
		if not found then
			res=array['504','Inconsistencia inesperada al reguistrar las cuotas de credito'];
		end if;
	else
		res:=array['503','Verefique que los datos del credito esten ingresados correctamente'];
	end if;
end if;
if  op=2 then
	if exists(select *from creditos.tbl_credito where id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
		if exists(select *from creditos.TBL_CUOTA where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito) then
			update creditos.TBL_CUOTA set 
			nro_letra=_nro_letra  ,
			nro_cuota=_nro_cuota  ,
			fec_vencimiento=to_timestamp(_fec_vencimiento,'YYYY-MM-DD HH24:MI:SS.MS'),
			imp_capital =_imp_capital,
			imp_interes=_imp_interes ,
			imp_cuota=_imp_cuota   ,
			imp_adicional=_imp_adicional,
			imp_mora=_imp_mora     ,
			intervalo_dias=_intervalo_dias,
			dias_gracia=_dias_gracia   ,
			imp_total=_imp_total     ,
			fec_registro=to_timestamp(_fec_registro,'YYYY-MM-DD HH24:MI:SS.MS')   ,
			genera_mora=_genera_mora   ,
			id_estado =_id_estado ,
			NRO_UNICO_PAGO=_NRO_UNICO_PAGO,
			dias_protesto=_dias_protesto,
			FECHA_PROTESTO=_fecha_protesto
			where id_cuotas=_id_cuotas and  id_credito=_id_credito and id_sucursal_credito=_id_sucursal_credito;
			res:=array['0',_id_cuotas::text,_id_credito::text,_id_sucursal_credito::text];
		else
			res:=array['503','Verefique que la cuota este seleccionado correctamente para realizar la actualización'];
		end if;
	else
		res:=array['503','Verefique que los datos del credito esten ingresados correctamente'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from CREDITOS.ISP_CREDITOSCOMPRA(1,4334,1,1,1,0,12015911,0,NULL,NULL,0,'45221.94')
select * from CREDITOS.ISP_CREDITOSCOMPRA(1,4335,1,1,1,2017,18,1,'1','2017-01-16 18:11:57.704',0,'1500.00')
SELECT id__compra,*FROM COMPRAS.TBL_COMPRA WHERE ID__COMPRA=18

CREATE OR REPLACE FUNCTION creditos.isp_creditoscompra(
    op integer,
    _id_credito integer,
    _id_estado integer,
    _id_sucursal_credito integer,
    _id_sucursalcompra integer,
    _anio integer,
    _id_compra integer,
    _id_mes integer,
    _id_usuario character,
    _fec_registro text,
    _id_creditoscompra bigint,
    _importe_documento numeric)
  RETURNS text[] AS
$BODY$
DECLARE
	CODIGO TEXT;
	RES TEXT[];
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM  compras.tbl_compra WHERE id_sucursalcompra=_id_sucursalcompra AND id__compra=_id_compra ) THEN
		IF EXISTS(SELECT 1 FROM creditos.tbl_credito WHERE id_credito=_id_credito AND  id_sucursal_credito=_id_sucursal_credito) THEN
			CODIGO:=_id_credito::TEXT || _id_sucursal_credito::TEXT ||_id_sucursalcompra::TEXT || _id_compra::TEXT;
			_id_creditoscompra:=CODIGO::BIGINT;	
			INSERT INTO creditos.tbl_creditoscompra(
				id_credito, 
				id_estado, 
				id_sucursal_credito, 
				id_sucursalcompra, 
				id__compra, 
				id_usuario, 
				fec_registro, 
				fec_actualizacion, 
				id_ussactualiza, 
				id_creditoscompra, 
				importe_documento
			)
			VALUES (
				_id_credito, 
				_id_estado, 
				_id_sucursal_credito, 
				_id_sucursalcompra, 
				_id_compra, 
				_id_usuario, 
				to_timestamp(_fec_registro,'YYYY-MM-DD HH24:MI:SS.MS'),
				NOW(), 
				_id_usuario, 
				_id_creditoscompra, 
				_importe_documento
			)RETURNING ARRAY['0',id_creditoscompra::TEXT] INTO RES;
			IF NOT FOUND THEN
				RES:=ARRAY['504','Ha ocurrido un iconsistencia al vincular las conpras con el credito'];
			END IF;
		ELSE
			RES:=ARRAY['503','Verefique que la cabecera de creditos este bien ingresado'];
		END IF;
	else
		res:=array['502','Verefique que los documentos de compra esten correctamente seleccionados'];
	END IF;
END IF;
if op=2 then
	if EXISTS(SELECT *FROM creditos.tbl_creditoscompra WHERE id_creditoscompra=_id_creditoscompra)then
		IF EXISTS(SELECT 1 FROM  compras.tbl_compra WHERE id_sucursalcompra=_id_sucursalcompra AND anio=_anio AND id_compra=_id_compra AND id_mes=_id_mes) THEN
			IF EXISTS(SELECT 1 FROM creditos.tbl_credito WHERE id_credito=_id_credito AND  id_sucursal_credito=_id_sucursal_credito) THEN
				UPDATE creditos.tbl_creditoscompra
				   SET id_credito=_id_credito, 
					id_estado=_id_estado, 
					id_sucursal_credito=_id_sucursal_credito, 
					id_sucursalcompra=_id_sucursalcompra, 
					id__compra=_id_compra, 
				        fec_actualizacion=now(), 
				        id_ussactualiza=_id_usuario, 				       
				       importe_documento=_importe_documento
				 WHERE id_creditoscompra=_id_creditoscompra;
				RES:=ARRAY['0','PROCESO EFECTUADO CON EXITO'];
			ELSE
			RES:=ARRAY['503','Verefique que la cabecera de creditos este bien ingresado'];
			END IF;
		else
			res:=array['502','Verefique que los documentos de compra esten correctamente seleccionados'];
		END IF;
	ELSE
		RES:=ARRAY['501','Verefique que exista el registro editado'];
	END IF;
END IF;
return res;	
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION almacen.isp_notaingalmacen(
    op integer,
    _id_movimiento bigint,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _id_comprobanteref integer,
    _id_almdestino integer,
    _id_tranzaccion character,
    _fecha text,
    _doc_referencia character varying,
    _id_motivo character varying,
    _fec_llegada text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _porcent_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_neto numeric,
    _glosa text,
    _id_sucursal integer,
    _id_dirclientprov bigint,
    _id_clientprov character varying,
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _id_vendedor character varying,
    _schema text,
    _tabla text,
    _codigorefk text,
    _ingreso boolean,
    _id_cotizaorden bigint,
    _id_ordeproduccion bigint,
    _serie_guia character,
    _serie_comprobante character,
    _numero_comprobante character,
    _id_comprobanteguia integer,
    _id_movimientoref bigint,
    _id_sucursalref bigint,
    _confirm_traslado boolean)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl text;
BEGIN
if op=1 then
	if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
		IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=_id_comprobante AND serie=_serie AND numero=_numero AND id_sucursal=_id_sucursal) then
			--correl:=_id_comprobante::text || _serie || _numero|| _id_sucursal::text;
			--_id_movimiento:=correl::bigint;
			select max(id_movimiento) into _id_movimiento from  almacen.tbl_cabmovalm;
			if _id_movimiento is null then
				_id_movimiento:=1;
			else
				_id_movimiento:=_id_movimiento+1;
			end if;

			insert into almacen.tbl_cabmovalm(
				id_movimiento,
				serie,
				numero,
				id_comprobante       ,
				id_comprobanteref    ,
				id_almdestino        ,
				id_tranzaccion       ,
				fecha                ,
				doc_referencia       ,
				id_motivo            ,
				fec_llegada          ,
				imp_bruto            ,
				imp_dscto            ,
				porcent_dscto	     ,
				valor_venta          ,
				imp_igv              ,
				imp_neto             ,
				glosa                ,
				id_sucursal          ,
				id_dirclientprov     ,
				id_clientprov        ,
				id_igv               ,
				id_tipocambio        ,
				id_moneda            ,
				id_vendedor,
				schema,
				tabla,
				codigorefk,
				ingreso,
				id_cotizaorden,
				id_ordeproduccion ,
				serie_guia,
				serie_comprobante,
				numero_comprobante,
				id_comprobanteguia,
				id_movimientoref      ,
				id_sucursalref,
				confirm_traslado
			)values(
				_id_movimiento,
				_serie,
				_numero,
				_id_comprobante       ,
				_id_comprobanteref    ,
				_id_almdestino        ,
				_id_tranzaccion       ,
				to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				_doc_referencia       ,
				_id_motivo            ,
				to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_bruto            ,
				_imp_dscto            ,
				_porcent_dscto	     ,
				_valor_venta          ,
				_imp_igv              ,
				_imp_neto             ,
				_glosa                ,
				_id_sucursal          ,
				_id_dirclientprov     ,
				_id_clientprov        ,
				_id_igv               ,
				_id_tipocambio        ,
				_id_moneda            ,
				_id_vendedor,
				_schema,
				_tabla,
				_codigorefk,
				_ingreso,
				case when _id_cotizaorden=0 then null else _id_cotizaorden end ,
				case when _id_ordeproduccion =0 then null else _id_ordeproduccion end,
				_serie_guia,
				_serie_comprobante,
				_numero_comprobante,
				_id_comprobanteguia,
				_id_movimientoref      ,
				_id_sucursalref,
				_confirm_traslado
			)returning array['0',id_movimiento::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar la cabecera de la nota de ingreso'];
			end if;
		ELSE
			RES:=ARRAY['502','El numero de nota de ingreso ya existe'];
		END IF;
	else
		res:=array['503','Verefique que exista el proveedor'];
	end if;
end if;
if op=2 then
	if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=_id_movimiento) then
		if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
			update almacen.tbl_cabmovalm set
				serie=_serie,
				numero=_numero,
				id_comprobante=_id_comprobante,
				id_comprobanteref=_id_comprobanteref,
				id_almdestino=_id_almdestino,
				id_tranzaccion=_id_tranzaccion,
				fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				doc_referencia=_doc_referencia ,
				id_motivo =_id_motivo ,
				fec_llegada=to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS') ,
				imp_bruto=_imp_bruto,
				imp_dscto=_imp_dscto,
				porcent_dscto=_porcent_dscto,
				valor_venta=_valor_venta,
				imp_igv=_imp_igv,
				imp_neto=_imp_neto,
				glosa=_glosa,
				id_sucursal=_id_sucursal,
				id_dirclientprov=_id_dirclientprov,
				id_clientprov=_id_clientprov,
				id_igv=_id_igv,
				id_tipocambio=_id_tipocambio,
				id_moneda=_id_moneda,
				id_vendedor=_id_vendedor ,
				schema=_schema,
				tabla=_tabla,
				codigorefk=_codigorefk,
				ingreso=_ingreso,
				id_cotizaorden=case when _id_cotizaorden=0 then null else _id_cotizaorden end,
				id_ordeproduccion =case when _id_ordeproduccion=0 then null else _id_ordeproduccion end ,
				serie_guia=_serie_guia,
				serie_comprobante=_serie_comprobante,
				numero_comprobante=_numero_comprobante,
				id_comprobanteguia=_id_comprobanteguia,
				id_movimientoref=_id_movimientoref      ,
				id_sucursalref=_id_sucursalref,
				confirm_traslado=_confirm_traslado
				where id_movimiento=_id_movimiento returning array['0',id_movimiento::text] into res;
		else
			res:=array['503','Verefique que exista el proveedor'];
		end if;
	else
		res:=array['503','Seleccion correctamente la nota de ingreso'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.isp_notasalidaalmacen(
    op integer,
    _id_movimiento bigint,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _id_comprobanteref integer,
    _id_almorigen integer,
    _id_tranzaccion character,
    _fecha text,
    _doc_referencia character varying,
    _id_motivo character varying,
    _fec_llegada text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _porcent_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_neto numeric,
    _glosa text,
    _id_sucursal integer,
    _id_dirclientprov bigint,
    _id_clientprov character varying,
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _id_vendedor character varying,
    _schema text,
    _tabla text,
    _codigorefk text,
    _salida boolean,
    _id_ordeproduccion bigint,
    _id_tipoventa integer,
    _id_responsablesalida character varying,
    _id_almdestino integer,
    _id_movimientoref bigint,
    _id_sucursalref bigint)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl BIGINT;
BEGIN
if op=1 then
	if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
		IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=_id_comprobante AND serie=_serie AND numero=_numero AND id_sucursal=_id_sucursal) then
			--correl:=_id_comprobante::text || _serie::integer || _numero::bigint|| _id_sucursal::text;
			---_id_movimiento:=correl::bigint;

			select max(id_movimiento) into correl from  almacen.tbl_cabmovalm;
			if correl is null then
				correl:=1;
			else
				correl:=correl+1;				
			end if;
				_id_movimiento:=correl;
			insert into almacen.tbl_cabmovalm(
				id_movimiento,
				serie,
				numero,
				id_comprobante       ,
				id_comprobanteref    ,
				id_almorigen        ,
				id_tranzaccion       ,
				fecha                ,
				doc_referencia       ,
				id_motivo            ,
				fec_llegada          ,
				imp_bruto            ,
				imp_dscto            ,
				porcent_dscto	     ,
				valor_venta          ,
				imp_igv              ,
				imp_neto             ,
				glosa                ,
				id_sucursal          ,
				id_dirclientprov     ,
				id_clientprov        ,
				id_igv               ,
				id_tipocambio        ,
				id_moneda            ,
				id_vendedor,
				schema,
				tabla,
				codigorefk,
				salida,
				id_ordeproduccion,
				id_tipoventa,
				id_responsableSalida,
				id_almdestino,
				id_movimientoref,
				id_sucursalref
			)values(
				_id_movimiento,
				_serie,
				_numero,
				_id_comprobante       ,
				_id_comprobanteref    ,
				_id_almorigen        ,
				_id_tranzaccion       ,
				to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				_doc_referencia       ,
				_id_motivo            ,
				to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_bruto            ,
				_imp_dscto            ,
				_porcent_dscto	     ,
				_valor_venta          ,
				_imp_igv              ,
				_imp_neto             ,
				_glosa                ,
				_id_sucursal          ,
				_id_dirclientprov     ,
				_id_clientprov        ,
				_id_igv               ,
				_id_tipocambio        ,
				_id_moneda            ,
				_id_vendedor,
				_schema,
				_tabla,
				_codigorefk,
				_salida,
				case when _id_ordeproduccion=0 then null else _id_ordeproduccion end ,
				_id_tipoventa,
				_id_responsableSalida,
				case when _id_tranzaccion in ('27','28') then _id_almdestino  else null end,
				_id_movimientoref,
				_id_sucursalref
			)returning array['0',id_movimiento::text,id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar la cabecera de la nota de ingreso'];
			end if;
		ELSE
			RES:=ARRAY['502','El numero de nota de ingreso ya existe'];
		END IF;
	else
		res:=array['503','Verefique que exista el proveedor'];
	end if;
end if;
if op=2 then
	if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=_id_movimiento) then
		if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
			update almacen.tbl_cabmovalm set
				serie=_serie,
				numero=_numero,
				id_comprobante=_id_comprobante,
				id_comprobanteref=_id_comprobanteref,
				id_almorigen=_id_almorigen,
				id_tranzaccion=_id_tranzaccion,
				fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				doc_referencia=_doc_referencia ,
				id_motivo =_id_motivo ,
				fec_llegada=to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS') ,
				imp_bruto=_imp_bruto,
				imp_dscto=_imp_dscto,
				porcent_dscto=_porcent_dscto,
				valor_venta=_valor_venta,
				imp_igv=_imp_igv,
				imp_neto=_imp_neto,
				glosa=_glosa,
				id_sucursal=_id_sucursal,
				id_dirclientprov=_id_dirclientprov,
				id_clientprov=_id_clientprov,
				id_igv=_id_igv,
				id_tipocambio=_id_tipocambio,
				id_moneda=_id_moneda,
				id_vendedor=_id_vendedor ,
				schema=_schema,
				tabla=_tabla,
				codigorefk=_codigorefk,
				salida=_salida,
				id_ordeproduccion =case when _id_ordeproduccion=0 then null else _id_ordeproduccion   end ,
				id_tipoventa=_id_tipoventa,
				id_responsableSalida=_id_responsableSalida,
				id_almdestino=case when _id_tranzaccion in('27','28') then _id_almdestino  else null end
				where id_movimiento=_id_movimiento returning array['0',id_movimiento::text,id_sucursal::text] into res;
		else
			res:=array['503','Verefique que exista el proveedor'];
		end if;
	else
		res:=array['503','Seleccion correctamente la nota de ingreso'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;




CREATE OR REPLACE FUNCTION almacen.isp_notaingalmacen(
    op integer,
    _id_movimiento bigint,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _id_comprobanteref integer,
    _id_almdestino integer,
    _id_tranzaccion character,
    _fecha text,
    _doc_referencia character varying,
    _id_motivo character varying,
    _fec_llegada text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _porcent_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_neto numeric,
    _glosa text,
    _id_sucursal integer,
    _id_dirclientprov bigint,
    _id_clientprov character varying,
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _id_vendedor character varying,
    _schema text,
    _tabla text,
    _codigorefk text,
    _ingreso boolean,
    _id_cotizaorden bigint,
    _id_ordeproduccion bigint,
    _serie_guia character,
    _serie_comprobante character,
    _numero_comprobante character,
    _id_comprobanteguia integer,
    _id_movimientoref bigint,
    _id_sucursalref bigint,
    _confirm_traslado boolean)
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl text;
BEGIN
if op=1 then
	if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
		IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=_id_comprobante AND serie=_serie AND numero=_numero AND id_sucursal=_id_sucursal) then
			--correl:=_id_comprobante::text || _serie || _numero|| _id_sucursal::text;
			--_id_movimiento:=correl::bigint;
			select max(id_movimiento) into _id_movimiento from  almacen.tbl_cabmovalm;
			if _id_movimiento is null then
				_id_movimiento:=1;
			else
				_id_movimiento:=_id_movimiento+1;
			end if;

			insert into almacen.tbl_cabmovalm(
				id_movimiento,
				serie,
				numero,
				id_comprobante       ,
				id_comprobanteref    ,
				id_almdestino        ,
				id_tranzaccion       ,
				fecha                ,
				doc_referencia       ,
				id_motivo            ,
				fec_llegada          ,
				imp_bruto            ,
				imp_dscto            ,
				porcent_dscto	     ,
				valor_venta          ,
				imp_igv              ,
				imp_neto             ,
				glosa                ,
				id_sucursal          ,
				id_dirclientprov     ,
				id_clientprov        ,
				id_igv               ,
				id_tipocambio        ,
				id_moneda            ,
				id_vendedor,
				schema,
				tabla,
				codigorefk,
				ingreso,
				id_cotizaorden,
				id_ordeproduccion ,
				serie_guia,
				serie_comprobante,
				numero_comprobante,
				id_comprobanteguia,
				id_movimientoref      ,
				id_sucursalref,
				confirm_traslado
			)values(
				_id_movimiento,
				_serie,
				_numero,
				_id_comprobante       ,
				_id_comprobanteref    ,
				_id_almdestino        ,
				_id_tranzaccion       ,
				to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				_doc_referencia       ,
				_id_motivo            ,
				to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_bruto            ,
				_imp_dscto            ,
				_porcent_dscto	     ,
				_valor_venta          ,
				_imp_igv              ,
				_imp_neto             ,
				_glosa                ,
				_id_sucursal          ,
				_id_dirclientprov     ,
				_id_clientprov        ,
				_id_igv               ,
				_id_tipocambio        ,
				_id_moneda            ,
				_id_vendedor,
				_schema,
				_tabla,
				_codigorefk,
				_ingreso,
				case when _id_cotizaorden=0 then null else _id_cotizaorden end ,
				case when _id_ordeproduccion =0 then null else _id_ordeproduccion end,
				_serie_guia,
				_serie_comprobante,
				_numero_comprobante,
				_id_comprobanteguia,
				_id_movimientoref      ,
				_id_sucursalref,
				_confirm_traslado
			)returning array['0',id_movimiento::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar la cabecera de la nota de ingreso'];
			end if;
		ELSE
			RES:=ARRAY['502','El numero de nota de ingreso ya existe'];
		END IF;
	else
		res:=array['503','Verefique que exista el proveedor'];
	end if;
end if;
if op=2 then
	if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=_id_movimiento) then
		if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
			update almacen.tbl_cabmovalm set
				serie=_serie,
				numero=_numero,
				id_comprobante=_id_comprobante,
				id_comprobanteref=_id_comprobanteref,
				id_almdestino=_id_almdestino,
				id_tranzaccion=_id_tranzaccion,
				fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				doc_referencia=_doc_referencia ,
				id_motivo =_id_motivo ,
				fec_llegada=to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS') ,
				imp_bruto=_imp_bruto,
				imp_dscto=_imp_dscto,
				porcent_dscto=_porcent_dscto,
				valor_venta=_valor_venta,
				imp_igv=_imp_igv,
				imp_neto=_imp_neto,
				glosa=_glosa,
				id_sucursal=_id_sucursal,
				id_dirclientprov=_id_dirclientprov,
				id_clientprov=_id_clientprov,
				id_igv=_id_igv,
				id_tipocambio=_id_tipocambio,
				id_moneda=_id_moneda,
				id_vendedor=_id_vendedor ,
				schema=_schema,
				tabla=_tabla,
				codigorefk=_codigorefk,
				ingreso=_ingreso,
				id_cotizaorden=case when _id_cotizaorden=0 then null else _id_cotizaorden end,
				id_ordeproduccion =case when _id_ordeproduccion=0 then null else _id_ordeproduccion end ,
				serie_guia=_serie_guia,
				serie_comprobante=_serie_comprobante,
				numero_comprobante=_numero_comprobante,
				id_comprobanteguia=_id_comprobanteguia,
				id_movimientoref=_id_movimientoref      ,
				id_sucursalref=_id_sucursalref,
				confirm_traslado=_confirm_traslado
				where id_movimiento=_id_movimiento returning array['0',id_movimiento::text] into res;
		else
			res:=array['503','Verefique que exista el proveedor'];
		end if;
	else
		res:=array['503','Seleccion correctamente la nota de ingreso'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION almacen.isp_notasalidaalmacenObras(
    op integer,
    _id_movimiento bigint,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _id_comprobanteref integer,
    _id_almorigen integer,
    _id_tranzaccion character,
    _fecha text,
    _doc_referencia character varying,
    _id_motivo character varying,
    _fec_llegada text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _porcent_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_neto numeric,
    _glosa text,
    _id_sucursal integer,
    _id_dirclientprov bigint,
    _id_clientprov character varying,
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _id_vendedor character varying,
    _schema text,
    _tabla text,
    _codigorefk text,
    _salida boolean,
    _id_ordeproduccion bigint,
    _id_tipoventa integer,
    _id_responsablesalida character varying,
    _id_almdestino integer,
    _id_movimientoref bigint,
    _id_sucursalref bigint,
    _dniruc_cliente varchar(15),
    _nomape_cliente varchar(250),
    _direccion_cliente varchar(250)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl text;
BEGIN
if op=1 then
	if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
		IF NOT EXISTS(SELECT *FROM almacen.tbl_cabmovalm WHERE id_comprobante=_id_comprobante AND serie=_serie AND numero=_numero AND id_sucursal=_id_sucursal) then
			correl:=_id_comprobante::text || _serie::integer || _numero::bigint|| _id_sucursal::text;
			_id_movimiento:=correl::bigint;
			select max(id_movimiento) into _id_movimiento from almacen.tbl_cabmovalm;
			if _id_movimiento is null then
				_id_movimiento:=1;
			else
				_id_movimiento:=_id_movimiento+1;
			end if;
			insert into almacen.tbl_cabmovalm(
				id_movimiento,
				serie,
				numero,
				id_comprobante       ,
				id_comprobanteref    ,
				id_almorigen        ,
				id_tranzaccion       ,
				fecha                ,
				doc_referencia       ,
				id_motivo            ,
				fec_llegada          ,
				imp_bruto            ,
				imp_dscto            ,
				porcent_dscto	     ,
				valor_venta          ,
				imp_igv              ,
				imp_neto             ,
				glosa                ,
				id_sucursal          ,
				id_dirclientprov     ,
				id_clientprov        ,
				id_igv               ,
				id_tipocambio        ,
				id_moneda            ,
				id_vendedor,
				schema,
				tabla,
				codigorefk,
				salida,
				id_ordeproduccion,
				id_tipoventa,
				id_responsableSalida,
				id_almdestino,
				id_movimientoref,
				id_sucursalref,
				dniruc_cliente,
				nomape_cliente,
				direccion_cliente 
			)values(
				_id_movimiento,
				_serie,
				_numero,
				_id_comprobante       ,
				_id_comprobanteref    ,
				_id_almorigen        ,
				_id_tranzaccion       ,
				to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				_doc_referencia       ,
				_id_motivo            ,
				to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_bruto            ,
				_imp_dscto            ,
				_porcent_dscto	     ,
				_valor_venta          ,
				_imp_igv              ,
				_imp_neto             ,
				_glosa                ,
				_id_sucursal          ,
				_id_dirclientprov     ,
				_id_clientprov        ,
				_id_igv               ,
				_id_tipocambio        ,
				_id_moneda            ,
				_id_vendedor,
				_schema,
				_tabla,
				_codigorefk,
				_salida,
				case when _id_ordeproduccion=0 then null else _id_ordeproduccion end ,
				_id_tipoventa,
				_id_responsableSalida,
				case when _id_tranzaccion in ('27','28') then _id_almdestino  else null end,
				_id_movimientoref,
				_id_sucursalref,
				_dniruc_cliente,
				_nomape_cliente,
				_direccion_cliente 
			)returning array['0',id_movimiento::text,id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar la cabecera de la nota de ingreso'];
			end if;
		ELSE
			RES:=ARRAY['502','El numero de nota de ingreso ya existe'];
		END IF;
	else
		res:=array['503','Verefique que exista el proveedor'];
	end if;
end if;
if op=2 then
	if exists(select *from  almacen.tbl_cabmovalm where id_movimiento=_id_movimiento) then
		if exists(select *from ventas.tbl_direccion where id_direccion=_id_dirclientprov and  id_persona=_id_clientprov) then
			update almacen.tbl_cabmovalm set
				serie=_serie,
				numero=_numero,
				id_comprobante=_id_comprobante,
				id_comprobanteref=_id_comprobanteref,
				id_almorigen=_id_almorigen,
				id_tranzaccion=_id_tranzaccion,
				fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'),
				doc_referencia=_doc_referencia ,
				id_motivo =_id_motivo ,
				fec_llegada=to_timestamp(_fec_llegada,'YYYY-MM-DD HH24:MI:SS.MS') ,
				imp_bruto=_imp_bruto,
				imp_dscto=_imp_dscto,
				porcent_dscto=_porcent_dscto,
				valor_venta=_valor_venta,
				imp_igv=_imp_igv,
				imp_neto=_imp_neto,
				glosa=_glosa,
				id_sucursal=_id_sucursal,
				id_dirclientprov=_id_dirclientprov,
				id_clientprov=_id_clientprov,
				id_igv=_id_igv,
				id_tipocambio=_id_tipocambio,
				id_moneda=_id_moneda,
				id_vendedor=_id_vendedor ,
				schema=_schema,
				tabla=_tabla,
				codigorefk=_codigorefk,
				salida=_salida,
				id_ordeproduccion =case when _id_ordeproduccion=0 then null else _id_ordeproduccion   end ,
				id_tipoventa=_id_tipoventa,
				id_responsableSalida=_id_responsableSalida,
				id_almdestino=case when _id_tranzaccion in('27','28') then _id_almdestino  else null end,
				dniruc_cliente=_dniruc_cliente,
				nomape_cliente=_nomape_cliente,
				direccion_cliente=_direccion_cliente 
				where id_movimiento=_id_movimiento returning array['0',id_movimiento::text,id_sucursal::text] into res;
		else
			res:=array['503','Verefique que exista el proveedor'];
		end if;
	else
		res:=array['503','Seleccion correctamente la nota de ingreso'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



select * from ventas.ISP_GRABARPREVENTA(2,1,3462,3462,1,'0001','0003345',16,'14/02/2021','14/02/2021','15.30','0','15.3','0','15.30','0','1',1,349,'177','1    ',1,'Venta Realizada con la session iniciada del usuario:ADMINISTRADOR DEL SISTEMA',1,1,1,'0.00','20',1,'1',NULL,'43791368','CARMELA VALLEJOS HERRERA   ','JR. CHICLAYO / MOYOBAMBA ','BVT','0',NULL,NULL,NULL,'')
select *from ventas.tbl_cotizacionpreventa

CREATE OR REPLACE FUNCTION ventas.isp_grabarpreventa(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,--23
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,--30
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono  varchar(50),--39
    _orden_compra text
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		if (_id_cliente='000'  and _imp_total>750 )  then
			res:=array['506','Es obligatorio ingresar datos completos del cliente(DNI,Nombres y apellidos,direccion) a partir de 750.00  soles'];
			return res;
		end if;
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI,
			    orden_compra
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    _numero, 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono,
			    _orden_compra
			    			    
		) RETURNING ARRAY['0',id_cotizapreventa::TEXT,id_sucursal::TEXT] INTO RES;
		IF NOT FOUND THEN
			RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    serie=_serie, 
				    numero=_numero, 
				    id_comprobante=_id_comprobante, 
				    fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono,
				    orden_compra=_orden_compra
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
	END IF;
END IF;


return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



select * from ventas.ISP_DETPREVENTA(1,3462,1,'2.00','3','0.00','0','6.00','FIDEO VITTORIO COD/RAY X 250 GR.',1,'4210',1,1,1,3,'01','0','Iten por cotización',1,1,'0','0','0',NULL,NULL,NULL,NULL,0)

select *from ventas.tbl_detpreventacotiza where id_cotizapreventa=3462

CREATE OR REPLACE FUNCTION ventas.isp_grabarpreventa_automatica(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,--23
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,--30
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono  varchar(50),--39
    _orden_compra text
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
_TIPDOCUMENTO:='TCK';
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		IF NOT EXISTS(SELECT  1 FROM ventas.tbl_cotizacionpreventa WHERE SERIE=_serie AND NUMERO=_NUMERO) THEN 
			SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
			IF CORREL IS NULL THEN
				CORREL:=1;
			ELSE
				CORREL:=CORREL+1;
			END IF;
			if (_id_cliente='000'  and _imp_total>750 )  then
				res:=array['506','Es obligatorio ingresar datos completos del cliente(DNI,Nombres y apellidos,direccion) a partir de 750.00  soles'];
				return res;
			end if;
			INSERT INTO ventas.tbl_cotizacionpreventa(
				    id_cotizapreventa, 
				    id_cotizacion, 
				    id_sucursalcotizacion, 
				    id_sucursal, 
				    serie, 
				    numero, 
				    id_comprobante, 
				    fecha, 
				    id_tranzaccion, 
				    imp_bruto, 
				    imp_dscto, 
				    valor_venta, 
				    imp_igv, 
				    imp_total, 
				    id_estado, 
				    id_direccion, 
				    id_cliente, 
				    cotizacion, 
				    preventa, 
				    id_usuarior, 
				    id_tipoventa, 
				    glosa, 
				    id_igv, 
				    id_tipocambio, 
				    id_moneda, 
				    redondeo, 
				    id_usuarioa, 
				    date_act, 
				    id_operacion, 
				    valido_hasta,
				    ID_VENDEDOR,
				    DNI_CLIENTE,
				    NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE,
				    TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION,
				    IMP_NETO,
				    TELEFONO_CLI,
				    orden_compra
				)
			    VALUES (
				    CORREL,-- id_cotizapreventa, 
				    case when _id_cotizacion=0 then null else _id_cotizacion end, 
				   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
				    _id_sucursal, 
				    _serie, 
				    _numero, 
				    _id_comprobante, 
				    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    _id_tranzaccion, 
				    _imp_bruto, 
				    _imp_dscto, 
				    _valor_venta, 
				    _imp_igv, 
				    _imp_total, 
				    _id_estado, 
				    _id_direccion, 
				    _id_cliente, 
				    _cotizacion, 
				    _preventa, 
				    _id_usuario, 
				    _id_tipoventa, 
				    _glosa, 
				    _id_igv, 
				    _id_tipocambio, 
				    _id_moneda, 
				    _redondeo, 
				    _id_usuario, 
				    now(), 
				    _id_operacion, 
				    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    _ID_VENDEDOR,
				    _DNI_CLIENTE,
				    _NOMAPE_CLIENTE,
				    _DIRECCION_CLIENTE,
				    _TIPDOCUMENTO,
				    _BLOQUEAR_ENCAJA,
				    _IMP_PERCEPCION,
				    _IMP_NETO,
				    _telefono,
				    _orden_compra
							    
			) RETURNING ARRAY['0',id_cotizapreventa::TEXT,id_sucursal::TEXT] INTO RES;
			IF NOT FOUND THEN
				RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
			END IF;
		ELSE
			RES:=ARRAY['502','ORDEN DE VENTA YA GENERADA','0'];
	--ROLLBACK
		END IF;
	else
		RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    serie=_serie, 
				    numero=_numero, 
				    id_comprobante=_id_comprobante, 
				    --fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    --valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono,
				    orden_compra=_orden_compra
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
	END IF;
END IF;


return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


 select *from ventas.tbl_cotizacionpreventa

CREATE OR REPLACE FUNCTION ventas.isp_grabarpreventa_solicitud(
    op integer,
    _id_sucursal integer,
    _id_cotizapreventa bigint,
    _id_cotizacion bigint,
    _id_sucursalcotizacion integer,
    _serie character,
    _numero character,
    _id_comprobante integer,
    _fecha text,
    _valido_hasta text,
    _imp_bruto numeric,
    _imp_dscto numeric,
    _valor_venta numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _cotizacion boolean,
    _preventa boolean,
    _id_estado integer,
    _id_direccion bigint,
    _id_cliente character varying,
    _id_usuario character,
    _id_tipoventa integer,
    _glosa text,--23
    _id_igv integer,
    _id_tipocambio integer,
    _id_moneda integer,
    _redondeo numeric,
    _id_tranzaccion character,
    _id_operacion integer,
    _id_vendedor character varying,--30
    _observaciones text,
    _dni_cliente character,
    _nomape_cliente text,
    _direccion_cliente text,
    _tipdocumento text,
    _bloquear_encaja boolean,
    _imp_percepcion numeric,
    _imp_neto numeric,
    _telefono  varchar(50),--39
    _solicitud_credito_id bigint,
    _sucursal_solicitud_credito_id bigint
    
    
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	correl integer;
BEGIN
IF OP=1 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_DIRECCION WHERE id_direccion=_id_direccion AND id_persona=_id_cliente) THEN
		SELECT MAX(id_cotizapreventa) INTO CORREL FROM VENTAS.TBL_COTIZACIONPREVENTA ;--WHERE ID_SUCURSAL=_ID_SUCURSAL;
		IF CORREL IS NULL THEN
			CORREL:=1;
		ELSE
			CORREL:=CORREL+1;
		END IF;
		INSERT INTO ventas.tbl_cotizacionpreventa(
			    id_cotizapreventa, 
			    id_cotizacion, 
			    id_sucursalcotizacion, 
			    id_sucursal, 
			    serie, 
			    numero, 
			    id_comprobante, 
			    fecha, 
			    id_tranzaccion, 
			    imp_bruto, 
			    imp_dscto, 
			    valor_venta, 
			    imp_igv, 
			    imp_total, 
			    id_estado, 
			    id_direccion, 
			    id_cliente, 
			    cotizacion, 
			    preventa, 
			    id_usuarior, 
			    id_tipoventa, 
			    glosa, 
			    id_igv, 
			    id_tipocambio, 
			    id_moneda, 
			    redondeo, 
			    id_usuarioa, 
			    date_act, 
			    id_operacion, 
			    valido_hasta,
			    ID_VENDEDOR,
			    DNI_CLIENTE,
			    NOMAPE_CLIENTE,
			    DIRECCION_CLIENTE,
			    TIPDOCUMENTO,
			    BLOQUEAR_ENCAJA,
			    IMP_PERCEPCION,
			    IMP_NETO,
			    TELEFONO_CLI,
			    solicitud_credito_id,
			    sucursal_solicitud_credito_id
			)
		    VALUES (
			    CORREL,-- id_cotizapreventa, 
			    case when _id_cotizacion=0 then null else _id_cotizacion end, 
			   case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end, 
			    _id_sucursal, 
			    _serie, 
			    _numero, 
			    _id_comprobante, 
			    now(),--to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
			    _id_tranzaccion, 
			    _imp_bruto, 
			    _imp_dscto, 
			    _valor_venta, 
			    _imp_igv, 
			    _imp_total, 
			    _id_estado, 
			    _id_direccion, 
			    _id_cliente, 
			    _cotizacion, 
			    _preventa, 
			    _id_usuario, 
			    _id_tipoventa, 
			    _glosa, 
			    _id_igv, 
			    _id_tipocambio, 
			    _id_moneda, 
			    _redondeo, 
			    _id_usuario, 
			    now(), 
			    _id_operacion, 
			    now(),--to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
			    _ID_VENDEDOR,
			    _DNI_CLIENTE,
			    _NOMAPE_CLIENTE,
			    _DIRECCION_CLIENTE,
			    _TIPDOCUMENTO,
			    _BLOQUEAR_ENCAJA,
			    _IMP_PERCEPCION,
			    _IMP_NETO,
			    _telefono,
			    _solicitud_credito_id,
			    _sucursal_solicitud_credito_id
			    			    
		) RETURNING ARRAY['0',id_cotizapreventa::TEXT,id_sucursal::TEXT] INTO RES;
		IF NOT FOUND THEN
			RES:=ARRAY['504','Inconsistencia inesperada verfique que los datos esten ingresados correctamente'];
		END IF;
	--ROLLBACK;
	else
		RES:=ARRAY['503','Seleccione un cliente para realizar este proceso'];
		--ROLLBACK;
	END IF;

END IF;
IF OP=2 THEN
	IF EXISTS(SELECT 1 FROM VENTAS.TBL_COTIZACIONPREVENTA  WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal) THEN
		UPDATE VENTAS.TBL_COTIZACIONPREVENTA SET 
				    id_cotizacion= case when _id_cotizacion=0 then null else _id_cotizacion end, 
				    id_sucursalcotizacion= case when _id_sucursalcotizacion=0 then null else _id_sucursalcotizacion end,  
				    serie=_serie, 
				    numero=_numero, 
				    id_comprobante=_id_comprobante, 
				    fecha=to_timestamp(_fecha,'YYYY-MM-DD HH24:MI:SS.MS'), 
				    id_tranzaccion=_id_tranzaccion, 
				    imp_bruto=_imp_bruto, 
				    imp_dscto=_imp_dscto, 
				    valor_venta=_valor_venta, 
				    imp_igv=_imp_igv, 
				    imp_total=_imp_total, 
				    id_estado=_id_estado, 
				    id_direccion=_id_direccion, 
				    id_cliente=_id_cliente, 
				    cotizacion=_cotizacion, 
				    preventa=_preventa, 
				    id_tipoventa=_id_tipoventa, 
				    glosa=_glosa, 
				    id_igv=_id_igv, 
				    id_tipocambio=_id_tipocambio, 
				    id_moneda=_id_moneda, 
				    redondeo=_redondeo, 
				    id_usuarioa=_id_usuario, 
				    date_act=now(), 
				    id_operacion=_id_operacion, 
				    valido_hasta= to_timestamp(_valido_hasta,'YYYY-MM-DD HH24:MI:SS.MS'),
				    ID_VENDEDOR=_ID_VENDEDOR,
				    DNI_CLIENTE=_DNI_CLIENTE,
				    NOMAPE_CLIENTE=_NOMAPE_CLIENTE,
				    DIRECCION_CLIENTE=_DIRECCION_CLIENTE,
				    TIPDOCUMENTO=_TIPDOCUMENTO,
				    BLOQUEAR_ENCAJA=_BLOQUEAR_ENCAJA,
				    IMP_PERCEPCION=_IMP_PERCEPCION,
				    IMP_NETO=_IMP_NETO,
				    TELEFONO_CLI=_telefono
				WHERE id_cotizapreventa=_id_cotizapreventa AND  id_sucursal=_id_sucursal;
				res:=array['0',_id_cotizapreventa::TEXT,_id_sucursal::TEXT];
	ELSE
		RES:=ARRAY['504','Verefique que el registro este seleccionado correctamente el registro'];
	END IF;
END IF;


return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  

CREATE OR REPLACE FUNCTION common.spiu_comprobante(
    op integer,
    codigo character,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _id_estado integer,
    _codigo_sunat text,
    _prefix char(1)
  )
  RETURNS text[] AS
$BODY$
declare
   correl    integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_comprobante where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id_comprobante) INTO correl FROM common.tbl_comprobante ;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into common.tbl_comprobante (
			id_comprobante,
			descripcion_larga, 
			id_estado,
			descripcion_corta,
			codigosunat,
			prefix
			)
		values(
			correl, 
			_descripcion_larga, 
			_id_estado, 
			_descripcion_corta,
			_codigo_sunat,
			_prefix
		) RETURNING array['0',tbl_comprobante.id_comprobante::text] INTO res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		res:=array['1'];
	    end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_comprobante where id_comprobante=codigo::integer)) then
		update common.tbl_comprobante set 
			descripcion_larga = _descripcion_larga , 
			id_estado = _id_estado, 
			descripcion_corta = _descripcion_corta,
			codigosunat=_codigo_sunat,
			prefix=_prefix
		where id_comprobante = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

CREATE OR REPLACE FUNCTION common.spiu_configserie(
    op integer,
    codigo character,
    _id_comprobante integer,
    _serie character,
    _numero integer,
    _id_estado integer,
    _id_tranzaccion character,
    _impresora text,
    _plantilla text,
    _desde integer,
    _hasta integer,
    _serie_impresora text,
    _id_sucursal integer,
    _SERIE_ELECTRONICA BOOLEAN,
    _imp_directa boolean,
    _plantilla_generica boolean,
    _plantilla_a4 text
    )
  RETURNS text[] AS
$BODY$
declare
   correl    integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_configserie 
		where id_comprobante = _id_comprobante and id_sucursal = _id_sucursal and serie=_serie and id_tranzaccion=_id_tranzaccion)) then
		SELECT MAX(id_configserie) INTO correl FROM common.tbl_configserie ;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into common.tbl_configserie (
			id_configserie,
			id_comprobante,
			serie,
			numero,
			id_estado,
			id_tranzaccion,
			impresora,
			plantilla,
			desde,
			hasta,
			serie_impresora,
			id_sucursal,
			SERIE_ELECTRONICA,
			imp_directa,
			plantilla_generica,
			plantilla_a4
			)
		values(
			correl, 
			_id_comprobante,
			_serie,
			_numero,
			_id_estado,
			_id_tranzaccion,
			_impresora,
			_plantilla,
			_desde,
			_hasta,
			_serie_impresora,
			_id_sucursal,
			_SERIE_ELECTRONICA,
			_imp_directa,
			_plantilla_generica,
			_plantilla_a4
		) RETURNING array['0',tbl_configserie.id_configserie::text] INTO res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		res:=array['1','Configuración de Serie ya ha sido registrada \n en SUCURSAL y COMPROBANTE seleccionados ...!!'];
	end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_configserie where id_configserie=codigo::integer)) then
		update common.tbl_configserie set 
			id_comprobante = _id_comprobante,
			serie = _serie,
			numero = _numero,
			id_estado = _id_estado,
			id_tranzaccion = _id_tranzaccion,
			impresora = _impresora,
			plantilla = _plantilla,
			desde = _desde,
			hasta = _hasta,
			serie_impresora = _serie_impresora,
			id_sucursal = _id_sucursal,
			SERIE_ELECTRONICA=_SERIE_ELECTRONICA,
			imp_directa=_imp_directa,
			plantilla_generica=_plantilla_generica,
			plantilla_a4=_plantilla_a4
		where id_configserie = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from CAJA.TBL_CUENTABANCARIA




CREATE OR REPLACE FUNCTION compras.spiu__nota__credito(
    op integer,
    __nro__doc__compra character,
    __fec__documento text,
    __id__dirproveedor bigint,
    __id__comprobante integer,
    __id__tranzaccion character,
    __id__igv integer,
    __anio integer,
    __id_compra integer,
    __id__mes integer,
    __fec__ingsistema text,
    __imp__venta numeric,
    __imp__dcsto numeric,
    __porcent__dcsto numeric,
    __imp__igv numeric,
    __porcent__reintegro numeric,
    __imp__reintegro numeric,
    __sujeto__percepcion boolean,
    __id__sucursalcompra integer,
    __id__estado integer,
    __id__proveedor character varying,
    __serie character,
    __id__tipocambio integer,
    __mercaderia__transito boolean,
    __actualizar__precios boolean,
    __id__tipocompra integer,
    __paga__flete boolean,
    __doc__referencia character,
    __imp__bruto numeric,
    __imp__total numeric,
    __imp__exonerado numeric,
    __id__operacion integer,
    __imp__percepcion numeric,
    __genera__letra boolean,
    __reintegro__tributario boolean,
    __fec__ingalmacen text,
    __id__moneda integer,
    __imp__flete numeric,
    __imp__factor numeric,
    __id__ordencompra integer,
    __id__sucursalorden integer,
    __pesototal numeric,
    __imp__afecto numeric,
    __actualiza__stock boolean,
    __pesovolumen boolean,
    __destinarventaconigv boolean,
    __id__responsable character varying,
    __referencia__ncr text,
    __id__movimiento text,
    __id__compra bigint,
    __id__compra__ref bigint,
    __id__sucursal__ref integer,
    __nota__credito boolean,
    __id__concepto character,
    __id_motivonotacredito character(2),
    __imp_tipo_cambio numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res TEXT[];
	_id integer;
BEGIN

IF op=1 then
	if exists(select *from ventas.tbl_direccion  where id_direccion=__id__dirproveedor and id_persona=__id__proveedor) then
		if not exists(select *  from compras.tbl_compra 
			where nro_doc_compra=__nro__doc__compra and serie=__serie and id_proveedor=__id__proveedor and id_comprobante=__id__comprobante AND id_estado=1)then 
			select max(id__compra) into _id from COMPRAS.TBL_COMPRA;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO COMPRAS.TBL_COMPRA(
				id__compra,
				nro_doc_compra,
				fec_documento,
				id_dirproveedor,
				id_comprobante,
				id_tranzaccion,
				id_igv,
				anio,
				id_compra,
				id_mes,
				fec_ingsistema,
				imp_venta,
				imp_dcsto,
				porcent_dcsto,
				imp_igv,
				porcent_reintegro,
				imp_reintegro,
				sujeto_percepcion,
				id_sucursalcompra,
				id_estado,
				id_proveedor,
				serie,
				id_tipocambio,
				mercaderia_transito,
				actualizar_precios,
				id_tipocompra,
				paga_flete,
				doc_referencia,
				imp_bruto,
				imp_total,
				imp_exonerado,
				id_operacion,
				imp_percepcion,
				genera_letra,
				reintegro_tributario,
				fec_ingalmacen,
				id_moneda,
				imp_flete,
				imp_factor,
				pesototal,
				imp_afecto,
				actualiza_stock,
				pesovolumen,
				destinarventaconigv,
				id_responsable,
				REFERENCIA_NCR,
				REFMOV_ALMACEN,
				nota__credito,
				id__compra__ref,
				id__sucursal__ref,
				id__concepto,
				nota_credito,
				id_motivonotacredito,
				tipo_cambio,
				nota__debito
			)VALUES(
				_id,
				__nro__doc__compra,
				to_timestamp(__fec__documento,'YYYY-MM-DD HH24:MI:SS.MS'),
				__id__dirproveedor,
				__id__comprobante,
				__id__tranzaccion,
				__id__igv,
				__anio,
				__id_compra,
				__id__mes,
				to_timestamp(__fec__ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
				__imp__venta,
				__imp__dcsto,
				__porcent__dcsto,
				__imp__igv,
				__porcent__reintegro,
				__imp__reintegro,
				__sujeto__percepcion,
				__id__sucursalcompra,
				__id__estado,
				__id__proveedor,
				__serie,
				__id__tipocambio,
				__mercaderia__transito,
				__actualizar__precios,
				__id__tipocompra,
				__paga__flete,
				__doc__referencia,
				__imp__bruto,
				__imp__total,
				__imp__exonerado,
				__id__operacion,
				__imp__percepcion,
				__genera__letra,
				__reintegro__tributario,
				to_timestamp(__fec__ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
				__id__moneda,
				__imp__flete,
				__imp__factor,
				__pesototal,
				__imp__afecto,
				__actualiza__stock,
				__pesovolumen,
				__destinarventaconigv,
				__id__responsable,
				__REFERENCIA__NCR,
				__id__movimiento,
				true,
				__id__compra__ref,
				__id__sucursal__ref,
				__id__concepto,
				true,
				__id_motivonotacredito,
				__imp_tipo_cambio,
				false
			  )returning array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] into res;
			if not found then
				res:=array['504', 'Inconsitencia Inesperada al momento de registrar la compra'];
			--else
				--update almacen.tbl_cabmovalm set codigo_refk=res[1]||res[2]||res[3] || res[4] where id_movimiento in(_id_movimiento);
			end if;
		else	
			res:=array['504', 'el DOCUMENTO DE COMPRA YA SE ENCUENTRA REGISTRADO'];
		end if;
	ELSE
		res:=array['504', 'VERFIQUE QUE ESTE SELECCIONADO CORRECTAMENTE EL PROVEEDOR'];
	end if;	
ELSE
   IF op=2 then
	if exists(select 1 from COMPRAS.TBL_COMPRA where id__compra=__id__compra and id_sucursalcompra = __id__sucursalcompra) then
		UPDATE COMPRAS.TBL_COMPRA SET
		  nro_doc_compra  =   __nro__doc__compra,
		  fec_documento  =   to_timestamp(__fec__documento,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_dirproveedor  =   __id__dirproveedor,
		  id_comprobante  =   __id__comprobante,
		  id_tranzaccion  =   __id__tranzaccion,
		  id_igv  =   __id__igv,
		  fec_ingsistema  =   to_timestamp(__fec__ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
		  imp_venta  =   __imp__venta,
		  imp_dcsto  =   __imp__dcsto,
		  porcent_dcsto  =   __porcent__dcsto,
		  imp_igv  =   __imp__igv,
		  porcent_reintegro  =   __porcent__reintegro,
		  imp_reintegro  =   __imp__reintegro,
		  sujeto_percepcion  =   __sujeto__percepcion,
		  id_estado  =   __id__estado,
		  id_proveedor  =   __id__proveedor,
		  serie  =   __serie,
		  id_tipocambio  =   __id__tipocambio,
		  mercaderia_transito  =   __mercaderia__transito,
		  actualizar_precios  =   __actualizar__precios,
		  id_tipocompra  =   __id__tipocompra,
		  paga_flete  =   __paga__flete,
		  doc_referencia  =   __doc__referencia,
		  imp_bruto  =   __imp__bruto,
		  imp_total  =   __imp__total,
		  imp_exonerado  =   __imp__exonerado,
		  id_operacion  =   __id__operacion,
		  imp_percepcion  =   __imp__percepcion,
		  genera_letra  =   __genera__letra,
		  reintegro_tributario  =   __reintegro__tributario,
		  fec_ingalmacen  =   to_timestamp(__fec__ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_moneda  =   __id__moneda,
		  imp_flete = __imp__flete,
		  imp_factor = __imp__factor,
		  pesototal = __pesototal,
		  imp_afecto = __imp__afecto,
		  actualiza_stock = __actualiza__stock,
		  pesovolumen = __pesovolumen,
		  destinarventaconigv=__destinarventaconigv,
		  id_responsable=__id__responsable,
		  REFERENCIA_NCR=__REFERENCIA__NCR,
		  id__concepto=__id__concepto,
		  nota_credito=true,
		  nota__debito=false,
		  id_motivonotacredito=__id_motivonotacredito,
		  tipo_cambio=__imp_tipo_cambio,
		  id_mes=__id__mes,
		  anio=__anio,
		  id_compra=__id_compra
		WHERE id__compra=__id__compra and id_sucursalcompra = __id__sucursalcompra 
		RETURNING Array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] INTO RES;
		--res:= array['0', _id__compra::text, _id_sucursalcompra::TEXT, _id_mes::TEXT, _anio::TEXT];
	else
		res:= array['504','Verifique que los datos de la compra esten ingresados correctamente'];
	end if;
   END IF;
END IF;
  return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select nota_credito,nota__debito,*from COMPRAS.TBL_COMPRA

CREATE OR REPLACE FUNCTION compras.spiu__nota__debito(
    op integer,
    __nro__doc__compra character,
    __fec__documento text,
    __id__dirproveedor bigint,
    __id__comprobante integer,
    __id__tranzaccion character,
    __id__igv integer,
    __anio integer,
    __id_compra integer,
    __id__mes integer,
    __fec__ingsistema text,
    __imp__venta numeric,
    __imp__dcsto numeric,
    __porcent__dcsto numeric,
    __imp__igv numeric,
    __porcent__reintegro numeric,
    __imp__reintegro numeric,
    __sujeto__percepcion boolean,
    __id__sucursalcompra integer,
    __id__estado integer,
    __id__proveedor character varying,
    __serie character,
    __id__tipocambio integer,
    __mercaderia__transito boolean,
    __actualizar__precios boolean,
    __id__tipocompra integer,
    __paga__flete boolean,
    __doc__referencia character,
    __imp__bruto numeric,
    __imp__total numeric,
    __imp__exonerado numeric,
    __id__operacion integer,
    __imp__percepcion numeric,
    __genera__letra boolean,
    __reintegro__tributario boolean,
    __fec__ingalmacen text,
    __id__moneda integer,
    __imp__flete numeric,
    __imp__factor numeric,
    __id__ordencompra integer,
    __id__sucursalorden integer,
    __pesototal numeric,
    __imp__afecto numeric,
    __actualiza__stock boolean,
    __pesovolumen boolean,
    __destinarventaconigv boolean,
    __id__responsable character varying,
    __referencia__ncr text,
    __id__movimiento text,
    __id__compra bigint,
    __id__compra__ref bigint,
    __id__sucursal__ref integer,
    __nota__debito boolean,
    __id__concepto character,
    __id_motivonotacredito character(2),
    __tipocambio numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res TEXT[];
	_id integer;
BEGIN

IF op=1 then
	if exists(select *from ventas.tbl_direccion  where id_direccion=__id__dirproveedor and id_persona=__id__proveedor) then
		if not exists(select 1  from compras.tbl_compra 
			where nro_doc_compra=__nro__doc__compra and serie=__serie and id_proveedor=__id__proveedor and id_comprobante=__id__comprobante AND id_estado=1)then 
			select max(id__compra) into _id from COMPRAS.TBL_COMPRA;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO COMPRAS.TBL_COMPRA(
				id__compra,
				nro_doc_compra,
				fec_documento,
				id_dirproveedor,
				id_comprobante,
				id_tranzaccion,
				id_igv,
				anio,
				id_compra,
				id_mes,
				fec_ingsistema,
				imp_venta,
				imp_dcsto,
				porcent_dcsto,
				imp_igv,
				porcent_reintegro,
				imp_reintegro,
				sujeto_percepcion,
				id_sucursalcompra,
				id_estado,
				id_proveedor,
				serie,
				id_tipocambio,
				mercaderia_transito,
				actualizar_precios,
				id_tipocompra,
				paga_flete,
				doc_referencia,
				imp_bruto,
				imp_total,
				imp_exonerado,
				id_operacion,
				imp_percepcion,
				genera_letra,
				reintegro_tributario,
				fec_ingalmacen,
				id_moneda,
				imp_flete,
				imp_factor,
				pesototal,
				imp_afecto,
				actualiza_stock,
				pesovolumen,
				destinarventaconigv,
				id_responsable,
				REFERENCIA_NCR,
				REFMOV_ALMACEN,
				nota__credito,
				id__compra__ref,
				id__sucursal__ref,
				id__concepto,
				nota__debito,
				id_motivonotacredito
			)VALUES(
				_id,
				__nro__doc__compra,
				to_timestamp(__fec__documento,'YYYY-MM-DD HH24:MI:SS.MS'),
				__id__dirproveedor,
				__id__comprobante,
				__id__tranzaccion,
				__id__igv,
				__anio,
				__id_compra,
				__id__mes,
				to_timestamp(__fec__ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
				__imp__venta,
				__imp__dcsto,
				__porcent__dcsto,
				__imp__igv,
				__porcent__reintegro,
				__imp__reintegro,
				__sujeto__percepcion,
				__id__sucursalcompra,
				__id__estado,
				__id__proveedor,
				__serie,
				__id__tipocambio,
				__mercaderia__transito,
				__actualizar__precios,
				__id__tipocompra,
				__paga__flete,
				__doc__referencia,
				__imp__bruto,
				__imp__total,
				__imp__exonerado,
				__id__operacion,
				__imp__percepcion,
				__genera__letra,
				__reintegro__tributario,
				to_timestamp(__fec__ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
				__id__moneda,
				__imp__flete,
				__imp__factor,
				__pesototal,
				__imp__afecto,
				__actualiza__stock,
				__pesovolumen,
				__destinarventaconigv,
				__id__responsable,
				__REFERENCIA__NCR,
				__id__movimiento,
				true,
				__id__compra__ref,
				__id__sucursal__ref,
				__id__concepto,
				__nota__debito,
				__id_motivonotacredito
			  )returning array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] into res;
			if not found then
				res:=array['504', 'Inconsitencia Inesperada al momento de registrar la compra'];
			--else
				--update almacen.tbl_cabmovalm set codigo_refk=res[1]||res[2]||res[3] || res[4] where id_movimiento in(_id_movimiento);
			end if;
		else	
			res:=array['504', 'el DOCUMENTO DE COMPRA YA SE ENCUENTRA REGISTRADO'];
		end if;
	ELSE
		res:=array['504', 'VERFIQUE QUE ESTE SELECCIONADO CORRECTAMENTE EL PROVEEDOR'];
	end if;	
ELSE
   IF op=2 then
	if exists(select 1 from COMPRAS.TBL_COMPRA where id__compra=__id__compra and id_sucursalcompra = __id__sucursalcompra) then
		UPDATE COMPRAS.TBL_COMPRA SET
		  nro_doc_compra  =   __nro__doc__compra,
		  fec_documento  =   to_timestamp(__fec__documento,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_dirproveedor  =   __id__dirproveedor,
		  id_comprobante  =   __id__comprobante,
		  id_tranzaccion  =   __id__tranzaccion,
		  id_igv  =   __id__igv,
		  fec_ingsistema  =   to_timestamp(__fec__ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
		  imp_venta  =   __imp__venta,
		  imp_dcsto  =   __imp__dcsto,
		  porcent_dcsto  =   __porcent__dcsto,
		  imp_igv  =   __imp__igv,
		  porcent_reintegro  =   __porcent__reintegro,
		  imp_reintegro  =   __imp__reintegro,
		  sujeto_percepcion  =   __sujeto__percepcion,
		  id_estado  =   __id__estado,
		  id_proveedor  =   __id__proveedor,
		  serie  =   __serie,
		  id_tipocambio  =   __id__tipocambio,
		  mercaderia_transito  =   __mercaderia__transito,
		  actualizar_precios  =   __actualizar__precios,
		  id_tipocompra  =   __id__tipocompra,
		  paga_flete  =   __paga__flete,
		  doc_referencia  =   __doc__referencia,
		  imp_bruto  =   __imp__bruto,
		  imp_total  =   __imp__total,
		  imp_exonerado  =   __imp__exonerado,
		  id_operacion  =   __id__operacion,
		  imp_percepcion  =   __imp__percepcion,
		  genera_letra  =   __genera__letra,
		  reintegro_tributario  =   __reintegro__tributario,
		  fec_ingalmacen  =   to_timestamp(__fec__ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_moneda  =   __id__moneda,
		  imp_flete = __imp__flete,
		  imp_factor = __imp__factor,
		  pesototal = __pesototal,
		  imp_afecto = __imp__afecto,
		  actualiza_stock = __actualiza__stock,
		  pesovolumen = __pesovolumen,
		  destinarventaconigv=__destinarventaconigv,
		  id_responsable=__id__responsable,
		  REFERENCIA_NCR=__REFERENCIA__NCR,
		  id__concepto=__id__concepto,
		  nota_credito=__nota__debito,
		  id_motivonotacredito=__id_motivonotacredito
		WHERE id__compra=__id__compra and id_sucursalcompra = __id__sucursalcompra 
		RETURNING Array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] INTO RES;
		--res:= array['0', _id__compra::text, _id_sucursalcompra::TEXT, _id_mes::TEXT, _anio::TEXT];
	else
		res:= array['504','Verifique que los datos de la compra esten ingresados correctamente'];
	end if;
   END IF;
END IF;
  return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

 select *from ventas.tbl_tratopersona

CREATE OR REPLACE  FUNCTION VENTAS.ISP_CONTACTO(
	op		      INTEGER,
	_id_contacto          CHAR(15)  ,
	_DNI                  CHAR(11) ,
	_APELLIDOS            TEXT  ,
	_NOMBRES              TEXT  ,
	_RAZON_COMERCIAL      TEXT  ,
	_DIRECCION            TEXT  ,
	_ref_direccion        TEXT  ,
	_telefono             VARCHAR(50)  ,
	_celular              VARCHAR(50)  ,
	_rpm                  VARCHAR(50)  ,
	_rpc                  VARCHAR(50)  ,
	_ocupacion            VARCHAR(100)  ,
	_lugar                VARCHAR(100)  ,
	_direcc_trabajo       VARCHAR(200)  ,
	_trabajo_actual       VARCHAR(100)  ,
	_cargo                VARCHAR(50) ,
	_antiguedad           VARCHAR(20)  ,
	_ing_mensual          NUMERIC(20,4)  ,
	_otros_ingresos       NUMERIC(20,4)  ,
	_id_estadocivil       INTEGER   ,
	_id_tipvivienda       INTEGER   ,
	_nomape_conyuge       VARCHAR(100)  ,
	_dni_conyuge          CHAR(11)  ,
	_trabactual_conyuge   VARCHAR(100)  ,
	_antiguedad_conyuge   VARCHAR(20)  ,
	_cargo_conyuge        VARCHAR(40)  ,
	_telefono_conyuge     VARCHAR(30)  ,
	_ingmensual_conyugue  NUMERIC(20,4) ,
	_otrosing_conyugue    NUMERIC(20,4) ,
	_email                VARCHAR(100)  ,
	_fec_nac              TIMESTAMP  ,
	_id_trato             INTEGER  ,
	_id_estado            INTEGER  ,
	_id_sucursal          INTEGER  ,
	_id_usuario          CHAR(5) ,
	_id_empresa	     integer ,
	_id_sector	     integer
)
RETURNS TEXT[] AS $$
DECLARE 
	RES TEXT[];
	CORREL BIGINT;
BEGIN
IF OP=1 THEN
	IF   EXISTS(SELECT 1 FROM ventas.tbl_tipovivienda WHERE id_tipvivienda=_id_tipvivienda) THEN
		IF NOT EXISTS(SELECT *FROM VENTAS.TBL_CONTACTO WHERE TRIM(DNI)=TRIM(_DNI))THEN
			SELECT MAX(TRIM(id_contacto)::BIGINT) INTO CORREL FROM VENTAS.TBL_CONTACTO;
			IF CORREL IS NULL THEN
				CORREL:=1;
			ELSE
				CORREL:=CORREL+1;
			END IF;	
			_ID_CONTACTO:=CORREL::TEXT ;--|| '-' || _ID_SUCURSAL::TEXT || '-' || _ID_EMPRESA::TEXT;
			
		
				INSERT INTO ventas.tbl_contacto(
					id_contacto, 
					dni, 
					apellidos, 
					nombres, 
					razon_comercial, 
					direccion, 
					ref_direccion, 
					telefono, 
					celular, 
					rpm, 
					rpc, 
					ocupacion, 
					lugar, 
					direcc_trabajo, 
					trabajo_actual, 
					cargo, 
					antiguedad, 
					ing_mensual, 
					otros_ingresos, 
					id_estadocivil, 
					id_tipvivienda, 
					nomape_conyuge, 
					dni_conyuge, 
					trabactual_conyuge, 
					antiguedad_conyuge, 
					cargo_conyuge, 
					telefono_conyuge, 
					ingmensual_conyugue, 
					otrosing_conyugue, 
					email, 
					fec_nac, 
					fec_registro, 
					id_trato, 
					id_estado, 
					id_sucursal, 
					id_usuarior, 
					id_usuarioa, 
					date_act,
					id_sector
				   )
				VALUES (		
					_id_contacto, 
					_dni, 
					_apellidos, 
					_nombres, 
					_razon_comercial, 
					_direccion, 
					_ref_direccion, 
					_telefono, 
					_celular, 
					_rpm, 
					_rpc, 
					_ocupacion, 
					_lugar, 
					_direcc_trabajo, 
					_trabajo_actual, 
					_cargo, 
					_antiguedad, 
					_ing_mensual, 
					_otros_ingresos, 
					_id_estadocivil, 
					_id_tipvivienda, 
					_nomape_conyuge, 
					_dni_conyuge, 
					_trabactual_conyuge, 
					_antiguedad_conyuge, 
					_cargo_conyuge, 
					_telefono_conyuge, 
					_ingmensual_conyugue, 
					_otrosing_conyugue, 
					_email, 
					_fec_nac, 
					now(), 
					_id_trato, 
					_id_estado, 
					_id_sucursal, 
					_id_usuario, 
					_id_usuario, 
					now(),
					_id_sector
				) returning array['0',
						id_contacto,
						dni, 
						apellidos::text,
						nombres::text::TEXT,
						telefono::TEXT, 
						celular::TEXT, 
						rpm::TEXT
					] into res;
				if not found then
					res:=array['504','Inconsistencia inesperada verefique los datos esten ingresados correctamente'];
				end if;
		ELSE
			SELECT  ARRAY['0',TRIM(id_contacto),
						TRIM(dni), 
						apellidos::text,
						nombres::text::TEXT,
						telefono::TEXT, 
						celular::TEXT, 
						rpm::TEXT] INTO RES  FROM VENTAS.TBL_CONTACTO WHERE TRIM(DNI)=TRIM(_DNI) LIMIT 1;
		END IF;
	ELSE
		RES:=ARRAY['500','Verefique que el tipo de vivienda se encuentre Registrada'];
	END IF;
	
	
END IF;
if op=2 then
	if exists(select *from ventas.tbl_contacto where id_contacto=_id_contacto)then
		UPDATE ventas.tbl_contacto
		SET 
			dni=_dni, 
			apellidos=_apellidos, 
			nombres=_nombres, 
			razon_comercial=_razon_comercial, 
			direccion=_direccion, 
			ref_direccion=_ref_direccion, 
			telefono=_telefono, 
			celular=_celular, 
			rpm=_rpm, 
			rpc=_rpc, 
			ocupacion=_ocupacion, 
			lugar=_lugar, 
			direcc_trabajo=_direcc_trabajo, 
			trabajo_actual=_trabajo_actual, 
			cargo=_cargo, 
			antiguedad=_antiguedad, 
			ing_mensual=_ing_mensual, 
			otros_ingresos=_otros_ingresos, 
			id_estadocivil=_id_estadocivil, 
			id_tipvivienda=_id_tipvivienda, 
			nomape_conyuge=_nomape_conyuge, 
			dni_conyuge=_dni_conyuge, 
			trabactual_conyuge=_trabactual_conyuge, 
			antiguedad_conyuge=_antiguedad_conyuge, 
			cargo_conyuge=_cargo_conyuge, 
			telefono_conyuge=_telefono_conyuge, 
			ingmensual_conyugue=_ingmensual_conyugue, 
			otrosing_conyugue=_otrosing_conyugue, 
			email=_email, 
			fec_nac=_fec_nac, 
			id_trato=_id_trato, 
			id_estado=_id_estado, 
			id_sucursal=_id_sucursal, 
			id_usuarioa=_id_usuario, 
			date_act=now(), 
			id_sector=_id_sector
		WHERE id_contacto=_id_contacto ;
		res:=array['0',
			_id_contacto,
			_dni, 
			_apellidos::text,
			_nombres::text::TEXT,
			_telefono::TEXT, 
			_celular::TEXT, 
			_rpm::TEXT];
	else
		RES:=ARRAY['504','Verefique el registro este editado correctamente'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';



CREATE OR REPLACE  FUNCTION VENTAS.ISP_PERSONACONTACTO(
	op			integer,
	_id_contacpersona 	character(15) ,
	_id_contacto 		character(15) ,
	_id_persona 		character varying(15),
	_tipo_contacto 		integer,
	_observaciones 		text,
	_id_estado 		integer,
	_garante		boolean
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
	correl bigint;
BEGIN
if op=1 then
	if exists(select *from planillas.tbl_persona where id_persona=_id_persona) then
		if exists(select *from ventas.tbl_contacto where id_contacto=_id_contacto)then
			SELECT max(TRIM(trim(id_contacpersona))::BIGINT) INTO correl FROM VENTAS.tbl_contacpersona;
			if correl is null then
				correl:=1;
			else
				correl:=correl+1;
			end if;
			_id_contacpersona:=correl::TEXT ;--|| '-' || _ID_PERSONA::TEXT || '-' || _ID_CONTACTO::TEXT;
			INSERT INTO ventas.tbl_contacpersona(
				id_contacpersona, 
				id_contacto, 
				id_persona, 
				tipo_contacto, 
				observaciones, 
				id_estado,
				garante
			)
			VALUES (
				correl::text, 
				_id_contacto, 
				_id_persona, 
				_tipo_contacto, 
				_observaciones, 
				_id_estado,
				_garante
			)RETURNING ARRAY['0',id_contacpersona] into res;
			IF NOT FOUND THEN
				RES:=ARRAY['504','Inconsitencia inesesperada al vincular el contacto con el cliente'];
			END IF;
		else
			res:=array['503','Verefique que exista el contacto'];
		end if;				
	else
		res:=array['502','Verefique que exista el contacto'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_contacpersona where id_contacpersona=_id_contacpersona )then
		UPDATE ventas.tbl_contacpersona
		SET 
			id_contacto=_id_contacto,
			id_persona=_id_persona, 
			tipo_contacto=_tipo_contacto, 
			observaciones=_observaciones, 
			id_estado=_id_estado,
			garante=_garante
		 WHERE id_contacpersona=_id_contacpersona ;
		 res:=array['0',_id_contacpersona];
	else
		res:=array['504','Verefique que exista el registro de contacto'];
	end if;
end if;
return res;
END;$$
LANGUAGE 'plpgsql';
select *from ventas.tbl_contacto where id_contacto='1'

select * from VENTAS.FN_CONTACTO_PERSONA(1,NULL,'1','205426',1,'',1,'1')

SELECT * FROM ventas.tbl_contacpersona cp 
inner join planillas.tbl_persona per on per.id_persona=cp.id_persona
inner join ventas.tbl_contacto c on c.id_contacto=cp.id_contacto
where c.id_contacto='1'

CREATE OR REPLACE  FUNCTION VENTAS.FN_CONTACTO_PERSONA(
	op			integer,
	_id_contacpersona 	character(15) ,
	_id_contacto 		character(15) ,
	_id_persona 		character varying(15),
	_tipo_contacto 		integer,
	_observaciones 		text,
	_id_estado 		integer,
	_garante		boolean
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
	correl bigint;
BEGIN
IF NOT EXISTS(
SELECT 1 FROM ventas.tbl_contacpersona cp 
inner join planillas.tbl_persona per on per.id_persona=cp.id_persona
inner join ventas.tbl_contacto c on c.id_contacto=cp.id_contacto
where c.id_contacto=_id_contacto and cp.id_persona=_id_persona
) then

	if exists(select *from planillas.tbl_persona where id_persona=_id_persona) then
		if exists(select *from ventas.tbl_contacto where id_contacto=_id_contacto)then
			SELECT max(TRIM(id_contacpersona)::BIGINT )INTO CORREL FROM VENTAS.tbl_contacpersona;
			if correl is null then
				correl:=1;
			else
				correl:=correl+1;
			end if;
			_id_contacpersona:=CORREL::TEXT ;--|| '-' || _ID_PERSONA::TEXT || '-' || _ID_CONTACTO::TEXT;
			INSERT INTO ventas.tbl_contacpersona(
				id_contacpersona, 
				id_contacto, 
				id_persona, 
				tipo_contacto, 
				observaciones, 
				id_estado,
				garante
			)
			VALUES (
				_id_contacpersona, 
				_id_contacto, 
				_id_persona, 
				_tipo_contacto, 
				_observaciones, 
				_id_estado,
				_garante
			)RETURNING ARRAY['0',id_contacpersona] into res;
			IF NOT FOUND THEN
				RES:=ARRAY['504','Inconsitencia inesesperada al vincular el contacto con el cliente'];
			END IF;
		else
			res:=array['503','Verefique que exista el contacto' || _id_contacto];
		end if;				
	else
		res:=array['502','Verefique que exista el contacto'];
	end if;
else
	select  id_contacpersona into _id_contacpersona from ventas.tbl_contacpersona where id_contacto=_id_contacto and id_persona=_id_persona and id_estado=1;
	if exists(select *from ventas.tbl_contacpersona where id_contacpersona=_id_contacpersona )then
		UPDATE ventas.tbl_contacpersona
		SET 
			id_contacto=_id_contacto,
			id_persona=_id_persona, 
			tipo_contacto=_tipo_contacto, 
			observaciones=_observaciones, 
			id_estado=_id_estado,
			garante=_garante
		 WHERE id_contacpersona=_id_contacpersona ;
		 res:=array['0',_id_contacpersona];
	else
		res:=array['504','Verefique que exista el registro de contacto' || _id_contacto];
	end if;
end if; 
return res;
END;$$
LANGUAGE 'plpgsql';

select *from common.tbl_sucursal

CREATE OR REPLACE FUNCTION common.spiu_sucursal(
    op integer,
    codigo character varying,
    _nombre character varying,
    _email character varying,
    _observacion character varying,
    _direccion character varying,
    _id_empresa integer,
    _id_estado integer,
    _id__cliente character varying,
    _id__direccion bigint,
    _telefono character varying,
    _celular character varying,
    _id_ubigeo varchar(8),
    _codigo_establecimiento varchar(50),
    _init_correlativo_resumen integer
    )
  RETURNS text[] AS
$BODY$
declare
   correl   integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_sucursal where nombre = _nombre)) then
		SELECT MAX(id_sucursal) INTO correl FROM common.tbl_sucursal;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into common.tbl_sucursal (
			id_sucursal,
			nombre,
			email,
			observacion,
			direccion,
			id_empresa,
			id_estado,
			id__direccion,
			id__cliente,
			telefono,
			celular,
			id_ubigeo,
			codigo_establecimiento,
			init_correlativo_resumen
			)
		values(
			correl, 
			_nombre,
			_email,
			_observacion,
			_direccion,
			_id_empresa,
			_id_estado ,
			_id__direccion,
			_id__cliente,
			_telefono,
			_celular,
			_id_ubigeo,
			_codigo_establecimiento,
			_init_correlativo_resumen
		) RETURNING array['0', tbl_sucursal.id_sucursal::text] INTO res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		res:=array['1'];
	end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_sucursal where id_sucursal = codigo::integer)) then
		update common.tbl_sucursal set 
			nombre = _nombre, 
			email = _email,
			observacion = _observacion,
			direccion = _direccion,
			id_empresa = _id_empresa,
			id_estado = _id_estado,
			id__direccion=_id__direccion,
			id__cliente=_id__cliente,
			telefono=_telefono,
			celular=_celular,
			id_ubigeo=_id_ubigeo,
			codigo_establecimiento=_codigo_establecimiento,
			init_correlativo_resumen=_init_correlativo_resumen
		where id_sucursal = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION planillas.spiu_persona(
	op integer,
	_id_persona character varying,
	_id_estadocivil integer,
	_doc_persona character varying,
	_nombre_razon character varying,
	_razon_comercial character varying,
	_sexo character,
	_email character varying,
	_paginaweb text,
	_fecha_nac text,
	_tipo_persona boolean,
	_cliente_proveedor boolean,
	_deuda_confidencial boolean,
	_no_apto_credito boolean,
	_concientizado boolean,
	_copropietario boolean,
	_observaciones text,
	_id_estado integer,
	_id_vendtitular character,
	_id_vendsuplente character,
	_id_cobrador character,
	_imp_minimoventa numeric,
	_percep_cliente boolean,
	_agente_perceptor boolean,
	_id_coopropietario character varying,
	_id_tipdocidentidad integer,
	_porcent_percepcion numeric,
	_id_persona_ref varchar(15),
	_id_direccion_ref bigint,
	_facturar_a_clienteref boolean ,
        _proveedor boolean,
	_gestiona_lineacredito boolean
)
    RETURNS text[]
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

DECLARE 
	RES TEXT[];
	correl integer;
BEGIN
	IF OP=1 THEN
		if not exists(select * from PLANILLAS.TBL_PERSONA where doc_persona = _doc_persona and cliente_proveedor = _cliente_proveedor) then
			 
				select  max(ID_PERSONA::numeric) into correl from PLANILLAS.TBL_PERSONA WHERE  ISNUMERIC(ID_PERSONA) and  length(ID_PERSONA)<=8 ;-- where cliente_proveedor=FALSE;
				 
				if correl is null then
					_id_persona='1';
				else
					correl:=correl+1;
					_id_persona:=correl::text;
				end if;
				if (_id_tipdocidentidad!=2 and (length(_doc_persona)=8 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
				--select  *from planillas.tbl_tipdocidentidad
			insert into PLANILLAS.TBL_PERSONA(
				  id_persona ,
				  id_estadocivil ,
				  doc_persona ,
				  nombre_razon,
				  razon_comercial ,
				  sexo ,
				  email,
				  paginaweb ,
				  fecha_nac ,
				  tipo_persona ,
				  cliente_proveedor ,
				  deuda_confidencial,
				  no_apto_credito ,
				  concientizado ,
				  copropietario ,
				  observaciones ,
				  id_estado,
				  ID_VENDTITULAR,
				  ID_VENDSUPLENTE,
				  ID_COBRADOR,
				  IMP_MINIMOVENTA,
				  PERCEP_CLIENTE,
				  AGENTE_PERCEPTOR ,
				  id_tipdocidentidad,
				  PORCENT_PERCEPCION,
				  id_persona_ref,
				  id_direccion_ref ,
				  facturar_a_clienteref,
				  proveedor,
				  gestiona_lineacredito
				)
				values(
				  _id_persona ,
				  _id_estadocivil ,
				  _doc_persona ,
				  _nombre_razon,
				  _razon_comercial ,
				  _sexo ,
				  _email,
				  _paginaweb ,
				  _fecha_nac::date ,
				  _tipo_persona ,
				  _cliente_proveedor ,
				  _deuda_confidencial,
				  _no_apto_credito ,
				  _concientizado ,
				  _copropietario ,
				  _observaciones ,
				  _id_estado,
				  _ID_VENDTITULAR,
				  _ID_VENDSUPLENTE,
				  _ID_COBRADOR,
				  _IMP_MINIMOVENTA,
				  _PERCEP_CLIENTE,
				  _AGENTE_PERCEPTOR,
				  _id_tipdocidentidad,
				  _porcent_percepcion,
				  _id_persona_ref,
				  _id_direccion_ref ,
				  _facturar_a_clienteref,
				  _proveedor,
				  _gestiona_lineacredito
				)returning array['0',TBL_PERSONA.id_persona::text,doc_persona,nombre_razon]into res;
		else
			if _cliente_proveedor=true then
				res:=array['504','El Cliente con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			else
				res:=array['504','El Proveedor con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			end if;
			
		end if;
		
	END IF;
	IF OP=2 THEN
		if exists(select * from PLANILLAS.TBL_PERSONA where id_persona=_id_persona) then
                         if (_id_tipdocidentidad!=2 and (length(_doc_persona)=8 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
			update PLANILLAS.TBL_PERSONA set 
					  id_estadocivil =_id_estadocivil ,
					  doc_persona = _doc_persona ,
					  nombre_razon= _nombre_razon,
					  razon_comercial = _razon_comercial,
					  sexo = _sexo,
					  email = _email,
					  paginaweb = _paginaweb,
					  fecha_nac = _fecha_nac::Date,
					  tipo_persona = _tipo_persona,
					  cliente_proveedor = _cliente_proveedor,
					  deuda_confidencial = _deuda_confidencial,
					  no_apto_credito = _no_apto_credito,
					  concientizado = _concientizado,
					  copropietario = _copropietario,
					  observaciones = _observaciones,
					  id_estado = _id_estado,
					  ID_VENDTITULAR=_ID_VENDTITULAR,
					  ID_VENDSUPLENTE=_ID_VENDSUPLENTE,
					  ID_COBRADOR=_ID_COBRADOR,
					  IMP_MINIMOVENTA=_IMP_MINIMOVENTA,
					  PERCEP_CLIENTE=_PERCEP_CLIENTE,
					  AGENTE_PERCEPTOR=_AGENTE_PERCEPTOR,
					  id_tipdocidentidad=_id_tipdocidentidad,
					  PORCENT_PERCEPCION=_PORCENT_PERCEPCION,
					  id_persona_ref=_id_persona_ref,
					  id_direccion_ref=_id_direccion_ref ,
					  facturar_a_clienteref =_facturar_a_clienteref ,
					  gestiona_lineacredito=_gestiona_lineacredito
					where id_persona=_id_persona;
			res:=array['0',_id_persona::text,_doc_persona,_nombre_razon];	
		end if;
	end if;
	return res;
END;

$BODY$;




CREATE OR REPLACE FUNCTION planillas.spiu_cliente(
	op integer,
	_id_persona character varying,
	_id_estadocivil integer,
	_doc_persona character varying,
	_nombre_razon character varying,
	_razon_comercial character varying,
	_sexo character,
	_email character varying,
	_paginaweb text,
	_fecha_nac text,
	_tipo_persona boolean,
	_cliente_proveedor boolean,
	_deuda_confidencial boolean,
	_no_apto_credito boolean,
	_concientizado boolean,
	_copropietario boolean,
	_observaciones text,
	_id_estado integer,
	_id_vendtitular character,
	_id_vendsuplente character,
	_id_cobrador character,
	_imp_minimoventa numeric,
	_percep_cliente boolean,
	_agente_perceptor boolean,
	_id_coopropietario character varying,
	_id_tipdocidentidad integer,
	_porcent_percepcion numeric,
	_id_persona_ref varchar(15),
	_id_direccion_ref bigint,
	_facturar_a_clienteref boolean ,
	_gestiona_lineacredito boolean
)
    RETURNS text[]
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

DECLARE 
	RES TEXT[];
	correl integer;
BEGIN
	IF OP=1 THEN
		if not exists(select * from PLANILLAS.TBL_PERSONA where doc_persona = _doc_persona and cliente_proveedor = _cliente_proveedor) then
			 
				select  max(ID_PERSONA::numeric) into correl from PLANILLAS.TBL_PERSONA WHERE  ISNUMERIC(ID_PERSONA) and  length(ID_PERSONA)<=8 ;-- where cliente_proveedor=FALSE;
				 
				if correl is null then
					_id_persona='1';
				else
					correl:=correl+1;
					_id_persona:=correl::text;
				end if;
				if ((_id_tipdocidentidad NOT IN(2,7) )and (length(_doc_persona)=8 ) ) then
					res:=array['504','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
				--select  *from planillas.tbl_tipdocidentidad
			insert into PLANILLAS.TBL_PERSONA(
				  id_persona ,
				  id_estadocivil ,
				  doc_persona ,
				  nombre_razon,
				  razon_comercial ,
				  sexo ,
				  email,
				  paginaweb ,
				  fecha_nac ,
				  tipo_persona ,
				  cliente_proveedor ,
				  deuda_confidencial,
				  no_apto_credito ,
				  concientizado ,
				  copropietario ,
				  observaciones ,
				  id_estado,
				  ID_VENDTITULAR,
				  ID_VENDSUPLENTE,
				  ID_COBRADOR,
				  IMP_MINIMOVENTA,
				  PERCEP_CLIENTE,
				  AGENTE_PERCEPTOR ,
				  id_tipdocidentidad,
				  PORCENT_PERCEPCION,
				  id_persona_ref,
				  id_direccion_ref ,
				  facturar_a_clienteref,				 
				  gestiona_lineacredito
				)
				values(
				  _id_persona ,
				  _id_estadocivil ,
				  _doc_persona ,
				  _nombre_razon,
				  _razon_comercial ,
				  _sexo ,
				  _email,
				  _paginaweb ,
				  _fecha_nac::date ,
				  _tipo_persona ,
				  _cliente_proveedor ,
				  _deuda_confidencial,
				  _no_apto_credito ,
				  _concientizado ,
				  _copropietario ,
				  _observaciones ,
				  _id_estado,
				  _ID_VENDTITULAR,
				  _ID_VENDSUPLENTE,
				  _ID_COBRADOR,
				  _IMP_MINIMOVENTA,
				  _PERCEP_CLIENTE,
				  _AGENTE_PERCEPTOR,
				  _id_tipdocidentidad,
				  _porcent_percepcion,
				  _id_persona_ref,
				  _id_direccion_ref ,
				  _facturar_a_clienteref,				 
				  _gestiona_lineacredito
				)returning array['0',TBL_PERSONA.id_persona::text,doc_persona,nombre_razon]into res;
		else
			if _cliente_proveedor=true then
				res:=array['504','El Cliente con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			else
				res:=array['504','El Proveedor con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			end if;
			
		end if;
		
	END IF;
	IF OP=2 THEN
		if exists(select * from PLANILLAS.TBL_PERSONA where id_persona=_id_persona) then
                        if ((_id_tipdocidentidad NOT IN(2,7) )and (length(_doc_persona)=8 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
			update PLANILLAS.TBL_PERSONA set 
					  id_estadocivil =_id_estadocivil ,
					  doc_persona = _doc_persona ,
					  nombre_razon= _nombre_razon,
					  razon_comercial = _razon_comercial,
					  sexo = _sexo,
					  email = _email,
					  paginaweb = _paginaweb,
					  fecha_nac = _fecha_nac::Date,
					  tipo_persona = _tipo_persona,
					  deuda_confidencial = _deuda_confidencial,
					  no_apto_credito = _no_apto_credito,
					  concientizado = _concientizado,
					  copropietario = _copropietario,
					  observaciones = _observaciones,
					  id_estado = _id_estado,
					  ID_VENDTITULAR=_ID_VENDTITULAR,
					  ID_VENDSUPLENTE=_ID_VENDSUPLENTE,
					  ID_COBRADOR=_ID_COBRADOR,
					  IMP_MINIMOVENTA=_IMP_MINIMOVENTA,
					  PERCEP_CLIENTE=_PERCEP_CLIENTE,
					  AGENTE_PERCEPTOR=_AGENTE_PERCEPTOR,
					  id_tipdocidentidad=_id_tipdocidentidad,
					  PORCENT_PERCEPCION=_PORCENT_PERCEPCION,
					  id_persona_ref=_id_persona_ref,
					  id_direccion_ref=_id_direccion_ref ,
					  facturar_a_clienteref =_facturar_a_clienteref ,
					  cliente_proveedor=true,
					  gestiona_lineacredito=_gestiona_lineacredito
					where id_persona=_id_persona;
			res:=array['0',_id_persona::text,_doc_persona,_nombre_razon];	
		end if;
	end if;
	return res;
END;

$BODY$;



CREATE OR REPLACE FUNCTION planillas.spiu_proveedor(
	op integer,
	_id_persona character varying,
	_id_estadocivil integer,
	_doc_persona character varying,
	_nombre_razon character varying,
	_razon_comercial character varying,
	_sexo character,
	_email character varying,
	_paginaweb text,
	_fecha_nac text,
	_tipo_persona boolean,
	_deuda_confidencial boolean,
	_no_apto_credito boolean,
	_concientizado boolean,
	_copropietario boolean,
	_observaciones text,
	_id_estado integer,
	_id_vendtitular character,
	_id_vendsuplente character,
	_id_cobrador character,
	_imp_minimoventa numeric,
	_percep_cliente boolean,
	_agente_perceptor boolean,
	_id_coopropietario character varying,
	_id_tipdocidentidad integer,
	_porcent_percepcion numeric,
	_id_persona_ref varchar(15),
	_id_direccion_ref bigint,
	_facturar_a_clienteref boolean 
)
    RETURNS text[]
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

DECLARE 
	RES TEXT[];
	correl integer;
BEGIN
	IF OP=1 THEN
		if not exists(select * from PLANILLAS.TBL_PERSONA where doc_persona = _doc_persona) then
			 
				select  max(ID_PERSONA::numeric) into correl from PLANILLAS.TBL_PERSONA WHERE  ISNUMERIC(ID_PERSONA) and  length(ID_PERSONA)<=8 ;-- where cliente_proveedor=FALSE;
				 
				if correl is null then
					_id_persona='1';
				else
					correl:=correl+1;
					_id_persona:=correl::text;
				end if;
				if (_id_tipdocidentidad!=2 and (length(_doc_persona)=8 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
				--select  *from planillas.tbl_tipdocidentidad
			insert into PLANILLAS.TBL_PERSONA(
				  id_persona ,
				  id_estadocivil ,
				  doc_persona ,
				  nombre_razon,
				  razon_comercial ,
				  sexo ,
				  email,
				  paginaweb ,
				  fecha_nac ,
				  tipo_persona ,
				 
				  deuda_confidencial,
				  no_apto_credito ,
				  concientizado ,
				  copropietario ,
				  observaciones ,
				  id_estado,
				  ID_VENDTITULAR,
				  ID_VENDSUPLENTE,
				  ID_COBRADOR,
				  IMP_MINIMOVENTA,
				  PERCEP_CLIENTE,
				  AGENTE_PERCEPTOR ,
				  id_tipdocidentidad,
				  PORCENT_PERCEPCION,
				  id_persona_ref,
				  id_direccion_ref ,
				  facturar_a_clienteref,
				  proveedor
				  
				)
				values(
				  _id_persona ,
				  _id_estadocivil ,
				  _doc_persona ,
				  _nombre_razon,
				  _razon_comercial ,
				  _sexo ,
				  _email,
				  _paginaweb ,
				  _fecha_nac::date ,
				  _tipo_persona ,
				  _deuda_confidencial,
				  _no_apto_credito ,
				  _concientizado ,
				  _copropietario ,
				  _observaciones ,
				  _id_estado,
				  _ID_VENDTITULAR,
				  _ID_VENDSUPLENTE,
				  _ID_COBRADOR,
				  _IMP_MINIMOVENTA,
				  _PERCEP_CLIENTE,
				  _AGENTE_PERCEPTOR,
				  _id_tipdocidentidad,
				  _porcent_percepcion,
				  _id_persona_ref,
				  _id_direccion_ref ,
				  _facturar_a_clienteref,
				  true
				 
				)returning array['0',TBL_PERSONA.id_persona::text,doc_persona,nombre_razon]into res;
		else
			if _cliente_proveedor=true then
				res:=array['504','El Cliente con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			else
				res:=array['504','El Proveedor con Documento de Identidad << ' || _doc_persona || ' >> ya esta registrado ..!! '];
			end if;
			
		end if;
		
	END IF;
	IF OP=2 THEN
		if exists(select * from PLANILLAS.TBL_PERSONA where id_persona=_id_persona) then
                         if (_id_tipdocidentidad!=2 and (length(_doc_persona)=8 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo DNI'];
					return res;
				end if;
				if (_id_tipdocidentidad!=4 and (length(_doc_persona)=11 ) ) then
					res:=array['505','Verifique la identificacion del cliente para el tipo RUC'];
					return res;
				end if;
			update PLANILLAS.TBL_PERSONA set 
					  id_estadocivil =_id_estadocivil ,
					  doc_persona = _doc_persona ,
					  nombre_razon= _nombre_razon,
					  razon_comercial = _razon_comercial,
					  sexo = _sexo,
					  email = _email,
					  paginaweb = _paginaweb,
					  fecha_nac = _fecha_nac::Date,
					  tipo_persona = _tipo_persona,					 
					  deuda_confidencial = _deuda_confidencial,
					  no_apto_credito = _no_apto_credito,
					  concientizado = _concientizado,
					  copropietario = _copropietario,
					  observaciones = _observaciones,
					  id_estado = _id_estado,
					  ID_VENDTITULAR=_ID_VENDTITULAR,
					  ID_VENDSUPLENTE=_ID_VENDSUPLENTE,
					  ID_COBRADOR=_ID_COBRADOR,
					  IMP_MINIMOVENTA=_IMP_MINIMOVENTA,
					  PERCEP_CLIENTE=_PERCEP_CLIENTE,
					  AGENTE_PERCEPTOR=_AGENTE_PERCEPTOR,
					  id_tipdocidentidad=_id_tipdocidentidad,
					  PORCENT_PERCEPCION=_PORCENT_PERCEPCION,
					  id_persona_ref=_id_persona_ref,
					  id_direccion_ref=_id_direccion_ref ,
					  facturar_a_clienteref =_facturar_a_clienteref ,
					  proveedor=true
					where id_persona=_id_persona;
			res:=array['0',_id_persona::text,_doc_persona,_nombre_razon];	
		end if;
	end if;
	return res;
END;

$BODY$;




CREATE OR REPLACE FUNCTION common.spiu_moneda(
    op integer,
    codigo character varying,
    _descripcion_larga character varying,
    _descripcion_corta character varying,
    _id_estado integer,
    _predeterminado boolean
    )
  RETURNS text[] AS
$BODY$
declare
   correl   integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_moneda where descripcion_larga = _descripcion_larga)) then
		SELECT MAX(id_moneda) INTO correl FROM common.tbl_moneda;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into common.tbl_moneda (
			id_moneda,
			descripcion_larga, 
			id_estado,
			simbolo,
			predeterminado
			)
		values(
			correl, 
			_descripcion_larga, 
			_id_estado, 
			_descripcion_corta,
			_predeterminado
		) RETURNING array['0', tbl_moneda.id_moneda::text] INTO res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		res:=array['1'];
	end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_moneda where id_moneda = codigo::integer)) then
		update common.tbl_moneda set 
		descripcion_larga = _descripcion_larga , 
		id_estado = _id_estado, 
		simbolo = _descripcion_corta ,
		predeterminado=_predeterminado
		where id_moneda = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION compras.spiu_compras(
    op integer,
    _nro_doc_compra character,
    _fec_documento text,
    _id_dirproveedor bigint,
    _id_comprobante integer,
    _id_tranzaccion character,
    _id_igv integer,
    _anio integer,
    _id_compra integer,
    _id_mes integer,
    _fec_ingsistema text,
    _imp_venta numeric,
    _imp_dcsto numeric,
    _porcent_dcsto numeric,
    _imp_igv numeric,
    _porcent_reintegro numeric,
    _imp_reintegro numeric,
    _sujeto_percepcion boolean,
    _id_sucursalcompra integer,
    _id_estado integer,
    _id_proveedor character varying,
    _serie character,
    _id_tipocambio integer,
    _mercaderia_transito boolean,
    _actualizar_precios boolean,
    _id_tipocompra integer,
    _paga_flete boolean,
    _doc_referencia character,
    _imp_bruto numeric,
    _imp_total numeric,
    _imp_exonerado numeric,
    _id_operacion integer,
    _imp_percepcion numeric,
    _genera_letra boolean,
    _reintegro_tributario boolean,
    _fec_ingalmacen text,
    _id_moneda integer,
    _imp_flete numeric,
    _imp_factor numeric,
    _id_ordencompra integer,
    _id_sucursalorden integer,
    _pesototal numeric,
    _imp_afecto numeric,
    _actualiza_stock boolean,
    _pesovolumen boolean,
    _destinarventaconigv boolean,
    _id_responsable character varying,
    _referencia_ncr text,
    _id_movimiento text,
    _id__compra bigint,
    _tipo_cambio numeric,
    _aplica_dsctototal boolean,
    _referencia_guia text,
    _dias_credito integer,
    _imp_isc numeric(20,4)
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res TEXT[];
	_id integer;
BEGIN

IF op=1 then
	if exists(select *from ventas.tbl_direccion  where id_direccion=_id_dirproveedor and id_persona=_id_proveedor) then
		if not exists(select 1  from compras.tbl_compra 
			where nro_doc_compra=_nro_doc_compra and serie=_serie and id_proveedor=_id_proveedor and id_comprobante=_id_comprobante AND id_estado=1)then 
			select max(id__compra) into _id from COMPRAS.TBL_COMPRA;
			if _id is null then
				_id:=1;
			else
				_id:=_id+1;
			end if;
			INSERT INTO COMPRAS.TBL_COMPRA(
				id__compra,
				nro_doc_compra,
				fec_documento,
				id_dirproveedor,
				id_comprobante,
				id_tranzaccion,
				id_igv,
				anio,
				id_compra,
				id_mes,
				fec_ingsistema,
				imp_venta,
				imp_dcsto,
				porcent_dcsto,
				imp_igv,
				porcent_reintegro,
				imp_reintegro,
				sujeto_percepcion,
				id_sucursalcompra,
				id_estado,
				id_proveedor,
				serie,
				id_tipocambio,
				mercaderia_transito,
				actualizar_precios,
				id_tipocompra,
				paga_flete,
				doc_referencia,
				imp_bruto,
				imp_total,
				imp_exonerado,
				id_operacion,
				imp_percepcion,
				genera_letra,
				reintegro_tributario,
				fec_ingalmacen,
				id_moneda,
				imp_flete,
				imp_factor,
				id_orden,
				id_sucursalorden,
				pesototal,
				imp_afecto,
				actualiza_stock,
				pesovolumen,
				destinarventaconigv,
				id_responsable,
				REFERENCIA_NCR,
				REFMOV_ALMACEN,
				tipo_cambio,
				aplica_dsctototal,
				referencia_guia,
				dias_credito,
				imp_isc
			)VALUES(
				_id,
				_nro_doc_compra,
				to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
				_id_dirproveedor,
				_id_comprobante,
				_id_tranzaccion,
				_id_igv,
				_anio,
				_id_compra,
				_id_mes,
				to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
				_imp_venta,
				_imp_dcsto,
				_porcent_dcsto,
				_imp_igv,
				_porcent_reintegro,
				_imp_reintegro,
				_sujeto_percepcion,
				_id_sucursalcompra,
				_id_estado,
				_id_proveedor,
				_serie,
				_id_tipocambio,
				_mercaderia_transito,
				_actualizar_precios,
				_id_tipocompra,
				_paga_flete,
				_doc_referencia,
				_imp_bruto,
				_imp_total,
				_imp_exonerado,
				_id_operacion,
				_imp_percepcion,
				_genera_letra,
				_reintegro_tributario,
				to_timestamp(_fec_ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
				_id_moneda,
				_imp_flete,
				_imp_factor,
				case when _id_ordencompra=0 then null else _id_ordencompra end,
				case when _id_sucursalorden=0 then null else  _id_sucursalorden end,
				_pesototal,
				_imp_afecto,
				_actualiza_stock,
				_pesovolumen,
				_destinarventaconigv,
				_id_responsable,
				_REFERENCIA_NCR,
				_id_movimiento,
				_tipo_cambio,
				_aplica_dsctototal,
				_referencia_guia,
				_dias_credito,
				_imp_isc
			  )returning array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] into res;
			if not found then
				res:=array['504', 'Inconsitencia Inesperada al momento de registrar la compra'];
			--else
				--update almacen.tbl_cabmovalm set codigo_refk=res[1]||res[2]||res[3] || res[4] where id_movimiento in(_id_movimiento);
			end if;
		else	
			res:=array['504', 'el DOCUMENTO DE COMPRA YA SE ENCUENTRA REGISTRADO'];
		end if;
	ELSE
		res:=array['504', 'VERFIQUE QUE ESTE SELECCIONADO CORRECTAMENTE EL PROVEEDOR'];
	end if;	
ELSE
   IF op=2 then
	if exists(select * from COMPRAS.TBL_COMPRA where id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra) then
		UPDATE COMPRAS.TBL_COMPRA SET
		  nro_doc_compra  =   _nro_doc_compra,
		  fec_documento  =   to_timestamp(_fec_documento,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_dirproveedor  =   _id_dirproveedor,
		  id_comprobante  =   _id_comprobante,
		  id_tranzaccion  =   _id_tranzaccion,
		  id_igv  =   _id_igv,
		  fec_ingsistema  =   to_timestamp(_fec_ingsistema,'YYYY-MM-DD HH24:MI:SS.MS'),
		  imp_venta  =   _imp_venta,
		  imp_dcsto  =   _imp_dcsto,
		  porcent_dcsto  =   _porcent_dcsto,
		  imp_igv  =   _imp_igv,
		  porcent_reintegro  =   _porcent_reintegro,
		  imp_reintegro  =   _imp_reintegro,
		  sujeto_percepcion  =   _sujeto_percepcion,
		  id_estado  =   _id_estado,
		  id_proveedor  =   _id_proveedor,
		  serie  =   _serie,
		  id_tipocambio  =   _id_tipocambio,
		  mercaderia_transito  =   _mercaderia_transito,
		  actualizar_precios  =   _actualizar_precios,
		  id_tipocompra  =   _id_tipocompra,
		  paga_flete  =   _paga_flete,
		  doc_referencia  =   _doc_referencia,
		  imp_bruto  =   _imp_bruto,
		  imp_total  =   _imp_total,
		  imp_exonerado  =   _imp_exonerado,
		  id_operacion  =   _id_operacion,
		  imp_percepcion  =   _imp_percepcion,
		  genera_letra  =   _genera_letra,
		  reintegro_tributario  =   _reintegro_tributario,
		  fec_ingalmacen  =   to_timestamp(_fec_ingalmacen,'YYYY-MM-DD HH24:MI:SS.MS'),
		  id_moneda  =   _id_moneda,
		  imp_flete = _imp_flete,
		  imp_factor = _imp_factor,
		  id_orden = case when _id_ordencompra=0 then null else _id_ordencompra end,
		  id_sucursalorden =case when _id_sucursalorden=0 then null else _id_sucursalorden end,
		  pesototal = _pesototal,
		  imp_afecto = _imp_afecto,
		  actualiza_stock = _actualiza_stock,
		  pesovolumen = _pesovolumen,
		  destinarventaconigv=_destinarventaconigv,
		  id_responsable=_id_responsable,
		  REFERENCIA_NCR=_REFERENCIA_NCR,
		  REFMOV_ALMACEN=_id_movimiento,
		  id_mes=_id_mes,
		  tipo_cambio=_tipo_cambio,
		  aplica_dsctototal=_aplica_dsctototal,
		  referencia_guia=_referencia_guia,
		  dias_credito=_dias_credito,
		  imp_isc=_imp_isc,
	          anio=_anio
		WHERE id__compra=_id__compra and id_sucursalcompra = _id_sucursalcompra 
		RETURNING Array['0', id__compra::text, id_sucursalcompra::TEXT, id_mes::TEXT, anio::TEXT,id_compra::text] INTO RES;
		--res:= array['0', _id__compra::text, _id_sucursalcompra::TEXT, _id_mes::TEXT, _anio::TEXT];
	else
		res:= array['504','Verifique que los datos de la compra esten ingresados correctamente'];
	end if;
   END IF;
END IF;
  return res;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;



CREATE OR REPLACE FUNCTION seguridad.usp_asignatoolbar(
    _idusuario character,
    _iditem integer,
    _toolbar boolean)
  RETURNS text AS
$BODY$
 declare
	res text;
 begin
	 if (exists (select *from seguridad.tbl_permiso where id_usuario=_idusuario and item=_iditem )) then
		 update seguridad.tbl_permiso set toolbar =_toolbar where id_usuario=_idusuario and item=_iditem;
		 res:='0';
	else
		res:='-10';
	 end if;
return res;
 end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from ventas.fn_conmunicacionbaja('29/03/2018');


CREATE OR REPLACE FUNCTION ventas.fn_conmunicacionbaja(IN _fecha text)
  RETURNS TABLE(
	id integer, 
	item integer, 
	tipodocumento character, 
	serie character, 
	numero character, 
	motivo text, 
	fecha timestamp without time zone, 
	fechacomunicacion character varying) AS
$BODY$
declare
	dat record;
	id integer;
begin
	CREATE TEMPORARY TABLE temp_anulados(
		_id integer,
		_item integer,
		_tipodocumento char(2),
		_serie char(4),
		_numero char(7),
		_motivo text,
		_fecha timestamp ,
		_FechaComunicacion varchar(100)
	)ON COMMIT DROP;

for dat in select 1 as Id,cp.codigosunat,cp.codigosunat, case when cp.codigosunat='01' then 'F' ELSE 'B' end || right(f.serie_facturacion,3) as Serie,
f.numdoc_facturacion as numero,F.MOTIVO_ANULACION as motivo,f.fecha_venta as fecha 
from ventas.tbl_facturacion f   
inner join common.tbl_comprobante cp on f.id_comprobante=cp.id_comprobante 
where f.id_estado=7 and f.fecha_venta::date=_fecha::date and f.id_comprobante=3 AND F.NUMDOC_FACTURACION<>'0000076'
union
select 
	2 as Id,
	cpn.codigosunat,
	cpn.codigosunat, 
	case when x.id_comprobante=3 then 'F' ELSE 'B' end || right(fn.serie_facturacion,3) as Serie,
	fn.numdoc_facturacion as numero,
	Fn.MOTIVO_ANULACION as motivo,
	fn.fecha_venta as fecha 
from ventas.tbl_facturacion fn
inner join common.tbl_comprobante cpn on fn.id_comprobante=cpn.id_comprobante 
inner join (
	select 
		fac.id_sucursal,
		fac.id_facturacion,
		fac.id_comprobante
		from ventas.tbl_facturacion fac 
		where fac.id_comprobante=3
	) x on x.id_facturacion=fn.id_facturacionref and x.id_sucursal=fn.id_sucursalref
where fn.id_estado<>1 and   fn.fecha_venta::date=_fecha::date and fn.nota_credito is true

 loop
	select max(_item) into id from temp_anulados;
	if id is null then
		id:=1;
	else
		id:=id+1;
	end if;
	insert into temp_anulados(_id,_item,_tipodocumento,_serie,_numero,_motivo,_fecha,_FechaComunicacion)
	values(1,id,dat.codigosunat,dat.serie,dat.numero,dat.motivo,dat.fecha,now()::varchar(100));
end loop;
return query select *from temp_anulados order by _item asc;

end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

 
CREATE OR REPLACE FUNCTION planillas.isp_programar_turno(
    op integer,
    _id_turno integer,
    _item integer,
    _fecha text,
    _id_usuarior character,
    _id_estado integer,
    _id_colaborador character varying,
    _observacion text,
    _asistio boolean,
    _turno_cerrado boolean,
    _id_sucursal integer,
    _id_isla integer,
    _id_caja integer)
  RETURNS text AS
$BODY$
declare
	correll integer;
	res text[];
begin
if op=1 then
	if not exists (select *from PLANILLAS.TBL_TURNOCOLABORADOR 
		where id_turno=_id_turno  and id_colaborador=_id_colaborador and fecha=cast(_fecha as date) and id_estado=1)then
		select max(item) into correll from PLANILLAS.TBL_TURNOCOLABORADOR where id_turno=_id_turno  and id_colaborador=_id_colaborador and fecha=cast(_fecha as date);
		if correll is null then
			correll:=1;
		else
			correll:=correll+1;
		end if;
		insert into  PLANILLAS.TBL_TURNOCOLABORADOR(
				id_turno,
				item ,
				fecha,
				fecha_registro,
				id_usuarior  ,
				id_estado    ,
				id_colaborador,
				observacion   ,
				asistio       ,
				turno_cerrado ,
				id_sucursal   ,
				id_isla  ,
				id_caja
			)values(
				_id_turno,
				correll ,
				cast(_fecha as date),
				now(),
				_id_usuarior  ,
				_id_estado    ,
				_id_colaborador,
				_observacion   ,
				_asistio       ,
				_turno_cerrado ,
				_id_sucursal   ,
				case when _id_isla =0 then null else _id_isla end,
				_id_caja
			)returning array['0',id_turno::text,item::text,id_colaborador::text,fecha::text] into res;

		--if res[0]='0' then
			if exists(select *from GRIFO.TBL_LIQUIDAR_ISLA where id_usuario is null and id_grifero is null and 
				id_isla=_id_isla and  id_sucursal=_id_sucursal and  fecha=cast(_fecha as date) and  id_turno=_id_turno) then
				update GRIFO.TBL_LIQUIDAR_ISLA set id_usuario=_id_usuarior,id_grifero=_id_colaborador 
				where id_isla=_id_isla and  id_sucursal=_id_sucursal and  fecha=cast(_fecha as date) and  id_turno=_id_turno;
			--else
				--res:=array['503','YA SE ENCUENTRA ASIGNADO UN USUARIO A LA ISLA'];
				--res:=array['0']
			end if;
		--end if;
		if not found then
			res:=array['504','Inconsistencia inesperada al regsitrar los turnos'];
		end if;
	else	
		res:=array['503','EL TURNO QUE HA SELECCIONADO YA ESTA PROGRAMADO, VUELVA A INICIAR SECCIÓN '];
	end if;
end if;
if op=2 then
	if exists (select *from  PLANILLAS.TBL_TURNOCOLABORADOR where id_turno=_id_turno and  item=_item and  id_colaborador=_id_colaborador and  fecha=cast(_fecha as date)) then
		update PLANILLAS.TBL_TURNOCOLABORADOR
				set 
				id_estado=_id_estado    ,
				observacion=_observacion   ,
				asistio =_asistio      ,
				id_sucursal=_id_sucursal   ,
				id_isla =case when _id_isla=0 then null else _id_isla end ,
				id_caja=_id_caja
				where id_turno=_id_turno and  item=_item and  id_colaborador=_id_colaborador and  fecha=cast(_fecha as date);

				update GRIFO.TBL_LIQUIDAR_ISLA set id_usuario=_id_usuarior,id_grifero=_id_colaborador 
				where id_isla=_id_isla and  id_sucursal=_id_sucursal and  fecha=cast(_fecha as date) and  id_turno=_id_turno;
				res:=array['0',_id_turno::text,_item::text,_id_colaborador::text,_fecha::text];
	else
		res:=array['503','Verefique el registro este seleccionado correctamente'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from common.spiu_empresa(2,'1','J & J SMART SOLUTIONS S.A.C','20531493835 ','JOSE GUEVARA YLATOMA','AV. BOLIVAR 1564',1,27248,'FALSE','','TRUE','TRUE','asanchez','123456','-','-','cpe@jsmartsol.com','cpe_jsmartsol','mail.jsmartsol.com','587')

CREATE OR REPLACE FUNCTION common.spiu_empresa(
	op integer,
	codigo character varying,
	_nombre character varying,
	_ruc character varying,
	_representantelegal character varying,
	_direccion character varying,
	_id_estado integer,
	_id_sector integer,
	_afecto_percepcion boolean,
	_Nro_resolucion varchar(50),
	_emisor_electronico boolean,
	_ZONA_EXONERADA boolean,
	_uss_services varchar(200),
	_pwd_services varchar(200),
	_uss_sunat varchar(200) ,
	_pwd_sunat varchar(200),
	_email_facturacion varchar(200) ,
	_pwd_facturacion varchar(200) ,
	_smtp_facturacion varchar(200) ,
	_port_facturacion varchar(200) ,
	_endpoint_mobil text,
	_genera_mobil boolean,
	_correo_ssl boolean
    )
  RETURNS text[] AS
$BODY$
declare
   correl   integer;
   res       TEXT[];
begin
if($1=1) then
	if(not exists (select * from common.tbl_empresa where nombre = _nombre)) then
		SELECT MAX(id_empresa) INTO correl FROM common.tbl_empresa;
		IF correl IS NULL THEN
			correl = 1;
		ELSE
			correl = correl + 1;
		END IF;
		
		insert into common.tbl_empresa (
			id_empresa,
			nombre,
			ruc,
			rep_legal,
			direccion,
			id_estado,
			id_sector,
			afecto_percepcion,
			Nro_resolucion,
			emisor_electronico,
			ZONA_EXONERADA,
			uss_services,
			pwd_services,
			uss_sunat ,
			pwd_sunat,
			email_facturacion,
			pwd_facturacion  ,
			smtp_facturacion ,
			port_facturacion  ,
			endpoint_mobil,
			genera_mobil,
			correo_ssl
			)
		values(
			correl, 
			_nombre,
			_ruc,
			_representantelegal,
			_direccion,
			_id_estado ,
			_id_sector,
			_afecto_percepcion,
			_Nro_resolucion,
			_emisor_electronico,
			_ZONA_EXONERADA,
			_uss_services,
			_pwd_services,
			_uss_sunat ,
			_pwd_sunat,
			_email_facturacion,
			_pwd_facturacion  ,
			_smtp_facturacion ,
			_port_facturacion,
			_endpoint_mobil,
			_genera_mobil,
			_correo_ssl
		) RETURNING array['0', tbl_empresa.id_empresa::text] INTO res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar'];
		end if;
		
	else
		res:=array['1'];
	end if;
end if;
if op=2 then
	if(exists (select * from common.tbl_empresa where id_empresa = codigo::integer)) then
		update common.tbl_empresa set 
			nombre = _nombre, 
			ruc = _ruc,
			rep_legal = _representantelegal,
			direccion = _direccion,
			id_estado = _id_estado,
			id_sector=_id_sector,
			afecto_percepcion=_afecto_percepcion,
			Nro_resolucion=_Nro_resolucion,
			emisor_electronico=_emisor_electronico,
			ZONA_EXONERADA=_ZONA_EXONERADA,
			uss_services=_uss_services,
			pwd_services=_pwd_services,
			uss_sunat=_uss_sunat ,
			pwd_sunat=_pwd_sunat,
			email_facturacion=_email_facturacion,
			pwd_facturacion=_pwd_facturacion  ,
			smtp_facturacion=_smtp_facturacion ,
			port_facturacion=_port_facturacion ,
			endpoint_mobil=_endpoint_mobil,
			genera_mobil=_genera_mobil ,
			correo_ssl=_correo_ssl
		where id_empresa = codigo::integer;
		res:=array['0',codigo::text];
	else
		res:=array['1'];
	end if;
end if;
return res;
end;$BODY$
  LANGUAGE plpgsql ;
 
  

CREATE OR REPLACE FUNCTION caja.getformaspago(
    _id_movimcaja integer,
    _id_sucursal integer)
  RETURNS text AS
$BODY$
declare
	res text;
	data record;
begin
res='';
 for data in select fp.id_formapago,fp.descripcion, dm.imp_pago,dm.nro_operacion from common.tbl_formapago fp inner join caja.tbl_detmovpago dm on (fp.id_formapago=dm.id_formapago)
	inner join common.tbl_moneda d on (d.id_moneda=dm.id_moneda)  where dm.id_movimcaja = _id_movimcaja and dm.id_sucursal=_id_sucursal loop
	res:=res || E'® F.P : '||  data.descripcion || ' Imp :' || ltrim(to_char(data.imp_pago, '999,999,999,999D99'::text)) || case when data.id_formapago='02' then ' Nro.OP: '|| COALESCE(data.nro_operacion,'') else '' end || E'\n' ;
 end loop;
return res;
end;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION caja.getformaspago(integer, integer)
  OWNER TO postgres;
  
CREATE OR REPLACE FUNCTION ALMACEN.ISP_SALDOINICIAL_EXISTENCIA(
	_id_producto varchar(20), 
	_id_unidadventa int, 
	_id_almacen int, 
	_id_inventario int,
	_stock_inicial numeric(20,4),
	_valor_incial numeric(20,4),
	_consto_inicial numeric(20,4)
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
BEGIN

if exists(select *from almacen.tbl_existencia ex  where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen and id_inventario=_id_inventario) then
	update almacen.tbl_existencia  set stock_inicial=_stock_inicial,valor_incial=_valor_incial,consto_inicial=_consto_inicial  where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_almacen=_id_almacen and id_inventario=_id_inventario;
	res:=array['0','Registro Actualizado'];
else
	res:=array['1','Verefique que exista el articulo'];
end if;

return res;
END;$$
language 'plpgsql';


select *from ventas.fn_imprimircomprobantes()

create or replace function ventas.fn_imprimircomprobantes(
	__id_preventa bigint,
	__id_sucursal integer
)
returns table(
	numdoc_facturacion char(7),
	serie char(4),
	id_comprobante integer,
	id_direccion bigint,
	id_cliente varchar(15),
	id_sucursal integer,
	documento text,
	cliente text,
	direccion text,
	fecha_venta timestamp,
	nro_documento text,
	tot_letras text,
	valor_venta numeric(20,4),
	imp_igv numeric(20,4),
	imp_total numeric(20,4),
	cantidad numeric(20,4),
	precio numeric(20,4),
	producto text,
	tot_detalle numeric(20,4),
	unidad varchar(20),
	moneda varchar(5),
	id_facturacion integer,
	id_producto varchar(20)	,
	id_almacen integer,
	id_unidadventa  integer,
	id_listaprecio integer,
	id_manguera varchar(4),
	id_lado integer,
	id_isla integer,
	id_estado integer,
	imp_dscto numeric(20,4)	,
	imp_igvdetalle numeric(20,4),
	item integer,
	impuesto numeric(20,4),
	servicio boolean,
	coste numeric(14,4),
	val_unidad numeric(14,6),
	val_minimo_venta numeric(14,6),
	id_caja integer,
	imp_recibido numeric(20,4),
	imp_vuelto numeric(20,4),
	id_vendedor varchar(15),
	vale text,
	nom_comprobante varchar(30),
	mensaje text,
	puntos numeric(20,4),
	tot_puntos numeric(20,4),
	id_turno integer,
	tipoventa varchar(30),
	vendedor text,
	ancho numeric(20,4),
	largo numeric(20,4),
	direccion_suc varchar(300),
	telefono varchar(50),
	celular varchar(50),
	ruc varchar(50)

) as $$
declare
 detalle record;
begin
create temporary table(
	id bigint primary key,
	numdoc_facturacion char(7),
	serie char(4),
	id_comprobante integer,
	id_direccion bigint,
	id_cliente varchar(15),
	id_sucursal integer,
	documento text,
	cliente text,
	direccion text,
	fecha_venta timestamp,
	nro_documento text,
	tot_letras text,
	valor_venta numeric(20,4),
	imp_igv numeric(20,4),
	imp_total numeric(20,4),
	cantidad numeric(20,4),
	precio numeric(20,4),
	producto text,
	tot_detalle numeric(20,4),
	unidad varchar(20),
	moneda varchar(5),
	id_facturacion integer,
	id_producto varchar(20)	,
	id_almacen integer,
	id_unidadventa  integer,
	id_listaprecio integer,
	id_manguera varchar(4),
	id_lado integer,
	id_isla integer,
	id_estado integer,
	imp_dscto numeric(20,4)	,
	imp_igvdetalle numeric(20,4),
	item integer,
	impuesto numeric(20,4),
	servicio boolean,
	coste numeric(14,4),
	val_unidad numeric(14,6),
	val_minimo_venta numeric(14,6),
	id_caja integer,
	imp_recibido numeric(20,4),
	imp_vuelto numeric(20,4),
	id_vendedor varchar(15),
	vale text,
	nom_comprobante varchar(30),
	mensaje text,
	puntos numeric(20,4),
	tot_puntos numeric(20,4),
	id_turno integer,
	tipoventa varchar(30),
	vendedor text,
	ancho numeric(20,4),
	largo numeric(20,4),
	direccion_suc varchar(300),
	telefono varchar(50),
	celular varchar(50),
	ruc varchar(50)

) on commit drop;
 for detalle in  select fecha,doc_persona,cliente,moneda,tipo_venta,imp_bruto,imp_dscto,valor_venta,imp_igv,imp_total,usuario,estado,serie,numero,vendedor,id_vendedor,glosa,id_cliente,id_direccion, from ventas.V_CABPREVENTA   where id_estado=1 and id_cotizapreventa::text || id_sucursal::text=(__id_preventa::text||__id_sucursal::text) and cantidad_pendiente>0 loop
	
 end loop;
 
return query select * from ventas.v_impdocventas   where  id_facturacion::text ||  id_sucursal::text='2082' ;
end;$$
language 'plpgsql';



CREATE OR REPLACE FUNCTION ventas.isp_unidadesitems(
    op integer,
    _id_cotizapreventa bigint,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _item integer,
    _id_items bigint,
    _id_cateintem integer,
    _cantidad numeric,
    _precio numeric,
    _ancho numeric,
    _largo numeric,
    _id_unidaditem integer,
    _area numeric,
    _id_estado integer,
    _id_retazo bigint
    )
  RETURNS text[] AS
$BODY$
DECLARE 
	res text[];
BEGIN
if op=1 then
	if exists(select *from ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa)then
		select max(id_items) into _id_items from ventas.tbl_items;
			if _id_items is null then
				_id_items:=1;
			else
				_id_items:=_id_items+1;
			end if;
		INSERT INTO ventas.tbl_items(
			id_cotizapreventa, 
			id_producto, 
			id_unidadventa, 
			id_listaprecio, 
			item, 
			id_items, 
			id_cateintem, 
			cantidad, 
			precio, 
			ancho, 
			largo,
			id_unidaditem,
			area,
			id_estado,
			id_retazo
		)
		VALUES (
			_id_cotizapreventa, 
			_id_producto, 
			_id_unidadventa, 
			_id_listaprecio, 
			_item, 
			_id_items, 
			_id_cateintem, 
			_cantidad, 
			_precio, 
			_ancho, 
			_largo,
			_id_unidaditem,
			_area,
			_id_estado,
			_id_retazo
		)returning array['0','Proceso efectuado con exito'] into res;
		if not found then
			res:=array['504','Inconsistencia inesperada al registrar las medidas de la cotización'];
		end if;
	else
		res:=array['504','Verefique que haya seleccionado correctamente el producto del detalle'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_items where id_items=_id_items)then
		UPDATE ventas.tbl_items
			SET 
				id_cateintem=_id_cateintem,
				cantidad=_cantidad, 
				precio=_precio, 
				ancho=_ancho, 
				largo=_largo,
				id_unidaditem=_id_unidaditem,
				area=_area,
				id_estado=id_estado,
				id_retazo=_id_retazo
		 WHERE  id_items=_id_items;
		RES:=ARRAY['0','Actualización efectuada con exito'];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION ventas.isp_detpreventa(
    op integer,
    _id_cotizapreventa bigint,
    _id_sucursal integer,
    _cantidad numeric,
    _precio numeric,
    _imp_dscto numeric,
    _imp_igv numeric,
    _imp_total numeric,
    _descripcion_linea text,
    _id_estado integer,
    _id_producto character varying,
    _id_unidadventa integer,
    _id_listaprecio integer,
    _lp integer,
    _item integer,
    _tipo character,
    _modotexto boolean,
    _observaciones text,
    _id_almacen integer,
    _id_unimedventa integer,
    _ancho numeric,
    _largo numeric,
    _sugeta_percepcion boolean,
    _tipo_documento character,
    _imp_percepcion numeric,
    _porcent_percepcion numeric,
    _precio_sinpercepcion numeric,
    _id_retazo bigint
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
	_correl_item integer;
BEGIN
if op=1 then
	if exists(select *from  ventas.tbl_cotizacionpreventa where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal) then
		if exists(select *from almacen.tbl_precio where id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio) then
			select max(item) into _correl_item from ventas.tbl_detpreventacotiza where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal;
			if _correl_item is null then
				_correl_item=1;
			else
				_correl_item:=_correl_item+1;
			end if;
			INSERT INTO ventas.tbl_detpreventacotiza(
				id_cotizapreventa, 
				id_sucursal, 
				cantidad, 
				precio, 
				imp_dscto, 
				imp_igv, 
				imp_total, 
				descripcion_linea, 
				id_estado, 
				id_producto, 
				id_unidadventa, 
				id_listaprecio, 
				lp, 
				item, 
				tipo, 
				modotexto, 
				observaciones,
				id_almacen,
				id_unimedventa,
				ancho,
				largo,
				imp_percepcion,
				porcent_percepcion,
				precio_sinpercepcion,
				id_retazo
			)
			VALUES (
				_id_cotizapreventa, 
				_id_sucursal, 
				_cantidad, 
				_precio, 
				_imp_dscto, 
				_imp_igv, 
				_imp_total, 
				_descripcion_linea, 
				_id_estado, 
				_id_producto, 
				_id_unidadventa, 
				_id_listaprecio, 
				_lp, 
				_item, 
				_tipo, 
				_modotexto, 
				_observaciones,
				case when _id_almacen=0 then 1 else _id_almacen end,
				_id_unimedventa,
				_ancho,
				_largo,
				_imp_percepcion,
				_porcent_percepcion,
				_precio_sinpercepcion,
				_id_retazo
			) returning array['0',id_cotizapreventa::text, id_sucursal::text] into res;
			if not found then
				res:=array['504','Inconsistencia inesperada al registrar el detalle de la cotizacion'];
			end if;
		else
			res:=array['503','Verefique que este seleccionado correctamente el producto : idprdod'|| _id_producto || '  _id_unidadventa :' || _id_unidadventa ];
		end if;
	else
		res:=array['504','Ingrese correctamente los datos de la cabecera de la cotizacion'];
	end if;
end if;
if op=2 then
	if exists(select *from ventas.tbl_detpreventacotiza 
		where id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and id_listaprecio=_id_listaprecio and item=_item) then
		UPDATE ventas.tbl_detpreventacotiza
		   SET  cantidad=_cantidad, 
			precio=_precio, 
			imp_dscto=_imp_dscto, 
		        imp_igv=_imp_igv, 
		        imp_total=_imp_total, 
		        descripcion_linea=_descripcion_linea, 
		        id_estado=_id_estado, 
		        lp=_lp,
		        tipo=_tipo, 
		        modotexto=_modotexto, 
		        observaciones=_observaciones,
		        id_almacen=_id_almacen,
		        id_unimedventa=_id_unimedventa,
		        ancho=_ancho,
		        largo=_largo,
		        imp_percepcion=_imp_percepcion,
			porcent_percepcion=_porcent_percepcion,
			precio_sinpercepcion=_precio_sinpercepcion,
			id_retazo=_id_retazo
		 WHERE id_cotizapreventa=_id_cotizapreventa and id_sucursal=_id_sucursal and 
			id_producto=_id_producto and id_unidadventa=_id_unidadventa and 
			id_listaprecio=_id_listaprecio and item=_item;
		res:=array['0','Proceso efectuado con exito'];
		
	else
		res:=array['504','Verefique que exista el producto :' || _descripcion_linea::text];
	end if;
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from VENTAS.FN_VENTAS_DIARIAS_VENDEDOR('19/09/2016');

CREATE OR REPLACE FUNCTION VENTAS.FN_VENTAS_DIARIAS_VENDEDOR(
	__fecha_venta text
)
RETURNS TABLE(
	_CLIENTE VARCHAR(100),
	_CondicionCliente TEXT,
	_CANTIDAD NUMERIC(14,4),
	_PRODUCTO VARCHAR(200),
	_PRECIO NUMERIC(14,4),
	_IMP_NETO  NUMERIC(20,4),
	_TIPOVENTA VARCHAR(20),
	_VENDEDOR TEXT,
	_FAMILIA VARCHAR(100) ,
	_id_cliente varchar(15)
) AS $$
DECLARE

BEGIN
 RETURN QUERY	SELECT 
		CLI.NOMBRE_RAZON AS CLIENTE,
		CASE WHEN COALESCE(Z.CANTIDAD,0)=1 THEN 'NUEVO' ELSE 'EMPADRONADO' END AS CondicionCliente,
		DF.CANTIDAD,
		P.DESCRIPCION_LARGA AS PRODUCTO,
		DF.PRECIO,
		F.IMP_NETO ,
		TV.DESCRIPCION_LARGA AS TIPOVENTA,
		COALESCE(VEND.APELL_PATERNO || ' ' || VEND.APELL_MATERNO || ' ' || VEND.NOMBRES,VEND.NOMBRE_RAZON) AS VENDEDOR,
		FA.DESCRIPCION_LARGA AS FAMILIA,
		cli.id_persona as Id_cliente
	FROM VENTAS.TBL_FACTURACION F
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	LEFT JOIN (SELECT COUNT(*)  AS CANTIDAD,DD.ID_PERSONA  FROM VENTAS.TBL_FACTURACION FF 
		    INNER JOIN VENTAS.TBL_DIRECCION DD ON DD.ID_DIRECCION=FF.ID_DIRECCION 
		    INNER JOIN PLANILLAS.TBL_PERSONA PP ON PP.ID_PERSONA=DD.ID_PERSONA
			WHERE FF.FECHA_VENTA::DATE=PP.FECHA_REG::DATE GROUP BY DD.ID_PERSONA 
		    ) Z ON Z.ID_PERSONA=F.ID_CLIENTE
	/*LEFT JOIN (SELECT FF.ID_FACTURACION,FF.ID_SUCURSAL,DFF.CANTIDAD,PP.DESCRIPCION_LARGA AS PRODUCTO,DFF.ID_PRODUCTO FROM VENTAS.TBL_FACTURACION FF 
			INNER JOIN VENTAS.TBL_DETFACTURACION DFF ON FF.ID_FACTURACION=DFF.ID_FACTURACION AND FF.ID_SUCURSAL=DFF.ID_SUCURSAL
			INNER JOIN ALMACEN.TBL_DETPRODUCTO DDP ON DDP.ID_PRODUCTO=DFF.ID_PRODUCTO AND DDP.id_unidadventa=DFF.id_unidadventa
			INNER JOIN ALMACEN.TBL_PRODUCTO PP ON PP.ID_PRODUCTO=DDP.ID_PRODUCTO
			INNER JOIN ALMACEN.TBL_FAMILIA FFA ON FFA.ID_FAMILIA=PP.ID_FAMILIA
			WHERE trim(Ffa.id_grupo)::integer=6
		) Z2 ON F.ID_FACTURACION=Z2.ID_FACTURACION AND F.ID_SUCURSAL=Z2.ID_SUCURSAL AND DF.ID_PRODUCTO<>Z2.ID_PRODUCTO*/
	WHERE fa.id_familia<>'6' and -- trim(df.id_producto)::integer<>43 and
	 F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	order by 
	trim(vend.id_persona),trim(cli.id_persona),fa.id_familia;
		
	
END;$$
LANGUAGE 'plpgsql';




CREATE OR REPLACE FUNCTION VENTAS.FN_VENTAS_DIARIAS_FAMILIA(
	__fecha_venta text
)
RETURNS TABLE(
	_VENDEDOR  TEXT,
	_CANTIDAD NUMERIC(14,4),
	_FAMILIA VARCHAR(100)
) AS $$
DECLARE

BEGIN
 RETURN QUERY	SELECT 		
		COALESCE(VEND.APELL_PATERNO || ' ' || VEND.APELL_MATERNO || ' ' || VEND.NOMBRES,VEND.NOMBRE_RAZON) AS VENDEDOR,
		SUM(DF.CANTIDAD) AS CANTIDAD,		
		FA.DESCRIPCION_LARGA AS FAMILIA
	FROM VENTAS.TBL_FACTURACION F
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	WHERE   F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY COALESCE(VEND.APELL_PATERNO || ' ' || VEND.APELL_MATERNO || ' ' || VEND.NOMBRES,VEND.NOMBRE_RAZON),FA.DESCRIPCION_LARGA,trim(vend.id_persona),fa.id_familia
	order by 
	trim(vend.id_persona),fa.id_familia;
		
	
END;$$
LANGUAGE 'plpgsql';



CREATE OR REPLACE FUNCTION VENTAS.FN_VENTAS_DIARIAS_FAMILIA_PRODUCTO(
	__fecha_venta text
)
RETURNS TABLE(
	_CANTIDAD NUMERIC(14,4),
	_FAMILIA VARCHAR(100),
	_PRODUCTO VARCHAR(100)
) AS $$
DECLARE

BEGIN
 RETURN QUERY	SELECT 				 
		SUM(DF.CANTIDAD) AS CANTIDAD,		
		FA.DESCRIPCION_CORTA AS FAMILIA,
		P.DESCRIPCION_LARGA AS PRODUCTO
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	WHERE   F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY FA.DESCRIPCION_CORTA,P.DESCRIPCION_LARGA
	order by 
	FA.DESCRIPCION_CORTA,P.DESCRIPCION_LARGA;
		
	
END;$$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION VENTAS.FN_VENTAS_DIARIAS_FAMILIA_TV(
	__fecha_venta text
)
RETURNS TABLE(
	_CANTIDAD NUMERIC(14,4),
	_FAMILIA VARCHAR(100),
	_TV VARCHAR(100)
) AS $$
DECLARE

BEGIN
 RETURN QUERY	SELECT 				 
		SUM(DF.CANTIDAD) AS CANTIDAD,		
		FA.DESCRIPCION_LARGA AS FAMILIA,
		TV.DESCRIPCION_LARGA AS TV
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	WHERE trim(FA.id_familia) not in('10','6') and  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY FA.DESCRIPCION_LARGA,TV.DESCRIPCION_LARGA
	order by 
	FA.DESCRIPCION_LARGA,TV.DESCRIPCION_LARGA;
		
	
END;$$
LANGUAGE 'plpgsql';



CREATE OR REPLACE FUNCTION VENTAS.FN_VENTAS_DIARIAS_ZONA(
	__fecha_venta text
)
RETURNS TABLE(
	_DISTRITO VARCHAR(30),
	_CONTADO  NUMERIC(20,3),
	_CREDITO NUMERIC(20,3)
) AS $$
DECLARE

BEGIN
 RETURN QUERY
select t.distrito, sum(contado) as contado,sum(credito) as credito  
from (
	select dis.distrito, sum(df.cantidad) as contado,0 as credito from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	inner join ventas.tbl_direccion dir on dir.id_direccion=f.id_direccion and dir.id_persona=f.id_cliente
	inner join ventas.tbl_sector s on s.id_sector=dir.id_sector
	inner join ventas.tbl_zona z on z.id_zona=s.id_zona
	inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
	inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa 
	where f.id_tipoventa=1 and  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 AND FA.ID_FAMILIA  IN('3') and f.nota-credito=false
	group by dis.distrito
	union all
	select dis.distrito, 0  as contado, sum(df.cantidad)  as credito from ventas.tbl_facturacion f 
	inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	inner join ventas.tbl_direccion dir on dir.id_direccion=f.id_direccion and dir.id_persona=f.id_cliente
	inner join ventas.tbl_sector s on s.id_sector=dir.id_sector
	inner join ventas.tbl_zona z on z.id_zona=s.id_zona
	inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
	inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa 
	where f.id_tipoventa=2 and  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1  AND FA.ID_FAMILIA  IN('3') and f.nota_credito=false
	group by distrito
) as t
group by t.distrito;
END;$$
LANGUAGE 'plpgsql';




CREATE OR REPLACE FUNCTION VENTAS.FN_RESUMEN_VENTAS_DIARIAS_VENDEDOR(
	__fecha_venta text
)  RETURNS TABLE(
	_VENDEDOR VARCHAR(30),
	_HARINAS  NUMERIC(20,3),
	_MANTECA NUMERIC(20,3),
	_LEVADURA NUMERIC(20,3),
	_MEJORADOR NUMERIC(20,3),
	_TOTAL NUMERIC(20,3)
	
) AS $$
DECLARE

BEGIN
 RETURN QUERY
SELECT PRODUCTO,SUM(HARINAS) AS HARINAS,SUM(MANTECA) AS MANTECA,SUM(LEVADURA) AS LEVADURA,SUM(MEJORADOR) AS MEJORADOR,(SUM(HARINAS) + SUM(MANTECA) + SUM(LEVADURA) +SUM(MEJORADOR)) AS TOTAL FROM (

SELECT 				 
		VEND.NOMBRE_RAZON AS PRODUCTO,
		SUM(DF.CANTIDAD) AS HARINAS,
		0 AS MANTECA,
		0 AS LEVADURA,
		0 AS MEJORADOR			
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
	WHERE  FA.ID_FAMILIA::INTEGER=3 AND  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY VEND.NOMBRE_RAZON  
	--order by VEND.NOMBRE_RAZON  
	UNION ALL	
	SELECT 				 
		VEND.NOMBRE_RAZON AS PRODUCTO,
		0 AS HARINAS,
		SUM(DF.CANTIDAD) AS MANTECA,
		0 AS LEVADURA,
		0 AS MEJORADOR			
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
	WHERE  FA.ID_FAMILIA::INTEGER=5 AND  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY VEND.NOMBRE_RAZON  
	UNION ALL
	SELECT 				 
		VEND.NOMBRE_RAZON AS PRODUCTO,
		0 AS HARINAS,
		0 AS MANTECA,
		SUM(DF.CANTIDAD) AS LEVADURA,
		0 AS MEJORADOR			
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
	WHERE  FA.ID_FAMILIA::INTEGER=8 AND  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota-credito=false
	GROUP BY VEND.NOMBRE_RAZON  
	UNION ALL	
	SELECT 				 
		VEND.NOMBRE_RAZON AS PRODUCTO,
		0 AS HARINAS,
		0 AS MANTECA,
		0 AS LEVADURA,
		SUM(DF.CANTIDAD) AS MEJORADOR			
	FROM VENTAS.TBL_FACTURACION F	
	INNER JOIN VENTAS.TBL_DIRECCION DIR ON DIR.ID_PERSONA=F.ID_CLIENTE AND F.ID_DIRECCION=DIR.ID_DIRECCION
	INNER JOIN PLANILLAS.TBL_PERSONA CLI ON CLI.ID_PERSONA=DIR.ID_PERSONA
	INNER JOIN COMMON.TBL_TIPOVENTA TV ON TV.ID_TIPOVENTA=F.ID_TIPOVENTA
	INNER JOIN VENTAS.TBL_DETFACTURACION DF ON DF.ID_FACTURACION=F.ID_FACTURACION AND F.ID_SUCURSAL=DF.ID_SUCURSAL
	INNER JOIN ALMACEN.TBL_DETPRODUCTO DP ON DP.ID_PRODUCTO=DF.ID_PRODUCTO AND DP.id_unidadventa=DF.id_unidadventa
        INNER JOIN ALMACEN.TBL_PRODUCTO P ON P.ID_PRODUCTO=DP.ID_PRODUCTO
        INNER JOIN ALMACEN.TBL_FAMILIA FA ON FA.ID_FAMILIA=P.ID_FAMILIA
	INNER JOIN PLANILLAS.TBL_PERSONA VEND ON VEND.ID_PERSONA=CLI.ID_VENDTITULAR
	WHERE  FA.ID_FAMILIA::INTEGER=9 AND  F.FECHA_VENTA::DATE=__fecha_venta::DATE AND F.ID_ESTADO=1 and f.nota_credito=false
	GROUP BY VEND.NOMBRE_RAZON 
	order by PRODUCTO  

) CT GROUP BY PRODUCTO;
END;$$
LANGUAGE 'plpgsql';

CREATE OR  REPLACE FUNCTION VENTAS.FN_CAMBIAR_MESAS(
	_id_mesacomanda bigint,
	_id_mesa integer
)
RETURNS TEXT[] AS $$
DECLARE
	res text[];
	
BEGIN
IF EXISTS(select 1 from restaurant.tbl_comandamesa where id_mesacomanda=_id_mesacomanda)THEN
	update restaurant.tbl_comandamesa set id_mesa=_id_mesa where id_mesacomanda=_id_mesacomanda;
	res:=array['0','Proceso realizado'];
 ELSE
	res:=array['503','El registro no existe'];
END IF;
return res;
END;$$
LANGUAGE 'plpgsql';


select * from ventas.FN_ACTUALIZA_SUNAT(24,1,'0','04','',NULL,'TmpK5+YqnFcCSzxeIYxEC3AK2dY=','jeb+hRpZZ5Zk1Wb7P1rzgBqdVXDQETMU8Cds77dr3P822Q2o0LJxaZ64Bf2V8bbawfPtvO8bawI7s3QAUR0ntIT+z9RjnF7Cy4hfGhGznALOzd8d+XVWySzlo5Fecro6eBq+8r/R47laY+gpWiw0EqMWeYhyiIIMwNNjlNp6MGI=')

CREATE OR REPLACE FUNCTION ventas.fn_actualiza_sunat(
    _id_facturacion integer,
    _id_sucursal integer,
    _status_sunat boolean,
    _code_sunat character varying,
    _message_sunat character varying,
    _observation_sunat character varying,
    _digestvalue character varying,
    _signaturevalue character varying,
    _ticket varchar(50)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal)then
	UPDATE VENTAS.TBL_FACTURACION SET
		STATUS_SUNAT=_STATUS_SUNAT,
		CODE_SUNAT=_CODE_SUNAT,
		MESSAGE_SUNAT=_MESSAGE_SUNAT,
		OBSERVATION_SUNAT=_OBSERVATION_SUNAT,
		DigestValue=_DigestValue,
		SignatureValue=_SignatureValue,
		Ticket=_Ticket
	 WHERE id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
	 res:=array['0','Registro Actualizado'];
else
	res:=array['0','Registro No existe'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select * from ventas.fn_actualiza_sunat_status(14,1,'TRUE','La Factura numero F001-0000001, ha sido aceptada','0',1,'')

CREATE OR REPLACE FUNCTION ventas.fn_actualiza_sunat_status(
    _id_facturacion integer,
    _id_sucursal integer,
    _status_sunat boolean,
    _message_sunat character varying,
    _code_sunat varchar(10) ,
    _enviado_status integer ,
    _observacion_sunat text  
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select 1 from ventas.tbl_facturacion where id_facturacion=_id_facturacion and id_sucursal=_id_sucursal)then
	UPDATE VENTAS.TBL_FACTURACION SET
		STATUS_SUNAT=_STATUS_SUNAT,		 
		MESSAGE_SUNAT=_MESSAGE_SUNAT,
		code_sunat=_code_sunat,
		enviado_status=_enviado_status,
		observation_sunat=_observacion_sunat,
		fecha_envio=now()  
	 WHERE id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
	 res:=array['0','Registro Actualizado'];
else
	res:=array['0','Registro No existe'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


select *from ventas.tbl_facturacion
select *from almacen.V_SERIE_PRODUCTO_MOVIMIENTOS

select *from seguridad.item where menu  ilike '%serie%'

CREATE OR REPLACE FUNCTION ventas.fn_actualiza_sunat_guia_remsion_status(
    _id_guia integer,
    _id_sucursal integer,
    _status_sunat boolean,
    _message_sunat character varying    
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select 1 from ventas.tbl_guiaremisionventa where id_guia=_id_guia and id_sucursal=_id_sucursal)then
	UPDATE VENTAS.tbl_guiaremisionventa SET
		STATUS_SUNAT=_STATUS_SUNAT,		 
		MESSAGE_SUNAT=_MESSAGE_SUNAT
		  
	 WHERE id_facturacion=_id_facturacion and id_sucursal=_id_sucursal;
	 res:=array['0','Registro Actualizado'];
else
	res:=array['0','Registro No existe'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

select *from ventas.tbl_facturacion
select *from VENTAS.tbl_guiaremisionventa

CREATE OR REPLACE FUNCTION ventas.fn_actualiza_guia_rem_sunat(
    _id_guia integer,
    _id_sucursal integer,
    _status_sunat boolean,
    _code_sunat character varying,
    _message_sunat character varying,
    _observation_sunat character varying,
    _digestvalue character varying,
    _signaturevalue character varying,
    _ticket varchar(50)
    )
  RETURNS text[] AS
$BODY$
DECLARE
	res text[];
BEGIN
if exists(select 1 from VENTAS.tbl_guiaremisionventa where id_guia=_id_guia and id_sucursal=_id_sucursal)then
	UPDATE VENTAS.tbl_guiaremisionventa SET
		STATUS_SUNAT=_STATUS_SUNAT,
		CODE_SUNAT=_CODE_SUNAT,
		MESSAGE_SUNAT=_MESSAGE_SUNAT,
		OBSERVATION_SUNAT=_OBSERVATION_SUNAT,
		DigestValue=_DigestValue,
		SignatureValue=_SignatureValue,
		Ticket=_Ticket
	 WHERE id_guia=_id_guia and id_sucursal=_id_sucursal;
	 res:=array['0','Registro Actualizado'];
else
	res:=array['0','Registro No existe'];
end if;
return res;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;  
  
select *from ventas.tbl_facturacion

SELECT *FROM  VENTAS.FN_RESUMEN_VENTAS_DIARIAS_VENDEDOR('02/09/2016')

select dis.distrito, df.cantidad,tv.descripcion_larga as tv from ventas.tbl_facturacion f 
inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion
inner join ventas.tbl_direccion dir on dir.id_direccion=f.id_direccion and dir.id_persona=f.id_cliente
inner join planillas.tbl_persona cli on cli.id_persona=dir.id_persona
inner join ventas.tbl_sector s on s.id_sector=dir.id_sector
inner join ventas.tbl_zona z on z.id_zona=s.id_zona
inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa




SELECT * 
FROM crosstab( 'select dis.distrito,tv.id_tipoventa as tv, sum(df.cantidad) as cantidad from ventas.tbl_facturacion f 
inner join ventas.tbl_detfacturacion df on f.id_facturacion=df.id_facturacion and f.id_sucursal=df.id_sucursal
inner join ventas.tbl_direccion dir on dir.id_direccion=f.id_direccion and dir.id_persona=f.id_cliente
inner join ventas.tbl_sector s on s.id_sector=dir.id_sector
inner join ventas.tbl_zona z on z.id_zona=s.id_zona
inner join common.tbl_distrito dis on dis.id_distrito=z.id_distrito
inner join common.tbl_tipoventa tv on tv.id_tipoventa=f.id_tipoventa 
group by dis.distrito,tv.id_tipoventa',
                'select m from generate_series(1,2) m') 
     AS  (distrito text, contado NUMERIC(14,3), 
		   credito NUMERIC(14,3));
     

group by distrito,id_tipoventa

select *from almacen.tbl_grupo

SELECT *FROM COMMON.TBL_TIPOVENTA
SELECT *FROM PLANILLAS.TBL_PERSONA
select *from VENTAS.FN_VENTAS_DIARIAS_FAMILIA_PRODUCTO('09/09/2016')
select * from VENTAS.FN_VENTAS_DIARIAS_FAMILIA_TV('08/09/2016')



select * from ALMACEN.isp_grabarexistencias(1,'002985',120,1,1,'Registro por productos','1','0.00','0.00','0')

select * from compras.rpt_comprasporproveedor('otrocursor','04/12/2020','04/12/2020','','9','');
fetch all from otrocursor